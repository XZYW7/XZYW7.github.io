<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    【笔记】Cherno Opengl Tutorial note 02 |
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-TA/OpenGL/Opengl learning_02" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    【笔记】Cherno Opengl Tutorial note 02
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/09/10/TA/OpenGL/Opengl%20learning_02/" class="article-date">
  <time datetime="2022-09-10T15:04:12.000Z" itemprop="datePublished">2022-09-10</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h2 id="08-How-I-Deal-with-Shaders"><a href="#08-How-I-Deal-with-Shaders" class="headerlink" title="08 How I Deal with Shaders"></a><strong>08 How I Deal with Shaders</strong></h2><p>在之前的着色器编写中，对于每个字符串都要加引号和换行符，这是非常不方便的。</p>
<p>因此我们需要从文件读取shader。</p>
<p>一般来说会把vs和fs分成两个文件。但作者认为两个文件也很不方便，而是把vs和fs合并在一起（shaderlab就是这样做的）。并且在文件中对两部分进行区别。</p>
<p>在项目文件夹中新建resource文件夹，包含shaders文件夹，（以后也可能添加纹理、模型等资源），创建一个后缀为shader的文件</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824221249780.png" alt="image-20220824221249780"></p>
<p>将着色器的代码粘贴到文件中，并分别加上指定vs和fs编译的宏（可以用替换的功能去掉引号和换行符）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec4 position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color = <span class="built_in">vec4</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们要做的是把这个文件转换成std字符串。读文件采用fstream设置文件流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span>&#123;</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FrgmentSource;</span><br><span class="line">&#125;;<span class="comment">// 为了返回多重数据而制作一个结构体</span></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span> &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">	std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line)) &#123;<span class="comment">//string头文件中的getline方法</span></span><br><span class="line">    	<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>)!=std::string::npos)&#123;</span><br><span class="line">            <span class="comment">//std::string::npos,表示字符串末尾（无效字符串）</span></span><br><span class="line">            <span class="keyword">if</span>(line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>)!=std::string::npos)&#123;</span><br><span class="line">                <span class="comment">// set mode to vertex</span></span><br><span class="line">            	type = ShaderType::VERTEX;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>)!=std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把代码添加到vs或fs的字符串流中</span></span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt;line&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  &#123;ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ShaderProgramSource source= <span class="built_in">ParseShader</span>(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line"><span class="comment">//我们这里使用相对路径，可执行文件的默认工作目录是可执行文件的目录，而visual studio调试器运行，工作目录是可设置的</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824224240477.png" alt="image-20220824224240477" style="zoom:50%;" />

<p>将解析的着色器代码输出出来，一切正常</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824224450410.png" alt="image-20220824224450410"></p>
<p>那么我们实现了从一个文件里读取vs和fs，这部分修改就完成了</p>
<h2 id="09-Index-Buffers"><a href="#09-Index-Buffers" class="headerlink" title="09 Index Buffers"></a><strong>09 Index Buffers</strong></h2><ul>
<li>Index Buffer是什么</li>
</ul>
<p>我们已经画好了一个三角形。我们如果想画一个正方形呢？实际上，也是由三角形组成的。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824230232057.png" alt="image-20220824230232057" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="comment">// 第二个三角形</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相应地，顶点缓冲区大小也增大了，绘制方法也需要改成6个顶点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>我们成功地 绘制出了想要的正方形&#x2F;长方形</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824230651997.png" alt="image-20220824230651997" style="zoom:50%;" />

<p>但是实际上顶点数组发生了大量重复，这也浪费了内存，尤其是顶点储存属性很多时。</p>
<p>因此我们使用索引缓冲Index Buffer，使顶点能够重复使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">&#125;;<span class="comment">//01230</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">	<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line">&#125;;<span class="comment">//必须使用无符号类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点缓冲</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;<span class="comment">//index buffer object</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//drawcall的变化</span></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);<span class="comment">//GL_INT就出现了问题，无法渲染出画面，而index  buffer是无符号的</span></span><br></pre></td></tr></table></figure>

<p>也非常顺利</p>
<h2 id="10-Dealing-with-Errors"><a href="#10-Dealing-with-Errors" class="headerlink" title="10 Dealing with Errors"></a><strong>10 Dealing with Errors</strong></h2><p>这里讨论的是Opengl提供的检查错误的方法，不会用到外部工具</p>
<p>主要有两种方法</p>
<p>glGetError</p>
<p>使用glGetError的工作流程是首先在opengl的每个函数调用前，&#x3D;&#x3D;在循环中调用&#x3D;&#x3D;，直到清除所有错误。</p>
<p>glMessageCallBack是opengl4.3添加的功能，允许我们指定一个指向Opengl函数的指针，比glGetError更方便。这一集教程中只关注glGetError。</p>
<ul>
<li>返回值flag</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825000148080.png" alt="image-20220825000148080"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">glGetError</span>()!=GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLCheckError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;[OpenGL Error] (&quot;</span>&lt;&lt; error &lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="built_in">GLClearError</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>);<span class="comment">//前面的符号类型错误</span></span><br><span class="line"><span class="built_in">GLCheckError</span>();</span><br></pre></td></tr></table></figure>

<p>控制台打印出1280的错误</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825000933480.png" alt="image-20220825000933480"></p>
<p>在glew.h中 ，会发现各种宏的定义都是16进制的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825001114710.png" alt="image-20220825001114710"></p>
<p>因此我们把1280转换成16进制，如果懒得搜的话，在断点 中定位到变量，右键可以选择16进制显示，这里结果是0x00000500，</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825001334790.png" alt="image-20220825001334790" style="zoom:50%;" />

<p>在glew.h中搜索，我们可以找到是GL_INVALID_ENUM的错误，也就是说，在我们检查的glDrawElements函数中，传递了一个无效的枚举类型参数。也就是GL_INT</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825001532054.png" alt="image-20220825001532054"></p>
<p>那么，最终的问题是，对于每个函数都做这样的处理太过麻烦，也会污染代码。所以我们最好知道错误发生在哪里 。</p>
<p>在这里我们已经设置了断点，当然我们在堆栈中可以找到具体的出现问题的函数。我们也可以用ASSERT来做这件事，如果条件不成立，通常发送一个消息到控制台，或是停止程序的执行 。这相当于用代码来设置断点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">glGetError</span>()!=GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;[OpenGL Error] (&quot;</span>&lt;&lt; error &lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">GLClearError</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(<span class="built_in">GLLogCall</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后自动触发了断点</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825003024764.png" alt="image-20220825003024764"></p>
<p>我们还可以再设置一宏命令来简化这个过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">		x;\</span></span><br><span class="line"><span class="meta">		ASSERT(GLLogCall())</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">GLCALL</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>

<p>非常好用。</p>
<p>还要解决的问题是，我们的错误消息并不能指定实际错误发生在哪个文件或行上，甚至函数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt; </span><br><span class="line">            <span class="string">&quot; &quot;</span>&lt;&lt; file&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;line&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更好用了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825004247444.png" alt="image-20220825004247444"></p>
<p>接下来我们要做的就是把每个opengl方法用GLCall包装起来。</p>
<p>有一些情况会为GLCall添加if、while等作用域，但是这样就无法使用于赋值的构造函数语句等，因为这会让创建的变量无法被调用，因为超出了作用域（相当于封装在了一个{}scope中）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreaateProgram</span>());</span><br><span class="line"><span class="comment">//这是可以使用的，但是添加作用域后不能使用，相当于把它放进了大括号</span></span><br></pre></td></tr></table></figure>



<h2 id="11-Uniforms"><a href="#11-Uniforms" class="headerlink" title="11 Uniforms"></a><strong>11 Uniforms</strong></h2><p>Uniform是一种从CPU获取数据的方式。</p>
<p>在交互时着色器变量有可能需要更新， 因此C++的变量通过Uniform传递到着色器。</p>
<p>我们在每次绘制前设置uniform</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Basic.shader</span></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"></span><br><span class="line">uniform vec4 u_Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color = u_Color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建着色器后，每个uniform都会被分配一个ID，并通过ID检索该变量的位置</span></span><br><span class="line"><span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>);</span><br><span class="line"><span class="comment">//如果在着色器中声明了但没有使用uniform变量，那么opengl编译时会舍弃该变量</span></span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">glUniform4f</span>(location, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<p>通过Uniform来对变量进行变化控制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">glUniform4f</span>(location, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">if</span> (r&gt;<span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span> (r&lt;<span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line">    r += increment;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(有可能会出现变化太快的问题，可以把双缓冲交换间隔设置为1。虽然我好像没有这个问题)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="12-Vertex-Arrays"><a href="#12-Vertex-Arrays" class="headerlink" title="12 Vertex Arrays"></a><strong>12 Vertex Arrays</strong></h2><ul>
<li>绑定vertex buffer</li>
<li>指定vertex layout</li>
<li>绑定index buffer</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解除绑定</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在每一帧重新绑定，结果是一样的。事实上由于每一帧绘制数据可能发生变化，正需要在这里进行绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));<span class="comment">//前面的符号类型错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们需要正确使用顶点数组，为每个几何体设置不同的顶点数组对象，然后只需要在drawcall前进行绑定。这就是VAO。</p>
<p>绘制过程</p>
<ul>
<li>绑定着色器</li>
<li>绑定顶点缓冲区</li>
<li>设置顶点布局</li>
<li>绑定index缓冲区</li>
<li>drawcall</li>
</ul>
<p>-》使用VAO</p>
<ul>
<li>绑定着色器</li>
<li>绑定顶点数组</li>
<li>绑定index缓冲</li>
<li>drawcall</li>
</ul>
<p>使用core profile</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//使用opengl最高版本或最低版本为3（3.3）</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//使用Core Profile</span></span><br><span class="line"><span class="comment">//可兼容性的opengl profile（compatbility Opengl profile）有VAO默认对象是0.但core profile没有默认对象，必须绑定VAO</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int vao;</span><br><span class="line">glGenVertexArrays(1, &amp;vao);</span><br><span class="line">glBindVertexArray(vao);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这些都绑定好后，由于Opengl的状态机属性，我们可以解除绑定。然后在drawcall前再绑定vao（把vertex buffer链接到VAO），就可以正常绘制。</p>
<ul>
<li>绑定VAO</li>
<li>绑定顶点缓冲</li>
<li>指定顶点属性指针，这时将会把顶点缓冲和VAO绑定在一起</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定VAO</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点缓冲</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;<span class="comment">//index buffer object</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定</span></span><br><span class="line"><span class="comment">//glUseProgram(0);</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);<span class="comment">//反正不要在VAO激活时解绑EBO/IBO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);</span></span><br><span class="line">	<span class="comment">//同样重要的是要注意，索引缓冲区/ELEMENT_ARRAY_BUFFER也包含在VAO状态中。它不需要按帧重新定义...因此，您也可以删除该行。  GL_ELEMENT_ARRAY_BUFFER必须在绑定顶点数组对象（glBindVertex 数组）之后绑定。GL_ELEMENT_ARRAY_BUFFER对象存储在顶点数组对象状态向量中。 如果顶点数组对象已解绑并再次绑定，则GL_ELEMENT_ARRAY_BUFFER也已知并再次绑定。但是，如果在绑定顶点数组对象时元素数组缓冲区显式解除绑定，则会从状态向量中删除该缓冲区。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));<span class="comment">//前面的符号类型错误</span></span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来的做法：</p>
<p>每次需要绘制时，绑定顶点缓冲区，指定顶点属性指针，绑定顶点索引缓冲，然后渲染。</p>
<p>VAO的方法：</p>
<p>为每个几何对象创建VAO，绑定顶点缓冲区，指定顶点属性指针，绑定顶点索引缓冲，解绑</p>
<p>在渲染该对象前绑定对应的VAO</p>
<p>LearnOpengl对此操作的描述</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#x27;s bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.</span></span><br><span class="line"><span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can unbind the VAO afterwards so other VAO calls won&#x27;t accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line"><span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在之后我们可以用class来做这件事，会方便很多。</p>
<p>每次绑定vertex buffer和VAO的方式哪种更快呢？</p>
<ul>
<li>实际上在过去使用一个VAO，每次绑定其他东西更快。</li>
<li>NVIDIA提出不建议使用VAO</li>
<li>但其实在不同环境下也可能出现不同的结果</li>
<li>如果一定特别需要压榨性能，可以看情况使用</li>
</ul>
<h2 id="13-Abstracting-Opengl-into-Class"><a href="#13-Abstracting-Opengl-into-Class" class="headerlink" title="13 Abstracting Opengl into Class"></a><strong>13 Abstracting Opengl into Class</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span> &#123;</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FrgmentSource;</span><br><span class="line">&#125;;<span class="comment">// 为了返回多重数据而制作一个结构体</span></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span> &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line)) &#123;<span class="comment">//string头文件中的getline方法</span></span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">            <span class="comment">//std::string::npos,表示字符串末尾（无效字符串）</span></span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to vertex</span></span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把代码添加到vs或fs的字符串流中</span></span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  &#123; ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">ComplieShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fail to complie &quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex &quot;</span> : <span class="string">&quot;fragment &quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">ComplieShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">ComplieShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;GlewInit fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">12</span>] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">    &#125;;<span class="comment">//01230</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">        <span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line">    &#125;;<span class="comment">//必须使用无符号类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定VAO</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点缓冲</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ibo;<span class="comment">//index buffer object</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::string vertexShader =</span></span><br><span class="line"><span class="comment">        &quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;layout(location = 0) in vec4 position;\n&quot;</span></span><br><span class="line"><span class="comment">        //和顶点属性的laout一致。</span></span><br><span class="line"><span class="comment">        //注意这里是vec4，而我们实际只有vec2，剩余的部分Opengl会默认转换z0w1</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;void main()&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#123;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;	gl_Position = position;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#125;\n&quot;;</span></span><br><span class="line"><span class="comment">    std::string fragmentShader =</span></span><br><span class="line"><span class="comment">        &quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;layout(location = 0) out vec4 color;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;void main()&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#123;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;	color = vec4(1.0,0.0,0.0,1.0);\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#125;\n&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FrgmentSource);</span><br><span class="line">    <span class="comment">//glUseProgram(shader);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建着色器后，每个uniform都会被分配一个ID</span></span><br><span class="line">    <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>);</span><br><span class="line">    <span class="comment">//如果在着色器中声明了但没有使用uniform变量，那么opengl编译时会舍弃该变量</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解除绑定</span></span><br><span class="line">    <span class="comment">//glUseProgram(0);</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line">        <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));<span class="comment">//前面的符号类型错误</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">            increment = <span class="number">-0.05f</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">            increment = <span class="number">0.05f</span>;</span><br><span class="line">        r += increment;</span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//glDeleteProgram(shader);</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里先放一放整体的代码，然后我们将要进行大的修改。</p>
<h3 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a><strong>Renderer</strong></h3><p>首先创建Renderer.h 和cpp文件。并且把错误处理的部分挪到头文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Renderer.h#################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Renderer.cpp###############</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VertexBuffer"><a href="#VertexBuffer" class="headerlink" title="VertexBuffer"></a><strong>VertexBuffer</strong></h3><p>我们再创建VertexBuffer的头文件和cpp文件,用来定义顶点缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexBuffer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBuffer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	<span class="comment">// 在其他API中，也表示是一个ID，因此用这种命名来通用地表达</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> <span class="type">int</span> size);</span><br><span class="line">	~<span class="built_in">VertexBuffer</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以右键类名后选择“快速操作和重构”，然后创建函数定义，这样IDE自动在cpp中为我们创建了各个方法的定义框架（但实际上我操作失败了，提示说所选的文本不包含任何函数签名，我只能全选下面的方法，然后再右键快速操作）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220910170329326.png" alt="image-20220910170329326"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexBuffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line">VertexBuffer::<span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VertexBuffer::~<span class="built_in">VertexBuffer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="IndexBuffer"><a href="#IndexBuffer" class="headerlink" title="IndexBuffer"></a><strong>IndexBuffer</strong></h3><p>对indexBuffer也可以用同样的做法.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#########IndexBuffer.h##############</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexBuffer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count);</span><br><span class="line">	~<span class="built_in">IndexBuffer</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//##########IndexBuffer.cpp#############</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IndexBuffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line">IndexBuffer::<span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    : <span class="built_in">m_Count</span>(count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="built_in">sizeof</span>(GLuint));</span><br><span class="line">    <span class="comment">//count*sizeof(GLuint)即使可能不会，但仍可能出现平台差异</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, count * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), data, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IndexBuffer::~<span class="built_in">IndexBuffer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a><strong>Application</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span>*<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 顶点缓冲</span></span><br><span class="line"><span class="comment">    unsigned int buffer;</span></span><br><span class="line"><span class="comment">    glGenBuffers(1, &amp;buffer);</span></span><br><span class="line"><span class="comment">    glBindBuffer(GL_ARRAY_BUFFER, buffer);</span></span><br><span class="line"><span class="comment">    glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0);</span></span><br><span class="line"><span class="comment">    glEnableVertexAttribArray(0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line"><span class="comment">    unsigned int ibo;//index buffer object</span></span><br><span class="line"><span class="comment">    glGenBuffers(1, &amp;ibo);</span></span><br><span class="line"><span class="comment">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);</span></span><br><span class="line"><span class="comment">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="14-Buffer-Layout-Abstraction"><a href="#14-Buffer-Layout-Abstraction" class="headerlink" title="14 Buffer Layout Abstraction"></a><strong>14 Buffer Layout Abstraction</strong></h2><p>我们希望用如下的结构来组织vao</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VertexArray va;</span><br><span class="line"><span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span>*<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line">va.<span class="built_in">AddBuffer</span>(vb);</span><br><span class="line"></span><br><span class="line">BufferLayout layout;</span><br><span class="line">layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>);</span><br><span class="line">va.<span class="built_in">AddLayout</span>(layout);</span><br><span class="line">....</span><br><span class="line">va.<span class="built_in">Bind</span>();</span><br></pre></td></tr></table></figure>



<h3 id="VertexArray"><a href="#VertexArray" class="headerlink" title="VertexArray"></a><strong>VertexArray</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexArray.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBufferLayout.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VertexArray</span>();</span><br><span class="line">	~<span class="built_in">VertexArray</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//VertexArray.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexArray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line">VertexArray::<span class="built_in">VertexArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VertexArray::~<span class="built_in">VertexArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    <span class="built_in">Bind</span>();</span><br><span class="line">    <span class="comment">// 绑定VBO</span></span><br><span class="line">	vb.<span class="built_in">Bind</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 顶点属性Layout</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; elements = layout.<span class="built_in">GetElements</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; elements.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; element = elements[i];</span><br><span class="line">        <span class="built_in">glVertexAttribPointer</span>(i, element.count,element.type,</span><br><span class="line">            element.normalized, layout.<span class="built_in">GetStride</span>(), (<span class="type">const</span> <span class="type">void</span>*) offset);</span><br><span class="line">        <span class="built_in">glEnableVertexAttribArray</span>(i);</span><br><span class="line">        offset += element.count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(element.type);</span><br><span class="line">        <span class="comment">//glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="VertexArrayLayout"><a href="#VertexArrayLayout" class="headerlink" title="VertexArrayLayout"></a><strong>VertexArrayLayout</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexArrayLayout.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexBufferElement</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> normalized;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetSizeOfType</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">			<span class="keyword">case</span> GL_FLOAT:			<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">			<span class="keyword">case</span> GL_UNSIGNED_INT:	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">			<span class="keyword">case</span> GL_UNSIGNED_BYTE:	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ASSERT</span>(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBufferLayout</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;VertexBufferElement&gt; m_Elements;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Stride;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VertexBufferLayout</span>()</span><br><span class="line">		: <span class="built_in">m_Stride</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">static_assert</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count) &#123;</span><br><span class="line">		m_Elements.<span class="built_in">push_back</span>(&#123; GL_FLOAT, count, GL_FALSE&#125;);</span><br><span class="line">		m_Stride += VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_FLOAT) * count;<span class="comment">//4 * 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用模板来完成不同类型顶点属性的添加，也方便进行其他类型的扩展</span></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count) &#123;</span><br><span class="line">		m_Elements.<span class="built_in">push_back</span>(&#123; GL_UNSIGNED_INT, count, GL_FALSE &#125;);</span><br><span class="line">		m_Stride += VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_INT) * count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count) &#123;</span><br><span class="line">		m_Elements.<span class="built_in">push_back</span>(&#123; GL_UNSIGNED_BYTE, count, GL_TRUE &#125;);</span><br><span class="line">		m_Stride += VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_BYTE) * count;<span class="comment">//GLbyte </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">const</span> std::vector&lt;VertexBufferElement&gt; <span class="title">GetElements</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Elements; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetStride</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Stride; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>作者在Bind和Unbind的地方其实处理得不是很舒服，受之前学长的影响，个人喜欢在添加完顶点属性后直接解绑，也就是AddBuffer函数之后，把va和vb解绑直接做掉。并且elementarray也就是IBO（EBO）Learnopengl中说过是绑定在VAO中的，可以不管。</p>
<h2 id="15-Shader-Abstraction"><a href="#15-Shader-Abstraction" class="headerlink" title="15 Shader Abstraction"></a><strong>15 Shader Abstraction</strong></h2><p>游戏和引擎中，通常有一种自定义着色语言，然后编译成每种api或平台适合的语言。并且是可控和可扩展的（着色器动态创建）。</p>
<p>我们在这里shader abstraction要完成的：</p>
<ol>
<li>能够使用文件和字符串编译shader</li>
<li>绑定和取消绑定</li>
<li>设置uniform</li>
</ol>
<h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a><strong>Shader</strong></h3><p>shader.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shader.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span><span class="comment">//hash table</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span> &#123;</span><br><span class="line">	std::string VertexSource;</span><br><span class="line">	std::string FrgmentSource;</span><br><span class="line">&#125;;<span class="comment">// 为了返回多重数据而制作一个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_FilePath;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m_UniformLocationCache;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath);</span><br><span class="line">	~<span class="built_in">Shader</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//set uniforms</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span>;</span><br><span class="line">	<span class="function">ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Shader.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shader.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line">Shader::<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath)</span><br><span class="line">    : <span class="built_in">m_FilePath</span>(filepath), <span class="built_in">m_RendererID</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ShaderProgramSource source = <span class="built_in">ParseShader</span>(filepath);</span><br><span class="line">    m_RendererID = <span class="built_in">CreateShader</span>(source.VertexSource, source.FrgmentSource);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shader::~<span class="built_in">Shader</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fail to complie &quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex &quot;</span> : <span class="string">&quot;fragment &quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ShaderProgramSource <span class="title">Shader::ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span> &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line)) &#123;<span class="comment">//string头文件中的getline方法</span></span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">            <span class="comment">//std::string::npos,表示字符串末尾（无效字符串）</span></span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to vertex</span></span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把代码添加到vs或fs的字符串流中</span></span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  &#123; ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUseProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUniform4f</span>(<span class="built_in">GetUniformLocation</span>(name), v0, v1, v2, v3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Shader::GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//优化：我们每次setUniform的时候，都需要重新GetUniformLocation，找到属性在Layout中的位置</span></span><br><span class="line">    <span class="comment">//这是多余的消耗，我们可以用hash table 把它储存起来。</span></span><br><span class="line">    <span class="keyword">if</span> (m_UniformLocationCache.<span class="built_in">find</span>(name) != m_UniformLocationCache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> m_UniformLocationCache[name];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(m_RendererID, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Warning: uniform &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#x27; dosen&#x27;t exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_UniformLocationCache[name] = location;</span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/10/TA/OpenGL/Opengl%20learning_02/" data-id="cmfe999ly0022p4uhc6422byl" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Opengl/" rel="tag">Opengl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2022/09/12/TA/OpenGL/Opengl%20learning_03/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      【笔记】Cherno Opengl Tutorial note 03
      
    </div>
  </a>
  
  
  <a href="/2022/09/04/Diary/2022-09-04/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">2022年9月4日 周日</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>