<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-TA/OpenGL/C++ learning_01" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/OpenGL/C++%20learning_01/" class="article-date">
  <time datetime="2025-09-10T13:18:14.018Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>[TOC]</p>
<h3 id="指针Pointers"><a href="#指针Pointers" class="headerlink" title="指针Pointers"></a>指针Pointers</h3><p>指针是一个整数，储存一个内存地址。</p>
<p>类型没有意义，只是在这个地址的数据是这个类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">void</span>* ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;<span class="comment">// 指针解引用，访问对应地址储存的值</span></span><br><span class="line">=========================</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>]; </span><br><span class="line"><span class="comment">// 一个char占用1个字节，分配了8个字节的内存，并返回一个指向这块内存的开始地址的指针</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span> );<span class="comment">// 为指定地址填充值</span></span><br><span class="line"><span class="keyword">delete</span>[] buffer;<span class="comment">// 删除值</span></span><br><span class="line">buffer = <span class="literal">nullptr</span>;<span class="comment">// 回收指针</span></span><br></pre></td></tr></table></figure>

<p>指针本身也只是变量，这些变量也储存在内存中（double pointers，triple pointers-指针的指针）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>]; </span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span> );</span><br><span class="line"><span class="type">char</span>** ptr = &amp;buffer;<span class="comment">// 在32位程序里，一个内存地址是32位的</span></span><br></pre></td></tr></table></figure>

<h3 id="引用Reference"><a href="#引用Reference" class="headerlink" title="引用Reference"></a>引用Reference</h3><p>指针和引用基本是一回事，引用是对某个存在变量的引用。引用本身不是一个新的变量，并不真正占用内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* b = &amp;a;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;<span class="comment">//这里引用的&amp;符号不同于指针，它是变量类型的一部分，紧跟着变量类型</span></span><br><span class="line"><span class="comment">//在这里创建了一个a的别名，ref其实不是一个实际的变量，只是a所在地址的数据的别称</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; <span class="comment">// 在这里是传值调用（passing by value）</span></span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">increment</span>(a);<span class="comment">//将a拷贝到了函数中，创造一个全新的变量value,a并不会发生改变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>* value)</span> </span>&#123;<span class="comment">//传递地址，调用a的内存地址而不是a本身给函数</span></span><br><span class="line">    (*value)++;<span class="comment">//解引用，改变地址储存的数值而不是地址本身.</span></span><br><span class="line">    <span class="comment">//递增符号会优先执行，所以添括号保证先解引用再递增</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">increment</span>(&amp;a)<span class="comment">//传递变量地址</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;<span class="comment">//引用传递,passing by reference</span></span><br><span class="line">    <span class="comment">//和传递地址是一样的，但是看起来更简单了</span></span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">increment</span>(a)</span><br></pre></td></tr></table></figure>

<p>引用只是让代码更好看了，没有什么事情是引用能做但指针不能的</p>
<p>一旦声明一个引用，就不能更改它所引用的对象</p>
<h3 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h3><p>C++支持面向过程，基于对象，面向对象，泛型编程</p>
<p>类是一种将数据和函数组织在一起的方式</p>
<p>由类类型制成的变量叫对象，新创建对象的过程叫做实例化</p>
<p>默认情况下，类成员的访问控制都是私有的，只有类内部的函数才能访问——提供公有函数访问接口</p>
<p>类内的函数称为方法（method）</p>
<h4 id="与结构体的区别"><a href="#与结构体的区别" class="headerlink" title="与结构体的区别"></a>与结构体的区别</h4><p>默认情况下，类是私有的，结构体是私有的</p>
<p>一般不对结构体使用继承，或过于复杂的功能，仅仅保持结构体为数据和简单的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">// 将公有私有变量、方法分开。</span></span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line">   	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">            m_LogLevel = level;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelError)</span><br><span class="line">            	std::cout &lt;&lt; <span class="string">&quot;[ERROR]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)</span><br><span class="line">            	std::cout &lt;&lt; <span class="string">&quot;[WARNING]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)</span><br><span class="line">            	std::cout &lt;&lt; <span class="string">&quot;[Info]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Log log;</span><br><span class="line">    log.<span class="built_in">SetLevel</span>(log.LogLevelWarning);</span><br><span class="line">    Log.<span class="built_in">Error</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    Log.<span class="built_in">warn</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    Log.<span class="built_in">Info</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    std::cin,<span class="built_in">get</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Static静态关键字"><a href="#Static静态关键字" class="headerlink" title="Static静态关键字"></a>Static静态关键字</h3><p>类外或结构体外的static修饰符在link阶段是局部的，它只对定义它的编译单元（.obj）可见</p>
<p>类内或结构体里面的static表示这部分内存是这个类的所有实例共享的，即就算实例化了很多次这个类或结构体，这个静态static变量只会有一个实例，并被共享。</p>
<p>静态方法也是如此，没有该实例的指针（this）</p>
<h4 id="类外的static。"><a href="#类外的static。" class="headerlink" title="类外的static。"></a>类外的static。</h4><p>static.cpp:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> s_Variable = <span class="number">5</span>; <span class="comment">// 这个变量在link的时候只对这个编译单元(.obj)里的东西可见</span></span><br><span class="line"><span class="comment">// static变量或函数表示在link到它实际的定义时，linker 不会再这个编译单元.obj外面寻找它的定义</span></span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> s_Variable = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; s_Variable &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">//输出10 不会与static.cpp中的static变量发生重复定义</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">=========================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> s_Variable;<span class="comment">//外部链接，会在其他编译单元里寻找定义，但如果static.cpp中是静态声明，就找不到了，静态声明使其他编译单元不能访问s_Variable,相当于私有变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; s_Variable &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类内Static"><a href="#类内Static" class="headerlink" title="类内Static"></a>类内Static</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt;std:endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">    e,x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line">    Entity e1 = &#123; <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>();<span class="comment">//2, 3 /n 5, 8</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">============================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> Entity&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt;std:endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line">    Entity e1<span class="comment">// = &#123; 5, 8 &#125;;//x和y不再是类的成员, 这种写法会报错</span></span><br><span class="line">    e<span class="number">1.</span>x = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//等同于Entity::x = 5,虽然写了e1.x，但其实并不属于类成员</span></span><br><span class="line">    e<span class="number">1.</span>y = <span class="number">8</span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>();<span class="comment">//5, 8 /n 5, 8</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//static 修饰的struct全局会共用一块内存</span></span><br><span class="line">    <span class="comment">//无法通过静态方法访问非静态的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部静态Local-Static"><a href="#局部静态Local-Static" class="headerlink" title="局部静态Local Static"></a>局部静态Local Static</h4><p>变量的</p>
<ul>
<li><p>生命周期：变量被删除前在内存中停留多久</p>
</li>
<li><p>作用域：在哪里能访问这个变量</p>
</li>
</ul>
<p>一个静态局部变量允许我们定义一个变量，生命周期是整个程序，但作用于被限制在这个函数里或任何作用域。和类内作用域的静态变量是一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;<span class="comment">//如果没有静态，则每次调用函数时，i的值被设为0,自增后输出1 </span></span><br><span class="line">    <span class="comment">//局部静态变量和在函数外定义全局变量的区别在于作用域</span></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ENUMS枚举"><a href="#ENUMS枚举" class="headerlink" title="ENUMS枚举"></a>ENUMS枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">  A,B,C  	</span><br><span class="line">      <span class="comment">//第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。</span></span><br><span class="line">      <span class="comment">// 可以指定任意数组，默认顺序</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example value = B</span><br><span class="line">&#125;</span><br><span class="line">============</span><br><span class="line"><span class="keyword">enum</span> Example : <span class="type">unsigned</span> <span class="type">char</span> &#123;<span class="comment">// 可以指定任意类型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Level</span>&#123;</span><br><span class="line">        Error, Warning, Info</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// const int LogLevelError = 0;</span></span><br><span class="line">    <span class="comment">// const int LogLevelWarning = 1;</span></span><br><span class="line">    <span class="comment">// const int LogLevelInfo = 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Constructor构造函数"><a href="#Constructor构造函数" class="headerlink" title="Constructor构造函数"></a>Constructor构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;<span class="comment">//需要一种方式，每当构造Entity实例时，需要将X，Y初始化</span></span><br><span class="line">        X = <span class="number">0.0f</span>;</span><br><span class="line">        Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt; X&lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Init</span>();</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line">=================================================</span><br><span class="line"><span class="keyword">class</span> Entity&#123;<span class="comment">//构造函数就是每当构建一个对象时都会调用的方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    <span class="comment">// Entity() = delete;删除默认的构造函数</span></span><br><span class="line">    <span class="built_in">Entity</span>()&#123;</span><br><span class="line">        X = <span class="number">0.0f</span>;</span><br><span class="line">        Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;<span class="comment">// 可以写许多构造函数（重载）</span></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y)&#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="function">Entity <span class="title">e2</span><span class="params">(<span class="number">10.0f</span>, <span class="number">5.0f</span>)</span></span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">2.</span><span class="built_in">Print</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用static声明类中元素时，并不会调用构造函数（因为static是所有实例共有的）</p>
<p>特殊类型的构造函数：拷贝构造函数Copy Constructor， Move Constructor</p>
<h3 id="Destructors析构函数"><a href="#Destructors析构函数" class="headerlink" title="Destructors析构函数"></a>Destructors析构函数</h3><p>constructor 在创建一个对象实例时运行，而析构函数在摧毁一个对象时运行</p>
<p>构造函数通常用来设置变量或者进行某些需要的初始化</p>
<p>当对象即将结束生命周期时，需要清理原本占用的内存，</p>
<p>析构函数同时使用堆和栈来给对象分配空间，所以如果使用new给对象分配空间，而对应的需要使用delete调用析构函数释放空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;<span class="comment">//构造函数就是每当构建一个对象时都会调用的方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    <span class="built_in">Entity</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        X = <span class="number">0.0f</span>;</span><br><span class="line">        Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y)&#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>()&#123;</span><br><span class="line">       	std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Created Entity!</span></span><br><span class="line"><span class="comment">0, 0</span></span><br><span class="line"><span class="comment">Destroyed Entity!</span></span><br><span class="line"><span class="comment">实例e的生命周期只在Function函数中，因此Function结束后，就调用析构函数释放了空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inheritance继承"><a href="#Inheritance继承" class="headerlink" title="Inheritance继承"></a>Inheritance继承</h3><p>（Code Duplication）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X,Y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xa, <span class="type">float</span> ya)</span> </span>&#123;</span><br><span class="line">        X += xa;</span><br><span class="line">        Y += ya;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity&#123;<span class="comment">// Entity中任何非私有的变量或函数，Player都可用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* Name;</span><br><span class="line">    <span class="comment">/*float X,Y;</span></span><br><span class="line"><span class="comment">    void Move(float xa, float ya) &#123;</span></span><br><span class="line"><span class="comment">        X += xa;</span></span><br><span class="line"><span class="comment">        Y += ya;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt; Name &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player palyer;</span><br><span class="line">    player.<span class="built_in">PrintName</span>();</span><br><span class="line">    palyer.<span class="built_in">Move</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Virtual-Functions虚函数"><a href="#Virtual-Functions虚函数" class="headerlink" title="Virtual Functions虚函数"></a>Virtual Functions虚函数</h3><p>虚函数允许我们覆盖子类中的方法</p>
<p>比如B是A的派生类（子类），如果指定A中某虚函数方法，则可以在B中覆盖该方法做别的事</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)<span class="comment">//这里使用了初始化列表，在构造时先于函数体执行，代表将name赋值给m_Name</span></span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">PrintName</span>(e)<span class="comment">//Entity</span></span><br><span class="line">    </span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;<span class="comment">//Cherno</span></span><br><span class="line">	<span class="built_in">PrintName</span>(p)<span class="comment">//Entity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数引入了动态分派Dynamic Dispatch，通常使用VTable虚函数表实现此编译</p>
<p>虚函数表包含基类中所有虚函数的映射，在运行时映射向正确的覆写函数</p>
<p>总之，如果要覆盖函数，需要在基类中将基函数标记为虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">//std::string Getname() &#123; retrun m_Name; &#125;</span></span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">    <span class="comment">//在C++11中，可以将覆写的函数用关键词override标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">PrintName</span>(e)<span class="comment">//Entity</span></span><br><span class="line">    </span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;<span class="comment">//Cherno</span></span><br><span class="line">	<span class="built_in">PrintName</span>(p)<span class="comment">//Cherno</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数的性能代价，是需要遍历整个虚函数表查看映射</p>
<h4 id="Pure-virtual-function纯虚函数"><a href="#Pure-virtual-function纯虚函数" class="headerlink" title="Pure virtual function纯虚函数"></a>Pure virtual function纯虚函数</h4><p>纯虚函数允许我们定义一个在基类中没有实现的函数，然后迫使在子类中实际实现</p>
<p>在接口中，类仅仅包含未实现的方法并充当一种勉强的模板,这种类无法实例化，必须在子类中实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">//std::string Getname() &#123; retrun m_Name; &#125;</span></span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">    <span class="comment">//在C++11中，可以将覆写的函数用关键词override标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Entity* e = new Entity();</span></span><br><span class="line">    <span class="comment">// PrintName(e)//Entity无法再实例化Entity类</span></span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintName</span>(e);</span><br><span class="line">    </span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;<span class="comment">//Cherno</span></span><br><span class="line">	<span class="built_in">PrintName</span>(p)<span class="comment">//Cherno</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当一个类提供所有纯虚函数的实现，才能实例化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> : <span class="keyword">public</span> Printable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">    std::string GetClassName <span class="keyword">override</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">     std::string GetClassName <span class="keyword">override</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;GetClassNmae &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="comment">// PrintName(e)//Entity</span></span><br><span class="line">    <span class="built_in">Print</span>(e)<span class="comment">//Entity</span></span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p-&gt;GetName() &lt;&lt; std::endl;//Cherno</span></span><br><span class="line">	<span class="comment">// PrintName(p)//Cherno</span></span><br><span class="line">    <span class="built_in">Print</span>(p)<span class="comment">// Player,如果没有在Player中定义，调用的是Entity中的override，输出Entity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Visibility访问控制"><a href="#Visibility访问控制" class="headerlink" title="Visibility访问控制"></a>Visibility访问控制</h3><p>本质指类中的成员数据及函数的可访问性</p>
<p>基本的访问控制修饰符：public公有， protected保护， private私有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">int</span> X,Y;<span class="comment">// 默认私有,意味着只有Entity类内才能访问这些变量，包括读写（除非是friend）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        X = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;<span class="comment">//Player的构造函数也不能访问Entity的私有变量</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> example[<span class="number">5</span>]; <span class="comment">//声明并分配空间</span></span><br><span class="line">example[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; example[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; example &lt;&lt; std::endl;<span class="comment">//输出example的地址，这是一个指针类型</span></span><br><span class="line"><span class="type">int</span>* ptr = example;</span><br><span class="line">*(ptr<span class="number">+2</span>) = <span class="number">6</span>;<span class="comment">//example[2] = 6,example地址后移两个int的空间并解引用，得到example[2]的值赋值为6</span></span><br></pre></td></tr></table></figure>

<p> new 运算符动态分配内存空间，</p>
<p>delete 运算符释放，否则即便局部作用域的程序运行完毕，内存也不会被回收。</p>
<p>为class分配内存空间时，还会同时运行构造函数。</p>
<p>实例的地址所指向的就是成员变量的地址；但如果用new关键字来分配，为成员变量建立了一个指针，实例的地址指向的是指针的地址。</p>
<h3 id="Strings字符串"><a href="#Strings字符串" class="headerlink" title="Strings字符串"></a>Strings字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line"><span class="comment">// 字符串在内存中末尾需要有0 填充作终止符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name2[<span class="number">6</span>] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">std::cout&lt;&lt;name2&lt;&lt;std::endl;<span class="comment">//输出的Cherno后面会跟随后面内存所对应的无意义的ASCII码，如锟斤拷</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name2[<span class="number">7</span>] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>，<span class="number">0</span>&#125;</span><br><span class="line">std::cout&lt;&lt;name2&lt;&lt;std::endl;<span class="comment">// 加上终止符，能正常输出Cherno</span></span><br><span class="line">name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="standard-string"><a href="#standard-string" class="headerlink" title="standard string"></a>standard string</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    <span class="comment">//std string 有一个构造函数，接受一个char ptr或const char ptr</span></span><br><span class="line">    <span class="comment">//这里是（const char[7]）</span></span><br><span class="line">    <span class="comment">//std string 还有一些成员函数可以使用</span></span><br><span class="line">    <span class="comment">//std::string name = &quot;Cherno&quot; + &quot;hello!&quot;;这是不可以的，这相当于把两个数组相加</span></span><br><span class="line">    name += <span class="string">&quot;hello!&quot;</span>;<span class="comment">//这是可以的，将一个指针和name相加，利用string的重载+ 拼接字符串</span></span><br><span class="line">    std::string name2 = std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>) + “hello!<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    //这也是可以的</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="string-literal"><a href="#string-literal" class="headerlink" title="string literal"></a>string literal</h4><p>字符串是不可变的。默认为const，在内存中只读</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正如上面所说，字符串的末尾默认有\0的填充，作为终止符</span></span><br><span class="line"><span class="comment">//&quot;Che\0rno&quot; =&quot;Che\0rno\0&quot;</span></span><br><span class="line"><span class="comment">//实际的字符长度因为中间的终止符，只有3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;Cherno&quot;</span><span class="comment">// 将它定义为数组，而不是字符串或字符串指针，就可以修改了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">u8&quot;Cherno&quot;</span>;<span class="comment">//每个字符一个字节</span></span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* name2 = <span class="string">L&quot;Cherno&quot;</span>;<span class="comment">//宽指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char16_t</span>* name3 = <span class="string">u&quot;Cherno&quot;</span>;<span class="comment">//每个字符两个字节的16位字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char32_t</span>* name4 = <span class="string">U&quot;Cherno&quot;</span>;<span class="comment">//32位字符或每个字符四个字节</span></span><br></pre></td></tr></table></figure>

<p>在C++14中，还可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line">std::string name0 = <span class="string">&quot;Cherno&quot;</span>s + <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::wstring name0 = <span class="string">L&quot;Cherno&quot;</span>s + <span class="string">L&quot;hello&quot;</span>;</span><br><span class="line">std::u32string name0 = <span class="string">U&quot;Cherno&quot;</span>s + <span class="string">U&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//R前缀</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* example = <span class="string">R&quot;(Line1</span></span><br><span class="line"><span class="string">Line2</span></span><br><span class="line"><span class="string">Line3</span></span><br><span class="line"><span class="string">Line4)&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Const常量"><a href="#Const常量" class="headerlink" title="Const常量"></a>Const常量</h3><p>就像一个承诺，认为一个变量不改变，但是否信守承诺还是取决于你自己。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">90</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a =<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">// 意味着不能再更改指针的内容，但是可以读取,也可以更改指针。</span></span><br><span class="line">*a = <span class="number">2</span>；<span class="comment">//不可操作</span></span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE； <span class="comment">//可以操作</span></span><br><span class="line">================================</span><br><span class="line"><span class="comment">//也等同于:    </span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">=================================</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">// 完全相反，不能更改指针，但可以更改指针的内容</span></span><br><span class="line">*a = <span class="number">2</span>;<span class="comment">// 可以操作</span></span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE；<span class="comment">// 不可操作</span></span><br><span class="line">================================</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_X,m_Y;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> var;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">// 此方法不会修改任何类成员变量，是一种只读方法</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_X = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        m_X = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">// 此方法的指针和此方法都不能更改，且不会修改任何成员变量。</span></span><br><span class="line">        retrun m_X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;e.<span class="built_in">GetX</span>()&lt;&lt;std::end;;</span><br><span class="line">    <span class="comment">//因为这里是引用了常量，因此不能对类有任何修改，在调用类方法时，也只能调用只读方法，如果没有类方法没有const，则不能调用，因为无法保证没有更改类成员。</span></span><br><span class="line">    <span class="comment">//有时同名的类方法会有const版本和无const版本，在这里调用时会自动使用const版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutable关键字"><a href="#Mutable关键字" class="headerlink" title="Mutable关键字"></a>Mutable关键字</h4><p>与const共同使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_DebugCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		m_DebugCount++;<span class="comment">//在这里，本来该方法不能修改类成员变量，但mutable是例外，可以修改了,mutable 将其标记为可变的。</span></span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lambda</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">auto</span> f = []() &#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;<span class="comment">//lambada函数</span></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]() &#123;<span class="comment">//传地址</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() &#123;<span class="comment">//传值</span></span><br><span class="line">    x++;<span class="comment">//在这里因为是值传递，相当于用新的变量储存，x不会发生改变</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    x++;<span class="comment">//外部的x变量仍然不会改变</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;<span class="comment">//9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f</span>();<span class="comment">//x = 8</span></span><br></pre></td></tr></table></figure>

<h3 id="Member-Initializer-Lists成员初始化列表"><a href="#Member-Initializer-Lists成员初始化列表" class="headerlink" title="Member Initializer Lists成员初始化列表"></a>Member Initializer Lists成员初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    &#125;<span class="comment">//可以使用初始化列表来完成：</span></span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Score</span>(<span class="number">0</span>)<span class="comment">//需要按照声明顺序定义</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    	：<span class="built_in">m_Name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_Name = name;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entiyt e0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，实际上在不同的构造函数中，如果对</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    Example m_Example;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    	m_Example = <span class="built_in">Example</span>(<span class="number">8</span>)<span class="comment">////调用了构造函数，不带参数，来源于m_Example声明。也调用了参数为8的构造函数。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Example</span>(<span class="built_in">Example</span>(<span class="number">8</span>))，<span class="built_in">m_Example</span>(<span class="number">8</span>)<span class="comment">//只调用一次参数为8的构造函数，节约性能。</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    	：<span class="built_in">m_Name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_Name = name;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ternary-Operators三元操作符"><a href="#Ternary-Operators三元操作符" class="headerlink" title="Ternary Operators三元操作符"></a>Ternary Operators三元操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s_Level&gt;<span class="number">5</span>)&#123;</span><br><span class="line">    s_Speed = <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s_Speed = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">s_Speed = s_Level&gt;<span class="number">5</span> ? <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">std::string rank = s_Level &gt; <span class="number">10</span> ?<span class="string">&quot;Master&quot;</span>: <span class="string">&quot;Beginner&quot;</span>;<span class="comment">//三元操作符能做到更快</span></span><br><span class="line">std::string rank;<span class="comment">//需要先声明，并调用构造函数</span></span><br><span class="line"><span class="keyword">if</span>(s_Level&gt;<span class="number">10</span>)</span><br><span class="line">    rank = <span class="string">&quot;Master&quot;</span>;<span class="comment">//还要进行重载</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    rank = <span class="string">&quot;Beginner&quot;</span>;</span><br><span class="line"></span><br><span class="line">s_Speed = s_Level &gt; <span class="number">5</span> ? s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line">s_Speed = s_Level &gt; <span class="number">5</span> ? (s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> ) : <span class="number">5</span>;</span><br><span class="line">s_Speed = s_Level &gt; <span class="number">5</span> &amp;&amp; s_Level &lt; <span class="number">100</span> ? s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> : <span class="number">5</span>;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/OpenGL/C++%20learning_01/" data-id="cmfe1u6p70011scuhb9a1cyz7" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2025/09/10/TA/OpenGL/Opengl%20learning_01/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      (no title)
      
    </div>
  </a>
  
  
  <a href="/2025/09/10/TA/OpenGL/C++%20learning_02/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title"></div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>