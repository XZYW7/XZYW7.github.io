<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">XZYW7&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="XZYW7&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-TA/百人计划/学习框架" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/" class="article-date">
  <time datetime="2025-09-10T13:18:14.028Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="TA学习体系框架"><a href="#TA学习体系框架" class="headerlink" title="TA学习体系框架"></a>TA学习体系框架</h3><ul>
<li><p>TA的职责</p>
<ul>
<li>为项目解决问题</li>
<li>（设计不就是解决问题吗，把设计思维运用在TA当中，我又感觉自己更适合TA了）</li>
<li>美术的问题，程序关于渲染、流程的问题<ul>
<li>节省项目成本</li>
<li>缩短项目周期</li>
<li>提升项目效果</li>
</ul>
</li>
</ul>
</li>
<li><p>TA的方向</p>
<ul>
<li>程序</li>
<li>美术</li>
<li>工具</li>
<li>渲染</li>
<li>流程</li>
<li>动作</li>
<li>。。。</li>
</ul>
</li>
</ul>
<h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul>
<li>核心是学习如何解决问题</li>
<li>区分解决问题的方法和手段</li>
<li>多精一专</li>
</ul>
<h4 id="学习框架"><a href="#学习框架" class="headerlink" title="学习框架"></a>学习框架</h4><img src="%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719231108190.png" alt="image-20220719231108190" style="zoom:50%;" />

<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719231205177.png" alt="image-20220719231205177"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719231518499.png" alt="image-20220719231518499"></p>
<p>大厂的要求</p>
<p>入门：会使用工具、可以完成指定功能</p>
<p>中级：可以对流程、工具，项目上的东西可以自己修改</p>
<p>高级：可以把做的东西推广到流程当中</p>
<h4 id="入门阶段"><a href="#入门阶段" class="headerlink" title="入门阶段"></a>入门阶段</h4><p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232105088.png" alt="image-20220719232105088"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232214079.png" alt="image-20220719232214079"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232319370.png" alt="image-20220719232319370"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232355422.png" alt="image-20220719232355422"></p>
<h4 id="进阶阶段"><a href="#进阶阶段" class="headerlink" title="进阶阶段"></a>进阶阶段</h4><p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232721031.png" alt="image-20220719232721031"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232836013.png" alt="image-20220719232836013"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232937688.png" alt="image-20220719232937688"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233011772.png" alt="image-20220719233011772"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233059747.png" alt="image-20220719233059747"></p>
<h4 id="高级阶段"><a href="#高级阶段" class="headerlink" title="高级阶段"></a>高级阶段</h4><p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233201038.png" alt="image-20220719233201038"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233208430.png" alt="image-20220719233208430"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233313853.png" alt="image-20220719233313853"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/" data-id="cmfe1u6pj002nscuhc88xb3lp" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.7.2 command buffer及urp概述" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2025-09-10T13:18:14.028Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形3-7-2-command-buffer及urp概述"><a href="#图形3-7-2-command-buffer及urp概述" class="headerlink" title="图形3.7.2 command buffer及urp概述"></a>图形3.7.2 command buffer及urp概述</h1><h2 id="一、Command-Buffer"><a href="#一、Command-Buffer" class="headerlink" title="一、Command Buffer"></a>一、Command Buffer</h2><p>Command Buffer：用来存储渲染命令的缓冲区</p>
<ul>
<li>保存渲染命令列表<ul>
<li>如set render target, draw mesh等等，可以设置在摄像机渲染期间的不同时间点执行</li>
</ul>
</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212010010.png" alt="image-20221004212010010"></p>
<ul>
<li>如图使用Command Buffer获取渲染这三个物体之前的背景，输出到RT，渲染物体时采样RT进行处理，获得各种效果</li>
<li>也可以在选择物体时使用多pass进行外扩描边(ExcuteInEditorMode的HeaderAttribute)</li>
</ul>
<h4 id="从Opengl指令分析Command-Buffer原理"><a href="#从Opengl指令分析Command-Buffer原理" class="headerlink" title="从Opengl指令分析Command Buffer原理"></a>从Opengl指令分析Command Buffer原理</h4><p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212333393.png" alt="image-20221004212333393"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212443470.png" alt="image-20221004212443470"></p>
<p>Unity里FrameDebugger打开的一大堆指令，也是Command Buffer</p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212836046.png" alt="image-20221004212836046"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212938333.png" alt="image-20221004212938333"></p>
<h4 id="从自定义RenderPipeline分析（ScriptableRenderContext与Command-Buffer）"><a href="#从自定义RenderPipeline分析（ScriptableRenderContext与Command-Buffer）" class="headerlink" title="从自定义RenderPipeline分析（ScriptableRenderContext与Command Buffer）"></a>从自定义RenderPipeline分析（ScriptableRenderContext与Command Buffer）</h4><p>这一段也许可以自己去看看catlike coding的SRP部分</p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004215426213.png" alt="image-20221004215426213"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004215744770.png" alt="image-20221004215744770"></p>
<h2 id="二、Command-Buffer常用函数"><a href="#二、Command-Buffer常用函数" class="headerlink" title="二、Command Buffer常用函数"></a>二、Command Buffer常用函数</h2><p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004215945624.png" alt="image-20221004215945624"></p>
<ul>
<li>RenderTarget</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220319374.png" alt="image-20221004220319374"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220610753.png" alt="image-20221004220610753"></p>
<ul>
<li>RenderTexture<ul>
<li>申请临时的RT必须手动Release</li>
<li>Release与Destroy的区别<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41251356">https://zhuanlan.zhihu.com/p/41251356</a></li>
<li>Release释放显存不释放内存</li>
<li>Destroy会把Object销毁的同时连带显存释放掉，因此频繁使用Destroy会加重申请内存的负担</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220340735.png" alt="image-20221004220340735"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220434194.png" alt="image-20221004220434194"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220529916.png" alt="image-20221004220529916"></p>
<ul>
<li>DrawMesh</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004223532948.png" alt="image-20221004223532948"></p>
<h2 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h2><ul>
<li>URP</li>
<li>RenderFeature与Command Buffer原理分析</li>
<li>Volume组件</li>
</ul>
<h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><ul>
<li>Scene窗口CameraColorTexture丢失[MSAA导致的bug ResolveAA]</li>
<li>深度缓冲和模板缓冲[16bit和24&#x2F;32bit]</li>
<li>RT精度格式问题</li>
<li>加速优化</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004225932580.png" alt="image-20221004225932580"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="完成洛基中的传送门效果"><a href="#完成洛基中的传送门效果" class="headerlink" title="完成洛基中的传送门效果"></a>完成洛基中的传送门效果</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13F411e7Ai">https://www.bilibili.com/video/BV13F411e7Ai</a></p>
<p>【技术美术百人计划】图形 3.72 command buffer及urp概述</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/" data-id="cmfe1u6pk002rscuheh5x68wl" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.4 延迟渲染管线介绍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.4%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2025-09-10T13:18:14.027Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-3-4-延迟渲染管线介绍"><a href="#图形-3-4-延迟渲染管线介绍" class="headerlink" title="图形 3.4  延迟渲染管线介绍"></a>图形 3.4  延迟渲染管线介绍</h1><h3 id="1-渲染路径"><a href="#1-渲染路径" class="headerlink" title="1.渲染路径"></a><strong>1.渲染路径</strong></h3><p>渲染路径（Rendering Path）：决定光照的实现方式。就是当前渲染目标使用光照的流程</p>
<h3 id="2-渲染方式"><a href="#2-渲染方式" class="headerlink" title="2.渲染方式"></a><strong>2.渲染方式</strong></h3><h4 id="2-1-前向渲染Forward-Rendering"><a href="#2-1-前向渲染Forward-Rendering" class="headerlink" title="2.1 前向渲染Forward Rendering"></a><strong>2.1 前向渲染Forward Rendering</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820011602900.png" alt="image-20220820011602900"></p>
<p>在渲染每一帧时，每个顶点、片元都要执行一次着色器代码。这时需要将所有的光照信息都传递到片元着色器中。虽然大部分情况下的光源都趋向于小型化，而其照亮的区域也不大，但即便是光源离这个像素所对应的世界空间中的位置很远，计算光照时还是会把所有光源考虑进去。复杂度是$O(mn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For each light:</span><br><span class="line">	For each object affected by the light:</span><br><span class="line">		framebuffer += object * light</span><br></pre></td></tr></table></figure>



<h4 id="2-2-延迟渲染Deferred-Rendering"><a href="#2-2-延迟渲染Deferred-Rendering" class="headerlink" title="2.2 延迟渲染Deferred Rendering"></a><strong>2.2 延迟渲染Deferred Rendering</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820012923949.png" alt="image-20220820012923949"></p>
<p>主要解决大量光照渲染的方案。先不要迭代三角形做光照计算，而是先找出能看到的所有像素，再去迭代光照。直接迭代三角形的话，由于大量三角形不可见，是浪费的。</p>
<p>如前向渲染下，近处光源和远处光源计算量相等。但延迟渲染下，近处的计算量会大于远处。因为远处的像素更少。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820012418691.png" alt="image-20220820012418691"></p>
<p>Gbuffer</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/v2-ad11e89e29c6ef9dc8e7c01a9203efa7_720w.jpg" alt="img"></p>
<p>流程：</p>
<p>分成两个pass</p>
<ul>
<li>几何处理pass<ul>
<li>首先将场景渲染一次，获取待渲染对象的各种几何信息，储存到G-buffer。并且开启深度测试，所以G-buffer只写入最近的片元的信息。</li>
</ul>
</li>
<li>光照处理pass<ul>
<li>遍历所有G-buffer的各种参数，执行光照计算。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For each object:</span><br><span class="line">	Render to multiple targets</span><br><span class="line">For each light:</span><br><span class="line">	Apply light as a <span class="number">2</span>D postprocess</span><br></pre></td></tr></table></figure>

<p>复杂度是$O(m+n)$ 。</p>
<h5 id="问题：如何渲染透明物体"><a href="#问题：如何渲染透明物体" class="headerlink" title="问题：如何渲染透明物体"></a><strong>问题：如何渲染透明物体</strong></h5><p>透明物体在前向渲染中，一般最后渲染，并且不写入深度。</p>
<p>所以在延迟渲染中，还是需要用前向渲染的方式，最后渲染透明物体</p>
<h4 id="2-3-不同渲染路径的优劣及特性"><a href="#2-3-不同渲染路径的优劣及特性" class="headerlink" title="2.3 不同渲染路径的优劣及特性"></a><strong>2.3 不同渲染路径的优劣及特性</strong></h4><h5 id="2-3-1-区别"><a href="#2-3-1-区别" class="headerlink" title="2.3.1 区别"></a><strong>2.3.1 区别</strong></h5><ul>
<li><p>后处理方式不同</p>
<ul>
<li>假设需要深度信息来进行后处理，前向渲染就需要单独渲染深度图</li>
</ul>
</li>
<li><p>着色计算不同</p>
<ul>
<li>延迟渲染只能计算一个光照模型，因为是统一在LightPass计算的</li>
</ul>
</li>
<li><p>抗锯齿方式不同</p>
</li>
</ul>
<h5 id="2-3-2-优劣"><a href="#2-3-2-优劣" class="headerlink" title="2.3.2 优劣"></a><strong>2.3.2 优劣</strong></h5><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>前向渲染</td>
<td>1. 支持半透明渲染</td>
<td>1. 光源数量对计算复杂度影响巨大</td>
</tr>
<tr>
<td></td>
<td>2. 支持使用多个光照pass</td>
<td>2. 访问深度等数据需要额外计算</td>
</tr>
<tr>
<td></td>
<td>3. 支持自定义光照计算方式</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>延迟渲染</td>
<td>1. 大量光照场景优势明显</td>
<td>1. 对MSAA支持不友好</td>
</tr>
<tr>
<td></td>
<td>2. 只渲染可见像素，节省计算量</td>
<td>2. 透明物体渲染存在问题</td>
</tr>
<tr>
<td></td>
<td>3. 对后处理支持良好</td>
<td>3. 占用大量的显存带宽</td>
</tr>
<tr>
<td></td>
<td>4. 用更少的shader</td>
<td></td>
</tr>
</tbody></table>
<h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a><strong>3.其他</strong></h4><h5 id="3-1-渲染路径的设置方式"><a href="#3-1-渲染路径的设置方式" class="headerlink" title="3.1 渲染路径的设置方式"></a><strong>3.1 渲染路径的设置方式</strong></h5><p>(2021.2版本以前，URP不支持延迟渲染)</p>
<ol>
<li>项目设置Tier Settings 的Rendering Path改为延迟渲染，并勾选Use Defaults</li>
<li>相机的Rendering Path使用延迟渲染</li>
</ol>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820014419975.png" alt="image-20220820014419975"></p>
<h5 id="3-2-移动端优化"><a href="#3-2-移动端优化" class="headerlink" title="3.2 移动端优化"></a><strong>3.2 移动端优化</strong></h5><ul>
<li>两个TBDR<ul>
<li>一个是SIGGRAPH2010提出，通过分块来降低带宽内存用量</li>
<li>一个是PowerVR基于手机GPU的TBR架构提出的，通过HSR减少overdraw</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820014624273.png" alt="image-20220820014624273"></p>
<h5 id="3-3-其他渲染路径"><a href="#3-3-其他渲染路径" class="headerlink" title="3.3 其他渲染路径"></a><strong>3.3 其他渲染路径</strong></h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54694743">https://zhuanlan.zhihu.com/p/54694743</a></p>
<ul>
<li>延迟光照 Light Pre-Pass&#x2F;Deferred Lighting<ul>
<li>减少G-buffer占用的过多开销，支持多种光照模型</li>
</ul>
</li>
<li>Forward+ 即Tiled Forward Rendering，分块正向渲染<ul>
<li>减少带宽，支持多光源，强制需要一个preZ</li>
</ul>
</li>
<li>群组渲染Clustered Rendering<ul>
<li>带宽相对减少，多光源下效率提升</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li>总结延迟渲染管线的优缺点<ul>
<li>文内</li>
</ul>
</li>
<li>如何优化（移动端优化技术）<ul>
<li>3.7见</li>
</ul>
</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1244y1i7oV">https://www.bilibili.com/video/BV1244y1i7oV</a></p>
<p>【技术美术百人计划】图形 3.4  延迟渲染管线介绍</p>
<p>[2] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/08%20Deferred%20Shading/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/08%20Deferred%20Shading/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.4%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/" data-id="cmfe1u6pi002dscuh906ua5hc" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.5 Early-z和Z-prepass" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.5%20Early-z%E5%92%8CZ-prepass/" class="article-date">
  <time datetime="2025-09-10T13:18:14.027Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-3-5-Early-z和Z-prepass-preZ"><a href="#图形-3-5-Early-z和Z-prepass-preZ" class="headerlink" title="图形 3.5 Early-z和Z-prepass(preZ)"></a>图形 3.5 Early-z和Z-prepass(preZ)</h1><h3 id="一、深度测试"><a href="#一、深度测试" class="headerlink" title="一、深度测试"></a><strong>一、深度测试</strong></h3><ul>
<li><p>fs-Alpha Test-Stencil Test-&#x3D;&#x3D;Depth Test&#x3D;&#x3D;</p>
</li>
<li><p>解决物体可见遮挡性的问题</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822155007188.png" alt="image-20220822155007188" style="zoom:50%;" />

<p>因为测试阶段发生在fs之后，片元即便被丢弃，已经经过了fs中大量的无用的计算。</p>
<h3 id="二、提前深度测试Early-Z"><a href="#二、提前深度测试Early-Z" class="headerlink" title="二、提前深度测试Early-Z"></a><strong>二、提前深度测试Early-Z</strong></h3><ul>
<li>解决过多不必要的片元计算问题</li>
<li>光栅化-&#x3D;&#x3D;EarlyZ&#x3D;&#x3D;-fs-Alpha Test-Stencil Test-&#x3D;&#x3D;Depth Test&#x3D;&#x3D;</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822155402937.png" alt="image-20220822155402937" style="zoom: 67%;" />

<ul>
<li>EarlyZ也可以基于模板测试在着色前丢弃片元</li>
<li><strong>EarlyZ剔除的最小单位不是1像素，而是像素块（2x2）</strong></li>
</ul>
<h4 id="2-1-EarlyZ失效"><a href="#2-1-EarlyZ失效" class="headerlink" title="2.1 EarlyZ失效"></a><strong>2.1 EarlyZ失效</strong></h4><p>通常在EarlyZ阶段不仅会进行深度测试，还会写入深度</p>
<ol>
<li>开启ALpha Test或Clip&#x2F;discard等手动丢弃片元操作<ul>
<li>如果手动丢弃片元，导致如果前面的片元丢弃了，深度仍然存在，后续的像素也会被丢弃。</li>
</ul>
</li>
<li>手动修改GPU插值得到的深度</li>
<li>开启Alpha Blend<ul>
<li>开启Alpha Blend的物体一般不会开启深度写入ZWrite off</li>
</ul>
</li>
<li>关闭深度测试Depth Test</li>
<li>开启Multi-Sampling：多重采样会影响周边像素，而EarlyZ无法得知周边像素是否被裁剪，无法提前剔除</li>
<li>以及其他任何导致需要混合后面颜色的操作</li>
</ol>
<p>此外，Early-Z技术会导致**深度数据冲突（depth data hazard）**的问题</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1617944-20190906001537033-642734220.png" alt="img" style="zoom:50%;" />

<p>避免深度数据冲突的方法之一是在写入深度值之前，再次与frame buffer的值进行对比：</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1617944-20190906001545523-562795391.png.png" alt="1617944-20190906001545523-562795391.png" style="zoom: 67%;" />

<h4 id="2-2-高效利用EarlyZ"><a href="#2-2-高效利用EarlyZ" class="headerlink" title="2.2 高效利用EarlyZ"></a><strong>2.2 高效利用EarlyZ</strong></h4><p>将不透明物体由近向远渲染，EarlyZ的优化效果最好</p>
<ul>
<li>CPU进行深度排序</li>
<li>场景复杂时，排序消耗增大。</li>
<li>严格按照从近到远渲染，不能同时搭配合批优化手段</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822155921813.png" alt="image-20220822155921813" style="zoom: 67%;" />



<h3 id="三、使用Z-Prepass"><a href="#三、使用Z-Prepass" class="headerlink" title="三、使用Z-Prepass"></a><strong>三、使用Z-Prepass</strong></h3><ol>
<li>在第一个pass即Z-Prepass中只写入深度，不计算输出任何颜色<ul>
<li>自动计算了最小深度的zbuffer，无需cpu排序</li>
<li>EarlyZ阶段也可以提升一点效率，虽然本来就没什么计算</li>
</ul>
</li>
<li>第二个pass关闭深度写入，并且将深度比较函数设置为相等</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Tags&#123;<span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span>&#125;</span><br><span class="line">    <span class="comment">//PreZ</span></span><br><span class="line">    Pass &#123;</span><br><span class="line">        ZWrite On 	<span class="comment">// 开启深度写入</span></span><br><span class="line">        ColorMask <span class="number">0</span> <span class="comment">// 关闭颜色输出</span></span><br><span class="line">        CGROGRAM</span><br><span class="line">        ...<span class="comment">//省略顶点变换部分</span></span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常地计算输出颜色</span></span><br><span class="line">    Pass &#123;</span><br><span class="line">        ZWrite Off	<span class="comment">// 关闭深度写入</span></span><br><span class="line">        ZTest Equal <span class="comment">// 深度相等通过</span></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        ...</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、Z-Prepass带来的问题"><a href="#四、Z-Prepass带来的问题" class="headerlink" title="四、Z-Prepass带来的问题"></a><strong>四、Z-Prepass带来的问题</strong></h3><h4 id="4-1-动态批处理问题"><a href="#4-1-动态批处理问题" class="headerlink" title="4.1 动态批处理问题"></a><strong>4.1 动态批处理问题</strong></h4><p>多pass的shader无法进行动态批处理-增加drawcall</p>
<h5 id="解决方法：提前分离的PrePass"><a href="#解决方法：提前分离的PrePass" class="headerlink" title="解决方法：提前分离的PrePass"></a>解决方法：提前分离的PrePass</h5><p>仍然使用两个pass</p>
<ol>
<li>将原先第一个pass（Z-Prepass）单独分离出来为单独一个shader，并使用这个shader将整个场景的Opaque物体渲染一遍（写入深度）</li>
<li>原先材质只剩下原先的第二个Pass，仍关闭深度写入，并且深度比较函数设置为相等</li>
</ol>
<p>两个pass都能够分别被批处理</p>
<h4 id="4-2-Z-Prepass解决透明渲染"><a href="#4-2-Z-Prepass解决透明渲染" class="headerlink" title="4.2 Z-Prepass解决透明渲染"></a><strong>4.2 Z-Prepass解决透明渲染</strong></h4><p>不写入深度的透明渲染会出现深度穿插错误的问题</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161301143(1).png" alt="image-20220822161301143(1)"></p>
<p>（无法看到透明物体的背面）</p>
<ul>
<li>如果要用Z-Prepass同时渲染物体背面<ul>
<li>需要先渲染背面，剔除正面</li>
<li>在下一个pass渲染正面，剔除背面</li>
<li>可用于头发渲染</li>
</ul>
</li>
</ul>
<h4 id="4-3-其他问题"><a href="#4-3-其他问题" class="headerlink" title="4.3 其他问题"></a><strong>4.3 其他问题</strong></h4><h5 id="计算消耗"><a href="#计算消耗" class="headerlink" title="计算消耗"></a>计算消耗</h5><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161643680.png" alt="image-20220822161643680"></p>
<p>权衡片元计算复杂性&#x2F;overdraw与Z-Prepass的消耗，根据实际情况采用</p>
<h3 id="五、Early-Z与Z-Prepass的实例应用"><a href="#五、Early-Z与Z-Prepass的实例应用" class="headerlink" title="五、Early-Z与Z-Prepass的实例应用"></a><strong>五、Early-Z与Z-Prepass的实例应用</strong></h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jaffhan/p/7382106.html">https://www.cnblogs.com/jaffhan/p/7382106.html</a></p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161834083.png" alt="image-20220822161834083" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161855886.png" alt="image-20220822161855886" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822162042913.png" style="zoom:67%;" />

<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><ol>
<li><strong>做下preZ的效果测试</strong></li>
</ol>
<p>左边的狮子是preZ，右边的狮子是普通的Alpha。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823202352241.png" alt="image-20220823202352241" style="zoom:80%;" />

<p>因为是透明渲染，所以自然而然会想到preZ的方法能否应用到之前深度测试的透视效果。</p>
<p>因为preZ记录了最前面的一个深度。透视，也就是说透明物体前面被遮挡住了，并且已经绘制了这个遮挡物体，那么就是遮挡物体的深度写入了深度缓冲。我们也就没有了被遮挡物体最近面的深度了。而之后要绘制出来，也要用Greater的判定方式，最终透明物体无法表现出自遮挡。</p>
<p>并且如果没有遮挡物的时候，物体自身最近片元就写入了深度。那么物体自己对自己形成遮挡，最后会发生没有遮挡时，绘制出了物体自身重叠部分。这种没有对透视效果做特殊处理，所以最后一次绘制物体自身的时候会覆盖（这是深度缓冲依然是物体自身最近距离，测试规则为LEqual）但是如果透视部分有特殊效果，那么正常的物体渲染可能会漏出这一部分。</p>
<p>总之结论就是，这个效果同一物体多pass的实现方法，无法用preZ来完成。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823203258886(1).png" alt="image-20220823203258886(1)"></p>
<ol start="2">
<li><strong>总结earlyZ的限制</strong></li>
</ol>
<ul>
<li><p>EarlyZ-失效</p>
<ul>
<li>开启ALpha Test或Clip&#x2F;discard等手动丢弃片元操作<ul>
<li>如果手动丢弃片元，导致如果前面的片元丢弃了，深度仍然存在，后续的像素也会被丢弃。</li>
</ul>
</li>
<li>手动修改GPU插值得到的深度</li>
<li>开启Alpha Blend<ul>
<li>开启Alpha Blend的物体一般不会开启深度写入ZWrite off</li>
</ul>
</li>
<li>关闭深度测试Depth Test</li>
<li>开启Multi-Sampling：多重采样会影响周边像素，而EarlyZ无法得知周边像素是否被裁剪，无法提前剔除</li>
<li>以及其他任何导致需要混合后面颜色的操作</li>
</ul>
</li>
<li><p>导致深度数据冲突</p>
</li>
<li><p>为了最大利用EarlyZ按照从近到远顺序渲染，但CPU阶段排序耗时，且严格按照从近到远渲染不能同时搭配合批优化手段</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FK4y1u7iw">https://www.bilibili.com/video/BV1FK4y1u7iw</a></p>
<p>【技术美术百人计划】图形 3.5 Early-z和Z-prepass</p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aM4y1g75f">https://www.bilibili.com/video/BV1aM4y1g75f</a></p>
<p>【技术美术百人计划】图形 2.7.2 GPU硬件架构概述</p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/timlly/p/11471507.html">https://www.cnblogs.com/timlly/p/11471507.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.5%20Early-z%E5%92%8CZ-prepass/" data-id="cmfe1u6pi002hscuh278yg2nn" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.6 纹理压缩" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.6%20%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9/" class="article-date">
  <time datetime="2025-09-10T13:18:14.027Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形3-6-纹理压缩"><a href="#图形3-6-纹理压缩" class="headerlink" title="图形3.6 纹理压缩"></a>图形3.6 纹理压缩</h1><h3 id="1-什么是纹理压缩"><a href="#1-什么是纹理压缩" class="headerlink" title="1. 什么是纹理压缩"></a><strong>1. 什么是纹理压缩</strong></h3><p>纹理压缩：是为了解决<strong>内存、带宽</strong>问题，专为在计算机图形渲染系统中存储纹理而使用的图像压缩技术。</p>
<h4 id="1-1-图片与纹理"><a href="#1-1-图片与纹理" class="headerlink" title="1.1 图片与纹理"></a><strong>1.1 图片与纹理</strong></h4><ul>
<li>图片格式<ul>
<li>图片格式是图片文件的存储格式，通常在磁盘、内存中储存和传输文件时使用。</li>
<li>例如：jpg、png、gif、bmp等</li>
</ul>
</li>
<li>纹理格式<ul>
<li>纹理格式是显卡能够直接进行采样的纹理数据格式，通常在向显卡中加载纹理时使用。</li>
</ul>
</li>
<li>纹理管线<ul>
<li>纹理压缩格式基于块压缩，能够更快读取像素所需字节块进行解压所以支持随机访问。</li>
<li>图片压缩格式基于整张图片进行压缩，无法直接实现单个像素的解析。</li>
<li>图片压缩格式无法被GPU识别，还需要经CPU解压缩成非压缩纹理格式才能被识别。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824164504787.png" alt="image-20220824164504787"></p>
<h3 id="2-常见纹理压缩格式"><a href="#2-常见纹理压缩格式" class="headerlink" title="2. 常见纹理压缩格式"></a><strong>2. 常见纹理压缩格式</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824164711622.png" alt="image-20220824164711622"></p>
<h4 id="2-1-非压缩格式"><a href="#2-1-非压缩格式" class="headerlink" title="2.1 非压缩格式"></a><strong>2.1 非压缩格式</strong></h4><table>
<thead>
<tr>
<th align="center">非压缩格式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">RGBA8888(RGBA32)</td>
<td>一个像素32位，包含A通道（一个像素消耗4字节）</td>
</tr>
<tr>
<td align="center">RGBA4444(RGBA16)</td>
<td>一个像素16位，包含A通道（一个像素消耗2字节）</td>
</tr>
<tr>
<td align="center">RGB888(RGB24)</td>
<td>一个像素24位，无A通道（一个像素消耗3字节）</td>
</tr>
<tr>
<td align="center">RGB565(RGB16)</td>
<td>一个像素16位，无A通道（一个像素消耗2字节）</td>
</tr>
</tbody></table>
<h4 id="2-2-压缩格式"><a href="#2-2-压缩格式" class="headerlink" title="2.2 压缩格式"></a><strong>2.2 压缩格式</strong></h4><h5 id="DXTC"><a href="#DXTC" class="headerlink" title="DXTC"></a><strong>DXTC</strong></h5><p>DXTC纹理压缩格式来源于S3公司提出的S3TC算法，基本思想是把4x4的像素块压缩成一个64或128位的数据块，优点是创建了一个固定大小且独立的编码片段，没有共享查找表或其他依赖关系，简化了解码过程。</p>
<ul>
<li><p>DXT1(BC1)</p>
<ul>
<li>每个块有2个16位RGB颜色值（RGB565），代表了此4x4像素块中颜色极端值，然后通过线性插值计算出两个中间颜色值，16个2位索引值则表示了每一个像素的颜色值索引；</li>
<li>(索引2个极端颜色+2个计算中间颜色)</li>
<li>适用于不具有透明度信息的贴图（或一位（0、1）透明信息-完全不透明或完全透明）<ul>
<li>有透明信息时，只计算一个中间颜色值，剩下的一个索引表示透明信息</li>
</ul>
</li>
<li>参照RGB24的压缩率-64&#x2F;(24*16) &#x3D;1&#x2F;6 </li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824165255015.png" alt="image-20220824165255015"></li>
</ul>
</li>
<li><p>DXT2&#x2F;3(BC2)</p>
<ul>
<li>DXT2&#x2F;3与DXT1类似，表示颜色信息的64位数据块不变，另外附加了64位数据来表示每个像素的Alpha信息，整个数据块变为128位</li>
<li>每个像素占用8位，0-3表示透明信息，4-7表示颜色信息</li>
<li>压缩率（RGBA32）：128&#x2F;(32*16) &#x3D; 1&#x2F;4</li>
</ul>
</li>
<li><p>DXT4&#x2F;5(BC3)</p>
<ul>
<li>DXT4&#x2F;5与DXT2&#x2F;3的差异在于其Alpha信息使用了线性插值，表示颜色信息的64位数据块依然不变，Alpha信息则由2个8位Alpha极端值和16个3位索引值组成。</li>
<li>压缩率（RGBA32）：128&#x2F;(32*16) &#x3D; 1&#x2F;4</li>
</ul>
</li>
<li><p>在Unity内贴图类型选为法线后会采用DXTnm压缩格式（居于DXT5），该格式会把法线贴图R通道存入A通道，然后RB通道清除为1，这样可以将法线XY信息分别存入到RGB&#x2F;A中分别进行压缩，以获得更高的精度，然后再根据XY构建出Z通道数据。</p>
</li>
</ul>
<h5 id="ATI1-2"><a href="#ATI1-2" class="headerlink" title="ATI1&#x2F;2"></a><strong>ATI1&#x2F;2</strong></h5><ul>
<li><p>ATI1</p>
<ul>
<li>为ATI公司开发的纹理压缩格式，也被称为BC4，其每个数据块存储单个颜色的数据通道，以与DXT5中的Alpha数据相同的方式进行编码，常用于存储高度图，光滑度贴图，效果与原始图像基本无差异；</li>
<li>压缩率（R8）：64&#x2F;(8*16)&#x3D;1&#x2F;2</li>
</ul>
</li>
<li><p>ATI2</p>
<ul>
<li>也被称为BC5，每个块中存储两个颜色通道的数据，同上以与DX5中Alpha数据相同的方式进行编码，相当于存储了两个BC4块。</li>
<li>压缩率（RG16）：128&#x2F;(8*16)&#x3D;1&#x2F;2</li>
</ul>
</li>
<li><p>如果是在将法线存储在XY双通道中采用BC5格式压缩，由于每个通道都有自己的索引，因此法线贴图XY信息可以比在BC1中保留更多的保真度，缺点是需要使用两倍内存，也需要更多带宽才能将纹理传递到着色器中；</p>
</li>
</ul>
<h5 id="BC6-7"><a href="#BC6-7" class="headerlink" title="BC6&#x2F;7"></a><strong>BC6&#x2F;7</strong></h5><p>仅在D3D11级图形硬件中受支持，他们每个块占用16字节，BC7针对8为RGB或RGBA数据，BC6针对RGB半精度浮点数据，因此BC6是唯一一个可以原生存储HDR的BC格式</p>
<ul>
<li>BC6是专门针对HDR图像设计的压缩算法，压缩比为1&#x2F;6</li>
<li>BC7是专门针对LDR图像设计的压缩算法，压缩比为1&#x2F;3<ul>
<li>该格式用于高质量的RGBA压缩，可以显著减少由于压缩法线带来的错误效果</li>
</ul>
</li>
</ul>
<h5 id="ETC"><a href="#ETC" class="headerlink" title="ETC"></a><strong>ETC</strong></h5><p>DirectX选择了DXTC作为标准压缩格式，对于Opengl则选择了爱立信研发的ETC格式，几乎所有安卓设备都可以支持ETC压缩，所以其在移动平台上被广泛使用。</p>
<p>ETC与DXTC具有相同的特点，将4x4的像素单元压缩成64位数据块，并将像素单元水平或竖直朝向分为两个区块，每个像素颜色等于基础颜色加上索引指向的亮度范围。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824183152849.png" alt="image-20220824183152849"></p>
<ul>
<li><p>ETC1</p>
<ul>
<li>每个数据块分区中的4位亮度索引信息会从16个内置亮度表中获取当前像素单元对应的亮度表，每个像素的2位像素索引值可以从亮度表的四个值中选取对应的亮度补充值</li>
<li>压缩率（RGB24）：64&#x2F;(16*24)&#x3D;1&#x2F;6</li>
</ul>
</li>
<li><p>ETC2</p>
<ul>
<li>ETC1的扩展，支持了Alpha通道的压缩，硬件要求Opengl ES3.0和Opengl4.3以上</li>
</ul>
</li>
<li><p>差别</p>
<ul>
<li>ETC1要求长宽为2的幂次的贴图，适用于所有安卓设备，压缩率比较高，但不适合带Alpha通道的贴图</li>
<li>ETC2要求长宽能被4整除的贴图，设备有硬件要求，支持Alpha通道压缩，内存占用大于ETC1</li>
</ul>
</li>
</ul>
<h5 id="ASTC"><a href="#ASTC" class="headerlink" title="ASTC"></a><strong>ASTC</strong></h5><p>ASTC是ARM和AMD联合开发的纹理压缩格式，各项指标都不错，</p>
<ul>
<li>优点<ul>
<li>可根据不同图片选择不同压缩率的算法</li>
<li>图片不需要为2的幂次</li>
<li>同时支持LDR和HDR</li>
</ul>
</li>
<li>缺点<ul>
<li>兼容性不够完善</li>
<li>解码时间较长</li>
</ul>
</li>
</ul>
<p>ASTC也是基于块的压缩算法，与BC7类似，数据块大小固定为128位，不同的是块中像素数量可变，从4x4到12x12像素都有。</p>
<p>每个数据块中存储了两个插值端点，但不一定存储的是颜色信息，也可能是Layer信息，这样可以用来对Normal或Alpha进行更好的压缩</p>
<p>对于块中每个像素，存储对应插值端点的权重，存储的权重数量可以少于纹素数量，可通过插值得到每一个纹素的权重值，然后再进行颜色的计算。</p>
<ul>
<li>数据块构成<ul>
<li>11位：权重、高度信息、特殊块标识</li>
<li>2位：Part数量</li>
<li>4位：16种插值端点模式（如LDR&#x2F;HDR，RGB&#x2F;RGBA）</li>
<li>111位：插值端点信息，纹素权重值，配置信息</li>
</ul>
</li>
</ul>
<h5 id="PVRTC"><a href="#PVRTC" class="headerlink" title="PVRTC"></a><strong>PVRTC</strong></h5><p>由Imagination公司专为PowerVR显卡设计，仅支持Iphone，Ipad和部分安卓机。</p>
<p>不同于DXTC和ETC这类基于块的算法，PVRTC将图像分为了低频和高频信号，低频信号由两张低分辨率图像AB组成，高频信号则是低精度的调制图像，记录了每个像素混合的权重，解码时AB图像经过双线性插值放大，然后根据调制图像的权重进行混合</p>
<ul>
<li>PVRTC<ul>
<li>PVRTC 2-bpp(bit per pixel)</li>
<li>PVRTC 4-bpp把一个4x4的像素单元压缩成一个64位数据块，每一个块中存储一个32位（每个像素2位）的调制数据，一个1位的调制标识，15位(RGB555&#x2F;RGBA4443)的颜色A，1位颜色A不透明标识（决定按照RGB还是RGBA进行存储），14位(RGB554&#x2F;RGBA4433)颜色B，1位颜色B不透明标识</li>
<li>压缩率（RGB）：64&#x2F;(24*16) &#x3D; 1&#x2F;6</li>
<li>压缩率（RGBA）：64&#x2F;(32*16) &#x3D; 1&#x2F;8</li>
</ul>
</li>
</ul>
<h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a><strong>2.3 总结</strong></h4><ul>
<li>画质比较<ul>
<li>RGBA&gt;ASTC 4x4&gt;ASTC6x6&gt;ETC2 ≈ETC1</li>
</ul>
</li>
<li>压缩比</li>
</ul>
<table>
<thead>
<tr>
<th align="center">压缩格式</th>
<th align="center">压缩率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DXT1</td>
<td align="center">1&#x2F;6</td>
</tr>
<tr>
<td align="center">DXT2&#x2F;3</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">DXT4&#x2F;5</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">ATI1</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">ATI2</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">BC6</td>
<td align="center">1&#x2F;6</td>
</tr>
<tr>
<td align="center">BC7</td>
<td align="center">1&#x2F;3</td>
</tr>
<tr>
<td align="center">ASTC</td>
<td align="center">1&#x2F;4~1&#x2F;35.95</td>
</tr>
<tr>
<td align="center">PVRTC</td>
<td align="center">1&#x2F;6</td>
</tr>
</tbody></table>
<h3 id="3-实际应用中的选择"><a href="#3-实际应用中的选择" class="headerlink" title="3. 实际应用中的选择"></a><strong>3. 实际应用中的选择</strong></h3><ul>
<li>PC<ul>
<li>低质量使用DXT1，不支持A通道，使用DXT5格式支持A通道</li>
<li>高质量使用BC7，支持A通道</li>
</ul>
</li>
<li>安卓<ul>
<li>低质量使用ETC1，不支持A通道</li>
<li>低质量使用ETC2，支持A通道（Opengl ES3.0&#x2F;Opengl 4.3以上版本）</li>
<li>高质量使用ASTC（Android5.0&#x2F;Opengl ES3.1以上版本）</li>
</ul>
</li>
<li>IOS<ul>
<li>高质量使用ASTC（Iphone6以上版本）</li>
<li>低质量使用PVRTC2（支持Iphone6以下版本）</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>结合今天课程，针对ASTC与ETC2这两个格式进行打包测试，分析内存占用占比。</p>
<p>3.7的作业正好也差不多。。。放个链接</p>
<p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/Lyp-tjMR_/#%E4%BD%9C%E4%B8%9A">https://xzyw7.github.io/post/Lyp-tjMR_/#%E4%BD%9C%E4%B8%9A</a></p>
<p>(ASTC6x6&amp;ETC2)最后包体的体积是非常接近的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824023612935.png" alt="image-20220824023612935"></p>
<p>ASCT</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024417255.png" alt="image-20220824024417255"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024516591.png" alt="image-20220824024516591"></p>
<p>ETC2</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024425619.png" alt="image-20220824024425619"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024506074.png" alt="image-20220824024506074"></p>
<p>就包体而言ASCT6x6是更大一些的，但是最后的内存占用却小了一些。</p>
<p>（帧率的差别应该主要来源于CPU的性能差别，ASTC的CPU性能占用稍高，也就是解码的消耗）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824025009019.png" alt="image-20220824025009019"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824025016354.png" alt="image-20220824025016354"></p>
<p>再用单张贴图的压缩结果来看看各种压缩格式的效果（ASTC压缩实在是有点猛，相比也会占用更多CPU时间）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021751226.png" alt="image-20220824021751226"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021823244.png" alt="image-20220824021823244"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021805123.png" alt="image-20220824021805123"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021840952.png" alt="image-20220824021840952"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021857439.png" alt="image-20220824021857439"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Av411K7bt">https://www.bilibili.com/video/BV1Av411K7bt</a></p>
<p>【技术美术百人计划】图形 3.6 纹理压缩——包体瘦身术</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.6%20%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9/" data-id="cmfe1u6pj002jscuhf1ji5maf" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.7 移动端TB(D)R架构基础" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7%20%E7%A7%BB%E5%8A%A8%E7%AB%AFTB(D)R%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2025-09-10T13:18:14.027Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形-3-7-移动端TB-D-R架构基础"><a href="#图形-3-7-移动端TB-D-R架构基础" class="headerlink" title="图形 3.7 移动端TB(D)R架构基础"></a>图形 3.7 移动端TB(D)R架构基础</h2><h3 id="一、当前移动端GPU概况"><a href="#一、当前移动端GPU概况" class="headerlink" title="一、当前移动端GPU概况"></a><strong>一、当前移动端GPU概况</strong></h3><h4 id="1-1-移动端和桌面端功耗对比"><a href="#1-1-移动端和桌面端功耗对比" class="headerlink" title="1.1 移动端和桌面端功耗对比"></a><strong>1.1 移动端和桌面端功耗对比</strong></h4><p>对于移动端我们通常用soc芯片名称来代指CPU</p>
<p>移动端GPU生产厂商主要是高通adreno，Mali和PowerVR</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822235329719.png" alt="image-20220822235329719"></p>
<h4 id="1-2-移动端和桌面端带宽对比"><a href="#1-2-移动端和桌面端带宽对比" class="headerlink" title="1.2 移动端和桌面端带宽对比"></a><strong>1.2 移动端和桌面端带宽对比</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822235406315.png" alt="image-20220822235406315"></p>
<h3 id="二、名词解释"><a href="#二、名词解释" class="headerlink" title="二、名词解释"></a><strong>二、名词解释</strong></h3><ul>
<li>System on Chip（Soc）<ul>
<li>Soc是把CPU、GPU、内存、通信基带、GPS模块等等整合在一起的芯片的称呼。常见的有A系Soc（苹果），骁龙Soc（高通），麒麟Soc（华为），联发科Soc，猎户座Soc（三星），2020年苹果推出M系Soc，暂用于Mac，这说明手机、笔记本、PC的通用芯片已经出现了。</li>
</ul>
</li>
<li>System Memory<ul>
<li>Soc中GPU和CPU共用一块片内LPDDR物理内存，就是常说的手机内存，也叫System Memory，大概几个G。</li>
<li>此外CPU和GPU还分别有自己的高速SRAM的Cache，也叫On-chip Memory，一般几百k-几M。不同距离的内存访问存在不同时间消耗，距离越近消耗越低，读取System Memory的时间消耗大概是On-chip Memory的几倍到几十倍</li>
<li>（soc上gpu和cpu共享一个（虚拟）内存地址空间）</li>
</ul>
</li>
<li>On-Chip Memory<ul>
<li>在TB(D)R架构下会存储Tile的颜色、深度和模板缓冲，读写修改都非常快。</li>
</ul>
</li>
<li>Stall停滞<ul>
<li>当一个GPU核心的两次计算结果之间有依赖关系而必须串行时，等待的过程便是Stall。</li>
</ul>
</li>
<li>FillRate<ul>
<li>像素填充率 &#x3D; ROP运行的时钟频率 * ROP的个数 * 每个时钟ROP可以处理的像素个数</li>
</ul>
</li>
<li>TB(D)R<ul>
<li>Tile-Based  (Deferred) Rendering</li>
<li>是目前主流的移动GPU渲染架构，对应一般PC上的GPU渲染架构则是IMR（Immediate Mode Rendering）</li>
<li>指屏幕被分块（16*16或32*32像素）渲染</li>
<li>TBR：VS - Defer - Rasterize - PS</li>
<li>TBDR：VS - Defer - Rasterize - Defer - PS</li>
<li>Defer字面是延迟，但从渲染数据的角度来看，Defer就是“阻塞+批处理”GPU的“一帧”的多个数据，然后一起处理</li>
</ul>
</li>
</ul>
<h3 id="三、立即渲染IMR"><a href="#三、立即渲染IMR" class="headerlink" title="三、立即渲染IMR"></a><strong>三、立即渲染IMR</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> draw <span class="keyword">in</span> renderPass:</span><br><span class="line">    <span class="keyword">for</span> primitive <span class="keyword">in</span> draw:</span><br><span class="line">        <span class="keyword">for</span> vertex <span class="keyword">in</span> primitive:</span><br><span class="line">            execute_vertex_shader(vertex)</span><br><span class="line">        <span class="keyword">if</span> primitive <span class="keyword">not</span> culled:</span><br><span class="line">            <span class="keyword">for</span> fragment <span class="keyword">in</span> primitive:</span><br><span class="line">                execute_fragment_shader(fragment)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823000924957.png" alt="image-20220823000924957"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001016993.png" alt="image-20220823001016993"></p>
<h3 id="四、基于块元的渲染TB-D-R"><a href="#四、基于块元的渲染TB-D-R" class="headerlink" title="四、基于块元的渲染TB(D)R"></a><strong>四、基于块元的渲染TB(D)R</strong></h3><p>TB(D)R宏观上分为2阶段</p>
<ol>
<li>第一阶段执行所有与几何相关的处理，并生成Primitive List，并且确定每个tile上面有哪些primitive</li>
<li>第二阶段将逐块执行光栅化及其后续处理，并在完成后将Frame Buffer从Tile Buffer写回到System Memory中。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pass one</span></span><br><span class="line"><span class="keyword">for</span> draw <span class="keyword">in</span> renderPass:</span><br><span class="line">    <span class="keyword">for</span> primitive <span class="keyword">in</span> draw:</span><br><span class="line">        <span class="keyword">for</span> vertex <span class="keyword">in</span> primitive:</span><br><span class="line">            execute_vertex_shader(vertex)</span><br><span class="line">        <span class="keyword">if</span> primitive <span class="keyword">not</span> culled:</span><br><span class="line">            append_tile_list(primitive)</span><br><span class="line"><span class="comment"># Pass two</span></span><br><span class="line"><span class="keyword">for</span> tile <span class="keyword">in</span> renderPass:</span><br><span class="line">    <span class="keyword">for</span> primitive <span class="keyword">in</span> tile:</span><br><span class="line">        <span class="keyword">for</span> fragment <span class="keyword">in</span> primitive:</span><br><span class="line">            execute_fragment_shader(fragment)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001450220.png" alt="image-20220823001450220"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001533374.png" alt="image-20220823001533374"></p>
<h3 id="五、TB-D-R的硬件渲染顺序"><a href="#五、TB-D-R的硬件渲染顺序" class="headerlink" title="五、TB(D)R的硬件渲染顺序"></a><strong>五、TB(D)R的硬件渲染顺序</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001818885.png" alt="image-20220823001818885"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>TBR的核心目的是降低带宽，减少功耗，但渲染帧率上并不比IMR块</strong></p>
<ul>
<li>优点<ul>
<li>TBR给消除Overdraw提供了机会，PowerVR用了HSR技术，Mali用了Forward Pixel Killing技术，目标一样，就是要最大限度减少被遮挡Pixel的texturing和shading。</li>
<li>TBR主要是cached friendly，在cache里读写的速度要比全局内存的速度快得多，以降低render rate的代价，降低带宽，省电</li>
</ul>
</li>
<li>缺点<ul>
<li>Binning过程是在vertex阶段之后，将输出的几何数据写入到DDR，然后才被fs读取。几何数据过多的管线，容易在此处有性能瓶颈。</li>
<li>如果某些三角形叠加在数个tile上，需要绘制数次。意味着总渲染时间将高于即时渲染模式。</li>
</ul>
</li>
</ul>
<h3 id="六、Binning过程"><a href="#六、Binning过程" class="headerlink" title="六、Binning过程"></a><strong>六、Binning过程</strong></h3><p>Binning过程（类似四叉树）&#x2F;第一个Defer</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823002346662.png" alt="image-20220823002346662"></p>
<p>确定哪些块元渲染哪些图元</p>
<h3 id="七、不同GPU的Early-Depth-Test"><a href="#七、不同GPU的Early-Depth-Test" class="headerlink" title="七、不同GPU的Early-Depth-Test"></a><strong>七、不同GPU的Early-Depth-Test</strong></h3><p>第二个Defer</p>
<ul>
<li><p>Android</p>
<ul>
<li>Qualcomm Adreno采用外置模块LRZ。在正常渲染管线前，多执行一次vs生成低精度depth texture，提前剔除不可见的triangles。直接用硬件做occlusion culling，功能类似软光栅遮挡剔除&#x2F;pre-Z</li>
<li>Arm Mali的FPK（Forward Pixel Killing）<ul>
<li>发生在Early-Z之后</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823002835382.png" alt="image-20220823002835382"></li>
</ul>
</li>
</ul>
</li>
<li><p>IOS</p>
<ul>
<li><p>PowerVR的HSR</p>
</li>
<li><p>TBDR的HSR实现</p>
<ul>
<li>HSR&#x3D;Hidden Surface Removal</li>
<li>对每个被投影光束交接的对象进行排序处理（使用分块减少数据集大小）</li>
<li>只有最近的不透明和最近的透明对象需要被渲染</li>
<li>余下的片元被剔除</li>
</ul>
</li>
<li><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823003102289.png" alt="image-20220823003102289"></p>
</li>
</ul>
</li>
</ul>
<h3 id="八、优化建议"><a href="#八、优化建议" class="headerlink" title="八、优化建议"></a><strong>八、优化建议</strong></h3><ul>
<li>不使用FrameBuffer的时候clear或者discard<ul>
<li>主要是清空积存在tile buffer上的中间数据，所以在unity里面对render texture的使用也特别说明了一下，当不再使用这个rt之前，调用一次Discard。在Opengl ES上善用glClear，glInvalidateFrameBuffer避免不必要的Resolve（Resolve就是tile buffer刷新到system memory）行为</li>
</ul>
</li>
<li>不要在一帧里面频繁切换FrameBuffer的绑定<ul>
<li>本质上就是减少tile buffer和system memory之间的stall操作</li>
</ul>
</li>
<li>对于移动平台，建议使用alpha blend而非alpha test<ul>
<li>在实际使用中，你应该分析并比较alpha test和alpha blend的表现，因为这取决于具体内容，通常在移动平台上应避免使用alpha混合来实现透明。需要进行alpha blend时，尝试缩小混合区域的覆盖范围。</li>
</ul>
</li>
<li>手机上必须要做Alpha Test，先做一遍preZ</li>
<li>图片尽量压缩，例如：ASTC，ETC2</li>
<li>图片尽量走mipmap</li>
<li>尽量使用从Vertex shader传来的Varying变量UV值采样贴图（连续的），不要在FragmentShader里动态计算贴图的UV值（非连续的），否则CacheMiss</li>
<li>在延迟渲染尽量利用Tile Buffer</li>
<li>如果你在unity里面调整ProjectSetting&#x2F;Quality&#x2F;Rendering&#x2F;Texture Quality不同的设置，或者不同分辨率下，帧率有很多变化，那么多半是带宽出问题。</li>
<li>MSAA在TBDR下反而是非常快速的。</li>
<li>少在fs中使用discard，调用gl_FragDepth从而打断Early-DT(HLSL中为Clip，GLSL中为discard)</li>
<li>在shader里面浮点数精度，有目的区分使用float，half；<ul>
<li>带宽用量减少</li>
<li>GPU中使用的周期数减少，因为着色器编译器可以优化你的代码以提高并行化程度。</li>
<li>要求的统一变量寄存器数量减少，这反过来又降低了寄存器数量溢出风险</li>
</ul>
</li>
<li>在移动端TB(D)R架构中，顶点处理部分容易成为瓶颈，避免使用曲面细分shader，置换贴图等负操作，提倡使用模型lod，本质上减少FrameData的压力，Unity中尽早在应用阶段借助umbra遮挡剔除。</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><p>结合今天的课程，将最近做的demo继续安卓平台<strong>打包</strong>，<strong>对比</strong>使用课上的优化点前后的性能变化。</p>
<p>这是第一次接触安卓平台的打包与性能分析。。关于性能分析使用了Unity的UPR工具。由于没有什么比较完整的demo，之前所有作业都是塞在一个项目里做的，就直接使用这个场景了，虽然感觉也很难触碰到性能瓶颈什么的。而且能够针对上面优化建议处理的点也不太多。于是选择了最直接的图片纹理压缩的部分（正好下一章节就会讲纹理压缩），应该也算非常适合了。</p>
<p>ASTC和ETC2两种压缩格式都非常接近</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824014740272.png" alt="image-20220824014740272"></p>
<p>而当我手动地取消所有纹理的压缩，改为8位浮点精度储存后，发现对性能的影响比想象中大得多。。。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824014834325.png" alt="image-20220824014834325"></p>
<p>首先是apk文件的大小就增大了一些。其次是最明显的纹理资源峰值这一项，UPR还贴心地提供了说明和优化建议。而且，这里Mipmap甚至已经关掉了。（其实这里做法是相反的，应该关闭压缩开启mip，这样这两个功能在纹理和渲染效率上的作用才是协同的）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824015319329.png" alt="image-20220824015319329"></p>
<p>那么在手机内存占用上，也发生了相应的变化</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020406052.png" alt="image-20220824020406052"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020414939.png" alt="image-20220824020414939"></p>
<ul>
<li><p>ReservedTotal峰值</p>
<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020439183.png" alt="image-20220824020439183"></li>
</ul>
</li>
<li><p>ReservedGFX峰值</p>
<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020513219.png" alt="image-20220824020513219"></li>
</ul>
</li>
</ul>
<p>其次就是帧率也发生了下降。这当然也是由于纹理资源数据变大，计算的速度也就下降了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824015213541.png" alt="image-20220824015213541"></p>
<p>性能分析工具本身还有很多需要去研究的地方，当然这也需要项目内容的支撑。。。鉴于现在也没有什么合适的内容，这里也只能到此为止了，算是一次小小的尝试。当打包出来的项目在手机上成功渲染出画面的时候，还是非常激动的。。。</p>
<p>（此外，曲面细分与几何着色器生成的草地没能在手机上绘制出来，想必也是手机平台不支持这两个着色器的缘故了。）</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Bb4y167zU">https://www.bilibili.com/video/BV1Bb4y167zU</a></p>
<p>【技术美术百人计划】图形 3.7 移动端TB(D)R架构基础</p>
<p>[2] <a target="_blank" rel="noopener" href="https://blog.imaginationtech.com/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/">https://blog.imaginationtech.com/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://upr.unity.cn/instructions/desktop">https://upr.unity.cn/instructions/desktop</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7%20%E7%A7%BB%E5%8A%A8%E7%AB%AFTB(D)R%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" data-id="cmfe1u6pj002lscuh1ss8fjbf" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.2 混合模式及剔除" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.2%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%89%94%E9%99%A4/" class="article-date">
  <time datetime="2025-09-10T13:18:14.026Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-3-2-混合模式及剔除"><a href="#图形-3-2-混合模式及剔除" class="headerlink" title="图形 3.2 混合模式及剔除"></a>图形 3.2 混合模式及剔除</h1><h3 id="一、什么是混合模式"><a href="#一、什么是混合模式" class="headerlink" title="一、什么是混合模式"></a>一、什么是混合模式</h3><ul>
<li>混合<ul>
<li>就是两种颜色混在一起。具体就是把某一像素位置原来的颜色和将要画上去的颜色，通过某种方式混在一起，从而实现新的效果</li>
</ul>
</li>
<li>透过红色玻璃看绿色玻璃<ul>
<li>可以先绘制绿色玻璃，再绘制红色玻璃。在绘制红色的时候，利用混合功能，把将要绘制上去的红色和原来的颜色（绿色）进行混合，于是得到新的颜色</li>
<li>也可以理解成，绿色首先对背景施加影响，无论红色玻璃存在与否，这个影响都是存在的，所以首先计算后面的绿色。然后再考虑前面的红色的影响。这也是我理解透明物体从后往前绘制的原理的一种方式。</li>
</ul>
</li>
</ul>
<p><strong>最终颜色&#x3D;Shader计算后的颜色值*源因子(SrcFactor)+累计颜色*目标因子(DstFactor)</strong></p>
<h3 id="二、混合模式的类型"><a href="#二、混合模式的类型" class="headerlink" title="二、混合模式的类型"></a>二、混合模式的类型</h3><p>PS中的混合模式</p>
<p><img src="/%E5%9B%BE%E5%BD%A23.2%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%89%94%E9%99%A4/image-20220817000953004.png" alt="image-20220817000953004"></p>
<h4 id="ShaderLab内的混合"><a href="#ShaderLab内的混合" class="headerlink" title="ShaderLab内的混合"></a>ShaderLab内的混合</h4><ol>
<li><p>如果颜色的某一分量超过1.0，则会被自动截取位1.0，不需要考虑越界的问题。</p>
</li>
<li><p>再所有着色器执行完毕，所有纹理都被应用，所有像素准备被呈现到屏幕之后，使用Blend命令来操作这些像素混合。</p>
</li>
<li><p>语法</p>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Blend Off</td>
<td>关闭blend混合（默认）</td>
</tr>
<tr>
<td align="left">Blend SrcFactor DstFactor</td>
<td>配置并启动混合计算</td>
</tr>
<tr>
<td align="left">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td>
<td>同上，但是使用不同的要素来混合Alpha通道</td>
</tr>
<tr>
<td align="left">BlendOp Value</td>
<td>如果使用BlendOp命令，则混合操作将设置为该值。否则，混合操作默认为Add。</td>
</tr>
<tr>
<td align="left">BlendOp OpColor, OpAlpha</td>
<td>同上，但是使用不同的操作来处理alpha通道</td>
</tr>
<tr>
<td align="left">AlphaToMaskOn</td>
<td>常用于开启MSAA的地表植被的渲染</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="Blend和BlendOp"><a href="#Blend和BlendOp" class="headerlink" title="Blend和BlendOp"></a>Blend和BlendOp</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">finalValue = sourceFactor * sourceValue operation destinationFactor * destinationValue</span><br><span class="line"><span class="comment">//finalValue: GPU写入目标缓冲区的值</span></span><br><span class="line"><span class="comment">//sourceFactor: Blend命令中定义</span></span><br><span class="line"><span class="comment">//sourceValue: 片元着色器输出的值</span></span><br><span class="line"><span class="comment">//operation: 混合操作</span></span><br><span class="line"><span class="comment">//destinationFactor: Blend命令中定义</span></span><br><span class="line"><span class="comment">//destinationValue: 目标缓冲区现有值的值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以写在Pass中或SubShader中(BlendOp在同一个代码块中还必须有一个Blend命令)</li>
<li>启用混合会禁用GPU上的一些优化（主要是隐藏表面去除Early-Z）</li>
</ul>
<h3 id="三、混合模式的实现方式"><a href="#三、混合模式的实现方式" class="headerlink" title="三、混合模式的实现方式"></a>三、混合模式的实现方式</h3><h4 id="Unity附带的Blend枚举"><a href="#Unity附带的Blend枚举" class="headerlink" title="Unity附带的Blend枚举"></a>Unity附带的Blend枚举</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//混合模式</span></span><br><span class="line">[Enum(UnityEngine.Rendering.BlendOp)] _BlendOp (&quot;BlendOp&quot;, <span class="type">float</span>) = <span class="number">0</span></span><br><span class="line">[Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (&quot;SrcBlend&quot;, <span class="type">float</span>) = <span class="number">1</span></span><br><span class="line">[Enum(UnityEngine.Rendering.BlendMode)]</span><br><span class="line">_DstBlend (&quot;DstBlend&quot;, <span class="type">float</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度开关</span></span><br><span class="line"><span class="comment">//ZWriteMode没有内置，只有两种状态，也可以用Toogle</span></span><br><span class="line">[Enum(Off, <span class="number">0</span>, On, <span class="number">1</span>)] _ZWriteMode (&quot;ZWriteMode&quot;, <span class="type">float</span>) = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">SubShader&#123;</span><br><span class="line">    Tag &#123;&quot;RenderType&quot; = &quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent&quot;&#125;</span><br><span class="line">    ZWrite [_ZWriteMode]</span><br><span class="line">    Blend [_SrcBlend] [_DstBlend]</span><br><span class="line">    <span class="comment">//这部分定义是CPU阶段的渲染设置，并不传入shader，不用定义uniform</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Photoshop的Blend实现方式"><a href="#Photoshop的Blend实现方式" class="headerlink" title="Photoshop的Blend实现方式"></a>Photoshop的Blend实现方式</h4><p>自己查吧</p>
<ul>
<li>普通的Blend<ul>
<li>Blend SrcAlpha OneMinusSrcAlpha<ul>
<li>&#x2F;&#x2F;Alpha混合 Alpha Blending</li>
</ul>
</li>
</ul>
</li>
<li>变暗Darken<ul>
<li>BlendOp Min</li>
<li>Blend One One</li>
<li>min(当前颜色，缓存颜色)*1</li>
</ul>
</li>
<li>正片叠底<ul>
<li>Blend Discolors Zero</li>
<li>当前颜色*缓存颜色+缓存颜色*0</li>
</ul>
</li>
<li>滤色Screen<ul>
<li>Blend OneMinusDstColor One 或Blend One OneMinusSrcColor</li>
<li>Src*(1-Dst)+Dst*1 &#x3D; Src+Dst-Src*Dst</li>
<li>当前颜色*(1-缓存颜色)+缓存颜色*1 或 当前颜色*1 + 缓存颜色* (1-缓存颜色)</li>
</ul>
</li>
<li>变亮Lighten<ul>
<li>BlendOp Max</li>
<li>Blend One One</li>
<li>max(当前颜色，缓存颜色)</li>
</ul>
</li>
<li>线性减淡LinearDodge<ul>
<li>Blend One One</li>
<li>缓存颜色*1+当前颜色*1</li>
</ul>
</li>
<li>颜色加深ColorBurn<ul>
<li>高级Opengl混合</li>
<li>此模式目前仅在具有GL_KHR_blend_equation_advanced或GL_NV_blend_equation_advanced扩展支持的Opengl硬件上可用</li>
<li>1-（1-Dst）&#x2F;Src</li>
</ul>
</li>
<li>。。。</li>
</ul>
<h3 id="四、剔除的实现方式"><a href="#四、剔除的实现方式" class="headerlink" title="四、剔除的实现方式"></a>四、剔除的实现方式</h3><ul>
<li>法线剔除<ul>
<li>也称背面消隐，根据法线朝向判断哪个面被剔除掉，可以用来控制是否双面渲染</li>
<li>Cull + [Off, Front, Back]</li>
</ul>
</li>
<li>面裁切<ul>
<li>Clip函数会参数小于某像素点直接在片元阶段丢弃，常用于制作溶解，裁剪等效果</li>
<li>Clip();&#x2F;&#x2F;默认会切掉0.5的部分，或者使用if</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(input.posInObjectCoords.y &gt; <span class="number">0.5</span>) <span class="keyword">discard</span>;</span><br><span class="line"><span class="comment">//剔除模式</span></span><br><span class="line">[Enum(UnityEngine.Rendering.CullMode)] _CullMode (&quot;CullMode&quot;, <span class="type">float</span>) = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>开启双面渲染相当于绘制了两次</li>
<li>Clip函数在某些PowerVR的机型上效率低</li>
<li>面裁切Clip使用AlphaTest队列</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>实现常用的混合模式，并设计使用界面</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sL4y1v7SS">https://www.bilibili.com/video/BV1sL4y1v7SS</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.2%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%89%94%E9%99%A4/" data-id="cmfe1u6ph002bscuhh5u794qe" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.3 曲面细分与几何着色器" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.3%20%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/" class="article-date">
  <time datetime="2025-09-10T13:18:14.026Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-3-3-曲面细分与几何着色器"><a href="#图形-3-3-曲面细分与几何着色器" class="headerlink" title="图形 3.3  曲面细分与几何着色器"></a>图形 3.3  曲面细分与几何着色器</h1><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a><strong>一、背景</strong></h3><h4 id="1-1应用"><a href="#1-1应用" class="headerlink" title="1.1应用"></a><strong>1.1应用</strong></h4><ul>
<li>曲面细分着色器<ul>
<li>海浪（曲面细分+顶点位移动画）</li>
<li>（交互）雪地（曲面细分+顶点位移）</li>
<li>置换贴图（曲面细分+顶点位移）</li>
</ul>
</li>
<li>几何着色器<ul>
<li>几何动画（几何图元）</li>
<li>草地等（与曲面细分着色器结合）</li>
</ul>
</li>
</ul>
<h4 id="1-2渲染管线"><a href="#1-2渲染管线" class="headerlink" title="1.2渲染管线"></a><strong>1.2渲染管线</strong></h4><ul>
<li>顶点着色器</li>
<li>曲面细分着色器<ul>
<li>细分控制着色器Hull Shader（TCS）</li>
<li>Tessellation Primitive Generator（不可编程）</li>
<li>细分计算着色器Domain Shader（TES）</li>
</ul>
</li>
<li>几何着色器</li>
<li>片元着色器</li>
</ul>
<h4 id="1-3曲面细分着色器"><a href="#1-3曲面细分着色器" class="headerlink" title="1.3曲面细分着色器"></a><strong>1.3曲面细分着色器</strong></h4><h5 id="1-3-1TESS的输入与输出"><a href="#1-3-1TESS的输入与输出" class="headerlink" title="1.3.1TESS的输入与输出"></a><strong>1.3.1TESS的输入与输出</strong></h5><ul>
<li><p>Hull Stage</p>
<ul>
<li>Hull function<ul>
<li>每个patch每个顶点运行一次</li>
<li>输入<ul>
<li>Patch，可以看成是多个顶点的集合，包含每个顶点的属性，可以指定一个Patch包含的顶点数以及自己的属性</li>
<li>Index，指定hull shader输出patch中的哪一个顶点</li>
</ul>
</li>
<li>输出patch内对应顶点</li>
</ul>
</li>
<li>Patch Constant Function<ul>
<li>输入Patch</li>
<li>每个patch运行一次</li>
<li>输出Tessellation Factor</li>
</ul>
</li>
<li>两个阶段是并行</li>
<li>功能<ul>
<li>将图元细分（三角形、矩形等）</li>
</ul>
</li>
<li>输出<ul>
<li>细分后的顶点数据</li>
</ul>
</li>
</ul>
</li>
<li><p>Tessellation Primitive Generator</p>
<ul>
<li>为新网格的所有顶点生成重心坐标</li>
</ul>
</li>
<li><p>Domain stage</p>
<ul>
<li>输入重心坐标、Patch</li>
<li>为细分后曲面的所有顶点运行一次</li>
<li>通常在顶点着色器的逻辑操作的部分，应该放在这里</li>
</ul>
</li>
<li><p>（Geometry Stage）</p>
</li>
</ul>
<h5 id="1-3-2HULL-shader参数"><a href="#1-3-2HULL-shader参数" class="headerlink" title="1.3.2HULL shader参数"></a><strong>1.3.2HULL shader参数</strong></h5><ul>
<li>Tessellation Factor<ul>
<li>决定将一条边分成几部分</li>
<li>equal_Spacing</li>
<li>fractional_even_spacing</li>
<li>fractional_odd_spacing</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818002411909.png" alt="image-20220818002411909"></p>
<ul>
<li>Inner Tessellation Factor<ul>
<li>（与上面的参数是同一等级）将边等分后，向内延伸相交，直至内部没有交点。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818002434236.png" alt="image-20220818002434236"></p>
<h4 id="1-4几何着色器"><a href="#1-4几何着色器" class="headerlink" title="1.4几何着色器"></a><strong>1.4几何着色器</strong></h4><h5 id="1-4-1几何着色器的输入与输出"><a href="#1-4-1几何着色器的输入与输出" class="headerlink" title="1.4.1几何着色器的输入与输出"></a><strong>1.4.1几何着色器的输入与输出</strong></h5><ul>
<li>输入为图元（三角形、矩形、边）<ul>
<li>根据图元不同，shader中会出现对应不同数量的顶点</li>
</ul>
</li>
<li>输出同样为图元（一个或多个），需要自己从顶点构建，顺序很重要，同时定义最大输出的顶点数</li>
</ul>
<h3 id="二、曲面细分"><a href="#二、曲面细分" class="headerlink" title="二、曲面细分"></a><strong>二、曲面细分</strong></h3><ul>
<li>将一个Quad细分</li>
<li>与置换贴图结合<ul>
<li>注意使用置换贴图不在fs中，也是在domain shader中的vert函数进行的，GPU无法获取mipmap信息，需要使用tex2Dlod等来读取图片。</li>
<li>法线也需要重新计算</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> hull hullProgram</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> domain ds</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex tessvert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Tessellation.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">...    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexInput</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexOutput</span>&#123;</span><br><span class="line">    float4 vertex: SV_POSITION;</span><br><span class="line">    float3 normal;</span><br><span class="line">    float3 tangent;</span><br><span class="line">    float2 uv;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function">VertexOutput <span class="title">vert</span><span class="params">(VertexInput v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VertexOutput o;</span><br><span class="line">    o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv,_MainTex);</span><br><span class="line">    o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">    o.normal = v.normal;</span><br><span class="line">    o.tangent = v.tangent;</span><br><span class="line">&#125;<span class="comment">//顶点着色器的函数，但这里没有拿给顶点着色器，而是用来在DomainShader进行空间转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只有在能够使用曲面细分着色器的平台才能使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNITY_CAN_COMPIE_TESSELLATION</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TessVertex</span> &#123;</span><br><span class="line">	float4 vertex: INTERNALTESSPOS;</span><br><span class="line">    float3 normal: NORMAL;</span><br><span class="line">    float4 tangent: TANGENT;</span><br><span class="line">    float2 uv: TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OutputPatchConstant</span> &#123;<span class="comment">//不同的图元，该结构会有不同</span></span><br><span class="line">	<span class="type">float</span> edge[<span class="number">3</span>]: SV_TESSFACTOR;</span><br><span class="line">    <span class="type">float</span> inside: SV_INSIDETESSFACTOR;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TessVertex <span class="title">tessvert</span><span class="params">(VertexInput v)</span></span>&#123;</span><br><span class="line">    TessVertex o;</span><br><span class="line">    o.vertex = v.vertex;</span><br><span class="line">    o.normal = v.normal;</span><br><span class="line">    o.tangent = v.tangent;</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="comment">//顶点着色器，注意这里没有进行空间转换，而是在domianshader里进行的空间转换 </span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> _TessellationUniform;</span><br><span class="line"><span class="function">OutputPatchConstant <span class="title">hsconst</span><span class="params">(InputPatch&lt;TessVertex, <span class="number">3</span>&gt; patch)</span> </span>&#123;</span><br><span class="line">    OutputPatchConstant o;</span><br><span class="line">    o.edge[<span class="number">0</span>] = _TessellationUniform;</span><br><span class="line">    o.edge[<span class="number">1</span>] = _TessellationUniform;</span><br><span class="line">    o.edge[<span class="number">2</span>] = _TessellationUniform;</span><br><span class="line">    o.inside = _TessellationUniform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Hull shader的函数</span></span><br><span class="line">[<span class="built_in">UNITY_domian</span>(<span class="string">&quot;tri&quot;</span>)]<span class="comment">//指定图元</span></span><br><span class="line">[<span class="built_in">UNITY_partitioning</span>(<span class="string">&quot;fractional_odd&quot;</span>)]<span class="comment">//拆分edge的方式，equal_spacing等</span></span><br><span class="line">[<span class="built_in">UNITY_outputtopology</span>(<span class="string">&quot;triangl_cw&quot;</span>)]</span><br><span class="line">[<span class="built_in">UNITY_patchconstantfunc</span>(<span class="string">&quot;hsconst&quot;</span>)]<span class="comment">//指定patch const function。一个patch一共有三个点，但是这三个点都共用这个函数</span></span><br><span class="line">[<span class="built_in">UNITY_outputcontrolpoints</span>(<span class="number">3</span>)]<span class="comment">//不同图元会对应不同控制点</span></span><br><span class="line"><span class="function">TessVertex <span class="title">hullProgram</span><span class="params">(InputPatch&lt;TessVertex, <span class="number">3</span>&gt; patch, uint id : SV_OutputControlPointID)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> patch[id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Domian shader的函数</span></span><br><span class="line">[<span class="built_in">UNITY_domain</span>(<span class="string">&quot;tri&quot;</span>)]<span class="comment">//同样指定图元</span></span><br><span class="line"><span class="function">VertexOutput <span class="title">ds</span> <span class="params">(OutputPatchConstant tessFactors, <span class="type">const</span> OutputPatch&lt;TessVertex, <span class="number">3</span>&gt; patch, float3 bary : SV_DomainLocation)</span> </span>&#123;</span><br><span class="line"><span class="comment">//bary重心坐标</span></span><br><span class="line"><span class="comment">//计算模型空间位置</span></span><br><span class="line">    VertexInput v;</span><br><span class="line">    v.vertex = patch[<span class="number">0</span>].vertex*bary.x + patch[<span class="number">1</span>].vertex*bary.y + patch[<span class="number">2</span>].vertex*bary.z;</span><br><span class="line">    v.tangent = patch[<span class="number">0</span>].tangent*bary.x + patch[<span class="number">1</span>].tangent*bary.y + patch[<span class="number">2</span>].tangent*bary.z;</span><br><span class="line">    v.normal = patch[<span class="number">0</span>].normal*bary.x + patch[<span class="number">1</span>].normal*bary.y + patch[<span class="number">2</span>].normal*bary.z;</span><br><span class="line">    v.uv = patch[<span class="number">0</span>].uv*bary.x + patch[<span class="number">1</span>].uv*bary.y + patch[<span class="number">2</span>].uv*bary.z;</span><br><span class="line">    VertexOutput o = <span class="built_in">vert</span>(v);<span class="comment">//调用原本该在顶点着色器中的转换函数。</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="comment">//这里才终于把顶点数据拿给下一阶段</span></span><br><span class="line"></span><br><span class="line">#ENDIF</span><br><span class="line"></span><br><span class="line">float4 frag...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、几何着色器"><a href="#三、几何着色器" class="headerlink" title="三、几何着色器"></a><strong>三、几何着色器</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> geometry geo</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexInput</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexOutput</span>&#123;</span><br><span class="line">    float4 vertex: SV_POSITION;</span><br><span class="line">    float3 normal;</span><br><span class="line">    float3 tangent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意这次的顶点着色器是vert函数，上次是tessvert,同样不做任何操作</span></span><br><span class="line">VertexOutput vert;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">geometryOutput</span>&#123;</span><br><span class="line">    float4 pos: SV_POSITION;</span><br><span class="line">    float2 uv: TEXCOORD0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">geopetryOutput <span class="title">CreateGeoOutput</span><span class="params">(float3 pos, float2 uv)</span></span>&#123;</span><br><span class="line">    geometryOutput o;</span><br><span class="line">    o.pos = UnityObjectToClipPos;</span><br><span class="line">    o.uv = uv;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="comment">//在几何着色器中完成空间转换，如果同时使用曲面细分和几何着色器，也要放到几何着色器来进行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="built_in">maxvertexcount</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">geo</span><span class="params">(triangle vertexOutput IN[<span class="number">3</span>]: SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> pos = IN[<span class="number">0</span>].vertex;</span><br><span class="line">    <span class="type">float</span> vNormal = IN[<span class="number">0</span>].normal;</span><br><span class="line">    <span class="type">float</span> vTangent = IN[<span class="number">0</span>].tangent;</span><br><span class="line">    <span class="type">float</span> vBinormal = <span class="built_in">cross</span>(vNormal,vTangent)*vTangent.w;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> height = ...</span><br><span class="line">    <span class="type">float</span> width = ...</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    geometryOutput o;</span><br><span class="line">    triStream.<span class="built_in">Append</span>(<span class="built_in">CreatGeoOutput</span>(<span class="built_in">dosomething</span>(pos),<span class="built_in">dosomething</span>(uv));</span><br><span class="line">    triStream.<span class="built_in">Append</span>(<span class="built_in">CreatGeoOutput</span>(<span class="built_in">dosomething</span>(pos),<span class="built_in">dosomething</span>(uv));</span><br><span class="line">    triStream.<span class="built_in">Append</span>(<span class="built_in">CreatGeoOutput</span>(<span class="built_in">dosomething</span>(pos),<span class="built_in">dosomething</span>(uv));<span class="comment">//添加了一个新的三角形图元                            </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以添加更多图元，如：</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818013037250.png" alt="image-20220818013037250" style="zoom:50%;" />



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818013127627.png" alt="image-20220818013127627"></p>
<p>三角形的构建是triStream自动完成的。（uv是自己计算的。）</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><p>使用曲面细分、几何着色器做一些有意思的Demo</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1661109050656-1661142579854.gif" alt="1661109050656"></p>
<p>看了一圈，基本上大家都是参考那两个教程，就不多写什么了。（做到这个效果还挺想复刻一下Clannad的片头的，说不定挺适合）</p>
<p>这里主要完成了基本的曲面细分-几何着色器多pass渲染带阴影和光照的草地-风的扰动。</p>
<p>事实上，几何着色器构建的图元会覆盖原来的三角形图元，原来的表面其实消失了。这里可以再加一个pass渲染。</p>
<p>并且地面pass可以不做细分来节省开销</p>
<p>还可以进一步处理的部分：</p>
<ul>
<li>基于距离的曲面细分</li>
<li>基于RT或物体位置的草地交互</li>
</ul>
<p>继续往后做这两个方向感觉就需要考虑偏向may佬说的在项目中整体方案的思路了。</p>
<p>暂时就放一放</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XX4y1A7Ns">https://www.bilibili.com/video/BV1XX4y1A7Ns</a></p>
<p>【技术美术百人计划】图形 3.3  曲面细分与几何着色器  大规模草渲染</p>
<p>[2] <a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/">https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://roystan.net/articles/grass-shader.html">https://roystan.net/articles/grass-shader.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.3%20%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/" data-id="cmfe1u6pi002fscuh27z74ht8" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.7 LDR与HDR" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.7%20LDR%E4%B8%8EHDR/" class="article-date">
  <time datetime="2025-09-10T13:18:14.025Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-2-7-LDR与HDR"><a href="#图形-2-7-LDR与HDR" class="headerlink" title="图形 2.7  LDR与HDR"></a>图形 2.7  LDR与HDR</h1><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>HDR &#x3D; High Dynamic Range（高动态范围）</p>
<p>LDR &#x3D; Low Dynamic Range（低动态范围）</p>
<p>动态范围 &#x3D; 最高亮度&#x2F;最低亮度</p>
<ul>
<li><p>对于显示器来说，实际的物理亮度是不同意的。因此需要匹配LDR0-1的范围</p>
</li>
<li><p>自然界中的亮度是HDR的</p>
<ul>
<li>在显示时需要转换到LDR的范围（Tone mapping色调映射）</li>
</ul>
</li>
<li><p>LDR</p>
<ul>
<li>8位精度</li>
<li>单通道0-1（0-255）</li>
<li>常用LDR图片储存格式<ul>
<li>jpg、png等</li>
</ul>
</li>
<li>拾色器、一般图片、电脑屏幕</li>
</ul>
</li>
<li><p>HDR</p>
<ul>
<li>远高于8位精度</li>
<li>单通道可以超过1</li>
<li>常用HDR图片储存格式<ul>
<li>hdr&#x2F;tif&#x2F;exr&#x2F;raw</li>
</ul>
</li>
<li>HDRI、真实世界</li>
</ul>
</li>
</ul>
<h4 id="为什么需要HDR"><a href="#为什么需要HDR" class="headerlink" title="为什么需要HDR"></a>为什么需要HDR</h4><ul>
<li>更好地色彩，更高的动态范围和更丰富的细节，并有效地防止画面国宝，超过亮度值1的色彩也能很好地表现，像素光亮度变得正常，视觉传达更真实。</li>
<li>HDR有超过1的数值，范围更大，能让bloom的表现更好。</li>
</ul>
<h4 id="一些HDR图网站"><a href="#一些HDR图网站" class="headerlink" title="一些HDR图网站"></a>一些HDR图网站</h4><p><a target="_blank" rel="noopener" href="http://www.hdrlabs.com/sibl/archive.html">http://www.hdrlabs.com/sibl/archive.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.openfootage.net/hdri-panorama/">https://www.openfootage.net/hdri-panorama/</a></p>
<h3 id="二、Unity中的HDR"><a href="#二、Unity中的HDR" class="headerlink" title="二、Unity中的HDR"></a>二、Unity中的HDR</h3><h4 id="Camera-HDR设置"><a href="#Camera-HDR设置" class="headerlink" title="Camera-HDR设置"></a>Camera-HDR设置</h4><ul>
<li>场景将渲染为HDR图像缓冲区</li>
<li>后处理：Bloom&amp;Tone mapping</li>
<li>完成转换HDR-&gt;LDR</li>
<li>LDR图像发送给显示器</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730183404967.png" alt="image-20220730183404967" style="zoom:67%;" />

<h4 id="Lightmap-HDR设置"><a href="#Lightmap-HDR设置" class="headerlink" title="Lightmap HDR设置"></a>Lightmap HDR设置</h4><ul>
<li>选择High Quality 将启用HDR光照贴图支持，而Normal Quality将切换为使用RGBM编码</li>
<li>RGBM编码：将颜色存储在RGB通道中，将乘数M储存在Alpha通道中</li>
</ul>
<p>（项目设置-Player-Other settings-Lightmap Encoding）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730183556522.png" alt="image-20220730183556522" style="zoom:67%;" />

<h4 id="拾色器HDR设置"><a href="#拾色器HDR设置" class="headerlink" title="拾色器HDR设置"></a>拾色器HDR设置</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HDR] _BackColor(&quot;BackColor&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Intensity滑动条可调整颜色强度</li>
<li>每增加1，提供的光亮增加一倍</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730183703721.png" alt="image-20220730183703721"></p>
<h4 id="HDR的优缺点"><a href="#HDR的优缺点" class="headerlink" title="HDR的优缺点"></a>HDR的优缺点</h4><ul>
<li>优点<ul>
<li>画面中亮度超过1的部分不会被截为1，增加亮部细节并减少曝光</li>
<li>减少画面较暗部分的色阶感</li>
<li>更好地支持Bloom</li>
</ul>
</li>
<li>缺点<ul>
<li>渲染速度较慢，需要更多显存</li>
<li>不支持硬件AA</li>
<li>部分手机不支持</li>
</ul>
</li>
</ul>
<h3 id="三、HDR与Bloom"><a href="#三、HDR与Bloom" class="headerlink" title="三、HDR与Bloom"></a>三、HDR与Bloom</h3><p>Bloom用于表现高光的晕光效果</p>
<p><em>为实现泛光，我们像平时那样渲染一个有光场景，提取出场景的HDR颜色缓冲以及只有这个场景明亮区域可见的图片。被提取的带有亮度的图片接着被模糊，结果被添加到HDR场景上面。（learnopengl）</em></p>
<h4 id="unity中的BLoom"><a href="#unity中的BLoom" class="headerlink" title="unity中的BLoom"></a>unity中的BLoom</h4><p>Untiy会首先进行下采样（down sample）来计算高光像素，并存在RT中，完成次数由一个参数控制，再up回去，并将下采样的RT加入进去。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730184829163.png" alt="image-20220730184829163" style="zoom:50%;" />

<p>我对这个操作目前的理解是，和learnopengl中为了完成高斯模糊是一样的</p>
<p><img src="https://learnopengl-cn.github.io/img/05/07/bloom_gaussian.png" alt="img"></p>
<p>在毛星云大佬的  《高品质后处理：十种图像模糊算法的总结与实现》中也可以看到对各种模糊算法的解释，如果说是以多次的Box filtering来近似高斯模糊或者其他模糊效果的话，就很好理解了。</p>
<h3 id="四、HDR与Tone-mapping"><a href="#四、HDR与Tone-mapping" class="headerlink" title="四、HDR与Tone mapping"></a>四、HDR与Tone mapping</h3><p>色调映射就是为了把HDR转化为LDR</p>
<ul>
<li>线性映射效果不好</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730185314765.png" alt="image-20220730185314765" style="zoom:50%;" />



<ul>
<li>把高光区域和阴影区域像中等亮度方向压缩-&gt;S曲线</li>
</ul>
<h4 id="ACES"><a href="#ACES" class="headerlink" title="ACES"></a>ACES</h4><p>ACES（Academy Color Encoding System学院颜色编码系统）</p>
<p>效果：对比度提高，很好地保留暗处和亮出的细节</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730185423773.png" alt="image-20220730185423773" style="zoom:50%;" />

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ACES</span></span><br><span class="line"><span class="comment">//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</span></span><br><span class="line">float3 ACESToneMapping(float3 color, <span class="type">float</span> adapted_lum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> A = <span class="number">2.51</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> B = <span class="number">0.03</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> C = <span class="number">2.43</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> D = <span class="number">0.59</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> E = <span class="number">0.14</span>f;</span><br><span class="line"></span><br><span class="line">	color *= adapted_lum;</span><br><span class="line">	<span class="keyword">return</span> (color * (A * color + B)) / (color * (C * color + D) + E);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他Tone mapping曲线</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730185538359.png" alt="image-20220730185538359" style="zoom:50%;" />

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reinhard</span></span><br><span class="line">float3 ReinhardToneMapping(float3 color, <span class="type">float</span> adapted_lum) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">float</span> MIDDLE_GREY = <span class="number">1</span>;</span><br><span class="line">    color *= MIDDLE_GREY / adapted_lum;</span><br><span class="line">    <span class="keyword">return</span> color / (<span class="number">1.0</span>f + color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CE</span></span><br><span class="line">float3 CEToneMapping(float3 color, <span class="type">float</span> adapted_lum) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - <span class="built_in">exp</span>(-adapted_lum * color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Filmic</span></span><br><span class="line">float3 F(float3 x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> A = <span class="number">0.22</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> B = <span class="number">0.30</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> C = <span class="number">0.10</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> D = <span class="number">0.20</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> E = <span class="number">0.01</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> F = <span class="number">0.30</span>f;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 Uncharted2ToneMapping(float3 color, <span class="type">float</span> adapted_lum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> WHITE = <span class="number">11.2</span>f;</span><br><span class="line">	<span class="keyword">return</span> F(<span class="number">1.6</span>f * adapted_lum * color) / F(WHITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LUT"><a href="#LUT" class="headerlink" title="LUT"></a>LUT</h4><p>在Color Grading的All None 模式中有一个Lookup Texture（滤镜）</p>
<ul>
<li><p>LUT在LDR之间做变换，Tone mapping是映射HDR到LDR</p>
</li>
<li><p>调整rgb三个通道的LUT被称为3D LUT</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/v2-cc29cf797d187c730f13cfc0bf520714_720w.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/v2-c7d19e036fe6edf8df4d5e694874df50_720w.jpg" alt="img"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="结合先行版基础渲染光照介绍（一）试试IBL在HDR和LDR的区别"><a href="#结合先行版基础渲染光照介绍（一）试试IBL在HDR和LDR的区别" class="headerlink" title="结合先行版基础渲染光照介绍（一）试试IBL在HDR和LDR的区别"></a>结合先行版基础渲染光照介绍（一）试试IBL在HDR和LDR的区别</h4><p>相机设置HDR</p>
<p>左侧探针设置LDR，右侧探针设置HDR，都是1024的分辨率</p>
<p>在生成的贴图上可以看到，一张是exr后缀的HDR贴图，一张是png后缀的LDR贴图。</p>
<p>把它放在我们的材质上，说实话我没看出来有啥区别……</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731223034086.png" alt="image-20220731223034086"></p>
<p>但是随着Lod层级的增加，就可以看出来区别了</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731223343672.png" alt="image-20220731223343672" style="width: 50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731223409296.png" alt="image-20220731223409296" style="width: 50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731223432177.png" alt="image-20220731223432177" style="width:50%;" />

<p>非常地合情合理，在HDR中储存的辐射度范围是大于0-1的，在mipmap中也会储存更高动态范围的光照，在ibl里的细节也就更丰富。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VA41137Wp">https://www.bilibili.com/video/BV1VA41137Wp</a> 【技术美术百人计划】图形 2.7  LDR与HDR</p>
<p>[2] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/07%20Bloom/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/07%20Bloom/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/125744132">https://zhuanlan.zhihu.com/p/125744132</a> 高品质后处理：十种图像模糊算法的总结与实现</p>
<p>[4] Unity Shader入门精要 p361,362</p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21983679">https://zhuanlan.zhihu.com/p/21983679</a> Tone mapping进化论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.7%20LDR%E4%B8%8EHDR/" data-id="cmfe1u6pg0023scuh491u07gn" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.8 flowmap的实现" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.8%20flowmap%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2025-09-10T13:18:14.025Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形2-8-flowmap的实现——流动效果实现"><a href="#图形2-8-flowmap的实现——流动效果实现" class="headerlink" title="图形2.8 flowmap的实现——流动效果实现"></a>图形2.8 flowmap的实现——流动效果实现</h1><h3 id="一、Flowmap是什么"><a href="#一、Flowmap是什么" class="headerlink" title="一、Flowmap是什么"></a>一、Flowmap是什么</h3><ul>
<li>Flowmap的实质<ul>
<li>一张记录了2D向量信息的纹理</li>
<li>Flowmap上的颜色（RG）记录该处向量场的方向，让模型上某一点表现出定量流动的特征</li>
<li>通过在shader中偏移uv再对纹理进行采样，来模拟流动效果。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220806235307299.png" alt="image-20220806235307299"></p>
<p>&#x3D;&#x3D;ue4与unity相比反转了绿通道&#x3D;&#x3D;</p>
<h3 id="二、Flowmap-shader"><a href="#二、Flowmap-shader" class="headerlink" title="二、Flowmap shader"></a>二、Flowmap shader</h3><ol>
<li>采样Flowmap获取向量场信息<ul>
<li>Flowmap不能直接使用，需要从0，1映射到-1，1</li>
</ul>
</li>
<li>用向量场信息，使采样贴图时的uv随时间变化</li>
<li>对同一贴图以半个周期的相位差采集两次，并线性插值，使贴图流动连续</li>
</ol>
<ul>
<li>随着时间进行，变形越来越大，为了把偏移控制在一定范围内</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> phase = frac(_Time);</span><br><span class="line"><span class="comment">// 解决frac产生的跳变</span></span><br><span class="line"><span class="comment">// 构造周期相同，相位相差半个周期的波形函数</span></span><br><span class="line"><span class="type">float</span> phase0 = frac(_Time * <span class="number">0.1</span> * _TimeSpeed);</span><br><span class="line"><span class="type">float</span> phase1 = frac(_Time * <span class="number">0.1</span> * _TimeSpeed + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220807000102114.png" alt="image-20220807000102114"></p>
<ul>
<li>用相位差半个周期的两层采样进行加权混合，使纹理流动一个周期重新开始时的不自然情况被另一层采样覆盖</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220807000117694.png" alt="image-20220807000117694"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float2 tiling_uv = i.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">half3 tex0 = tex2D(_MainTex, tiling_uv - floatDir.xy * phase0);</span><br><span class="line">half3 tex1 = tex2D(_MainTex, tiling_uv - floatDir.xy * phase1);</span><br><span class="line"><span class="comment">//构造函数计算随波形函数变化的权值，</span></span><br><span class="line"><span class="comment">//使得纹理采样值在接近最大偏移时有权值0，并因此消隐，构造较平滑的循环</span></span><br><span class="line"><span class="type">float</span> flowLerp = <span class="built_in">abs</span>((<span class="number">0.5</span>-phase0)/<span class="number">0.5</span>);</span><br><span class="line">half3 finalColor = lerp(tex0,tex1,flowLerp);</span><br></pre></td></tr></table></figure>



<h3 id="三、Flowmap的制作"><a href="#三、Flowmap的制作" class="headerlink" title="三、Flowmap的制作"></a>三、Flowmap的制作</h3><h4 id="Flowmap-painter"><a href="#Flowmap-painter" class="headerlink" title="Flowmap painter"></a>Flowmap painter</h4><p>Flowmap painter是unity制作的绘制flowmap的工具（用该工具得到的flowmap是线性空间颜色，不需要gamma矫正，在unity中取消勾选sRGB）</p>
<p>本来还以为这种东西要手动在ps里画RG通道。。。有点头疼来着，没想到这个工具这么方便，并且可以支持flow的效果实时可视化。</p>
<h4 id="Houdini-Labs"><a href="#Houdini-Labs" class="headerlink" title="Houdini Labs"></a>Houdini Labs</h4><p>Houdini Labs是内置在Houdini中的一组游戏开发相关的节点，可以在github中搜索sidefx Labs或直接在houdini中安装（在较早版本中的shoudini中无法在shelf内找到，在这些未被内置到houdini的版本中，这组工具名称为gamedev）</p>
<ol>
<li><strong>flowmap相关节点功能</strong></li>
</ol>
<ul>
<li>grid<ul>
<li>细分</li>
</ul>
</li>
<li>flowmap<ul>
<li>初始化向量场</li>
</ul>
</li>
<li>flowmap_brush<ul>
<li>向量场笔刷</li>
</ul>
</li>
<li>flowmap_to_color<ul>
<li>将向量映射到颜色</li>
<li>并添加uv（如有uv则直接沿用）</li>
</ul>
</li>
<li>flowmap_visualize<ul>
<li>可视化flowmap效果</li>
</ul>
</li>
<li>maps_baker<ul>
<li>导出</li>
<li>输出顶点色，并设置gamma（1-线性空间）</li>
</ul>
</li>
<li>flowmap_guide<ul>
<li>输入flowmap field(flowmap向量场)和曲线</li>
<li>利用曲线修改向量场</li>
</ul>
</li>
<li>flowma_obstacle<ul>
<li>输入模型和向量场</li>
<li>以模型和flowmap绘制平面进行检测，模型作为障碍，阻挡flow</li>
</ul>
</li>
</ul>
<h4 id="Flowmap的烘焙和相关设置"><a href="#Flowmap的烘焙和相关设置" class="headerlink" title="Flowmap的烘焙和相关设置"></a>Flowmap的烘焙和相关设置</h4><ul>
<li><p>flowmap贴图设置：</p>
<ul>
<li>无压缩或高质量</li>
<li>确认色彩空间</li>
</ul>
</li>
<li><p>Houdini</p>
<ul>
<li>Labs Map Baker节点</li>
<li>导出时注意gamma矫正选项、uv匹配</li>
<li>用Labs UV transfer节点来匹配高模和低模的UV</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="实现流动效果"><a href="#实现流动效果" class="headerlink" title="实现流动效果"></a>实现流动效果</h4><p>我也是第一次听说flowmap这个概念，然后看看我的桌面壁纸发现：</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802184553447.png" alt="image-20220802184553447"></p>
<p>这不就是flowmap做的水流效果吗？也是非常有趣。</p>
<p>作业直接拿去年图形学作业用的水面贴图拿过来用了。flowmap是用Flowmap painter画的。</p>
<p>中间平滑插值的一步看到图像其实很想用三角函数来做，但实操发现影响好像不太大，并且这个计算比起教程里的消耗会更大一点，所以还是没什么必要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float flowLerp = (cos(2*UNITY_PI * _Time*0.1 * _TimeSpeed)+1)/2;//abs((0.5-phase0)/0.5);//</span><br></pre></td></tr></table></figure>

<p>中间过程中一直发现有锯齿，最后发现是纹理压缩的问题，默认是法线质量压缩，在一些边缘处就会出现奇怪的锯齿</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816163919751.png" alt="image-20220816163919751"></p>
<p>把压缩模式换成无压缩就好了（这也是为什么人家工具导出的就是png格式）。</p>
<p>感觉flowmap很适合放在球面上，加一点自发光和半透明，做成朝一个方向旋转的水元素效果。一时间想不起来这种效果的案例哪里有了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/Flowmap.gif" alt="Flowmap"></p>
<p>感觉可以再进一步做一个顶点噪声扰动也许效果更好</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zq4y157c9">https://www.bilibili.com/video/BV1Zq4y157c9</a> </p>
<p>【技术美术百人计划】图形 2.8 flowmap的实现——流动效果实现</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.8%20flowmap%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="cmfe1u6pg0025scuhfyvu6dpk" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>