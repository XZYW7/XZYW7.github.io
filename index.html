<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">XZYW7&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="XZYW7&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-TA/百人计划/图形3.7.2 command buffer及urp概述" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2025-09-10T13:18:14.028Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形3-7-2-command-buffer及urp概述"><a href="#图形3-7-2-command-buffer及urp概述" class="headerlink" title="图形3.7.2 command buffer及urp概述"></a>图形3.7.2 command buffer及urp概述</h1><h2 id="一、Command-Buffer"><a href="#一、Command-Buffer" class="headerlink" title="一、Command Buffer"></a>一、Command Buffer</h2><p>Command Buffer：用来存储渲染命令的缓冲区</p>
<ul>
<li>保存渲染命令列表<ul>
<li>如set render target, draw mesh等等，可以设置在摄像机渲染期间的不同时间点执行</li>
</ul>
</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212010010.png" alt="image-20221004212010010"></p>
<ul>
<li>如图使用Command Buffer获取渲染这三个物体之前的背景，输出到RT，渲染物体时采样RT进行处理，获得各种效果</li>
<li>也可以在选择物体时使用多pass进行外扩描边(ExcuteInEditorMode的HeaderAttribute)</li>
</ul>
<h4 id="从Opengl指令分析Command-Buffer原理"><a href="#从Opengl指令分析Command-Buffer原理" class="headerlink" title="从Opengl指令分析Command Buffer原理"></a>从Opengl指令分析Command Buffer原理</h4><p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212333393.png" alt="image-20221004212333393"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212443470.png" alt="image-20221004212443470"></p>
<p>Unity里FrameDebugger打开的一大堆指令，也是Command Buffer</p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212836046.png" alt="image-20221004212836046"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212938333.png" alt="image-20221004212938333"></p>
<h4 id="从自定义RenderPipeline分析（ScriptableRenderContext与Command-Buffer）"><a href="#从自定义RenderPipeline分析（ScriptableRenderContext与Command-Buffer）" class="headerlink" title="从自定义RenderPipeline分析（ScriptableRenderContext与Command Buffer）"></a>从自定义RenderPipeline分析（ScriptableRenderContext与Command Buffer）</h4><p>这一段也许可以自己去看看catlike coding的SRP部分</p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004215426213.png" alt="image-20221004215426213"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004215744770.png" alt="image-20221004215744770"></p>
<h2 id="二、Command-Buffer常用函数"><a href="#二、Command-Buffer常用函数" class="headerlink" title="二、Command Buffer常用函数"></a>二、Command Buffer常用函数</h2><p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004215945624.png" alt="image-20221004215945624"></p>
<ul>
<li>RenderTarget</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220319374.png" alt="image-20221004220319374"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220610753.png" alt="image-20221004220610753"></p>
<ul>
<li>RenderTexture<ul>
<li>申请临时的RT必须手动Release</li>
<li>Release与Destroy的区别<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41251356">https://zhuanlan.zhihu.com/p/41251356</a></li>
<li>Release释放显存不释放内存</li>
<li>Destroy会把Object销毁的同时连带显存释放掉，因此频繁使用Destroy会加重申请内存的负担</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220340735.png" alt="image-20221004220340735"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220434194.png" alt="image-20221004220434194"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220529916.png" alt="image-20221004220529916"></p>
<ul>
<li>DrawMesh</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004223532948.png" alt="image-20221004223532948"></p>
<h2 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h2><ul>
<li>URP</li>
<li>RenderFeature与Command Buffer原理分析</li>
<li>Volume组件</li>
</ul>
<h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><ul>
<li>Scene窗口CameraColorTexture丢失[MSAA导致的bug ResolveAA]</li>
<li>深度缓冲和模板缓冲[16bit和24&#x2F;32bit]</li>
<li>RT精度格式问题</li>
<li>加速优化</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004225932580.png" alt="image-20221004225932580"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="完成洛基中的传送门效果"><a href="#完成洛基中的传送门效果" class="headerlink" title="完成洛基中的传送门效果"></a>完成洛基中的传送门效果</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13F411e7Ai">https://www.bilibili.com/video/BV13F411e7Ai</a></p>
<p>【技术美术百人计划】图形 3.72 command buffer及urp概述</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/" data-id="cmfe1kyb1002nykuh2idvb77s" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/学习框架" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/" class="article-date">
  <time datetime="2025-09-10T13:18:14.028Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="TA学习体系框架"><a href="#TA学习体系框架" class="headerlink" title="TA学习体系框架"></a>TA学习体系框架</h3><ul>
<li><p>TA的职责</p>
<ul>
<li>为项目解决问题</li>
<li>（设计不就是解决问题吗，把设计思维运用在TA当中，我又感觉自己更适合TA了）</li>
<li>美术的问题，程序关于渲染、流程的问题<ul>
<li>节省项目成本</li>
<li>缩短项目周期</li>
<li>提升项目效果</li>
</ul>
</li>
</ul>
</li>
<li><p>TA的方向</p>
<ul>
<li>程序</li>
<li>美术</li>
<li>工具</li>
<li>渲染</li>
<li>流程</li>
<li>动作</li>
<li>。。。</li>
</ul>
</li>
</ul>
<h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul>
<li>核心是学习如何解决问题</li>
<li>区分解决问题的方法和手段</li>
<li>多精一专</li>
</ul>
<h4 id="学习框架"><a href="#学习框架" class="headerlink" title="学习框架"></a>学习框架</h4><img src="%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719231108190.png" alt="image-20220719231108190" style="zoom:50%;" />

<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719231205177.png" alt="image-20220719231205177"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719231518499.png" alt="image-20220719231518499"></p>
<p>大厂的要求</p>
<p>入门：会使用工具、可以完成指定功能</p>
<p>中级：可以对流程、工具，项目上的东西可以自己修改</p>
<p>高级：可以把做的东西推广到流程当中</p>
<h4 id="入门阶段"><a href="#入门阶段" class="headerlink" title="入门阶段"></a>入门阶段</h4><p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232105088.png" alt="image-20220719232105088"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232214079.png" alt="image-20220719232214079"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232319370.png" alt="image-20220719232319370"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232355422.png" alt="image-20220719232355422"></p>
<h4 id="进阶阶段"><a href="#进阶阶段" class="headerlink" title="进阶阶段"></a>进阶阶段</h4><p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232721031.png" alt="image-20220719232721031"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232836013.png" alt="image-20220719232836013"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719232937688.png" alt="image-20220719232937688"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233011772.png" alt="image-20220719233011772"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233059747.png" alt="image-20220719233059747"></p>
<h4 id="高级阶段"><a href="#高级阶段" class="headerlink" title="高级阶段"></a>高级阶段</h4><p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233201038.png" alt="image-20220719233201038"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233208430.png" alt="image-20220719233208430"></p>
<p><img src="/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/image-20220719233313853.png" alt="image-20220719233313853"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/" data-id="cmfe1kyb2002pykuh10h58b2k" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.4 延迟渲染管线介绍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.4%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2025-09-10T13:18:14.027Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-3-4-延迟渲染管线介绍"><a href="#图形-3-4-延迟渲染管线介绍" class="headerlink" title="图形 3.4  延迟渲染管线介绍"></a>图形 3.4  延迟渲染管线介绍</h1><h3 id="1-渲染路径"><a href="#1-渲染路径" class="headerlink" title="1.渲染路径"></a><strong>1.渲染路径</strong></h3><p>渲染路径（Rendering Path）：决定光照的实现方式。就是当前渲染目标使用光照的流程</p>
<h3 id="2-渲染方式"><a href="#2-渲染方式" class="headerlink" title="2.渲染方式"></a><strong>2.渲染方式</strong></h3><h4 id="2-1-前向渲染Forward-Rendering"><a href="#2-1-前向渲染Forward-Rendering" class="headerlink" title="2.1 前向渲染Forward Rendering"></a><strong>2.1 前向渲染Forward Rendering</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820011602900.png" alt="image-20220820011602900"></p>
<p>在渲染每一帧时，每个顶点、片元都要执行一次着色器代码。这时需要将所有的光照信息都传递到片元着色器中。虽然大部分情况下的光源都趋向于小型化，而其照亮的区域也不大，但即便是光源离这个像素所对应的世界空间中的位置很远，计算光照时还是会把所有光源考虑进去。复杂度是$O(mn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For each light:</span><br><span class="line">	For each object affected by the light:</span><br><span class="line">		framebuffer += object * light</span><br></pre></td></tr></table></figure>



<h4 id="2-2-延迟渲染Deferred-Rendering"><a href="#2-2-延迟渲染Deferred-Rendering" class="headerlink" title="2.2 延迟渲染Deferred Rendering"></a><strong>2.2 延迟渲染Deferred Rendering</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820012923949.png" alt="image-20220820012923949"></p>
<p>主要解决大量光照渲染的方案。先不要迭代三角形做光照计算，而是先找出能看到的所有像素，再去迭代光照。直接迭代三角形的话，由于大量三角形不可见，是浪费的。</p>
<p>如前向渲染下，近处光源和远处光源计算量相等。但延迟渲染下，近处的计算量会大于远处。因为远处的像素更少。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820012418691.png" alt="image-20220820012418691"></p>
<p>Gbuffer</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/v2-ad11e89e29c6ef9dc8e7c01a9203efa7_720w.jpg" alt="img"></p>
<p>流程：</p>
<p>分成两个pass</p>
<ul>
<li>几何处理pass<ul>
<li>首先将场景渲染一次，获取待渲染对象的各种几何信息，储存到G-buffer。并且开启深度测试，所以G-buffer只写入最近的片元的信息。</li>
</ul>
</li>
<li>光照处理pass<ul>
<li>遍历所有G-buffer的各种参数，执行光照计算。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For each object:</span><br><span class="line">	Render to multiple targets</span><br><span class="line">For each light:</span><br><span class="line">	Apply light as a <span class="number">2</span>D postprocess</span><br></pre></td></tr></table></figure>

<p>复杂度是$O(m+n)$ 。</p>
<h5 id="问题：如何渲染透明物体"><a href="#问题：如何渲染透明物体" class="headerlink" title="问题：如何渲染透明物体"></a><strong>问题：如何渲染透明物体</strong></h5><p>透明物体在前向渲染中，一般最后渲染，并且不写入深度。</p>
<p>所以在延迟渲染中，还是需要用前向渲染的方式，最后渲染透明物体</p>
<h4 id="2-3-不同渲染路径的优劣及特性"><a href="#2-3-不同渲染路径的优劣及特性" class="headerlink" title="2.3 不同渲染路径的优劣及特性"></a><strong>2.3 不同渲染路径的优劣及特性</strong></h4><h5 id="2-3-1-区别"><a href="#2-3-1-区别" class="headerlink" title="2.3.1 区别"></a><strong>2.3.1 区别</strong></h5><ul>
<li><p>后处理方式不同</p>
<ul>
<li>假设需要深度信息来进行后处理，前向渲染就需要单独渲染深度图</li>
</ul>
</li>
<li><p>着色计算不同</p>
<ul>
<li>延迟渲染只能计算一个光照模型，因为是统一在LightPass计算的</li>
</ul>
</li>
<li><p>抗锯齿方式不同</p>
</li>
</ul>
<h5 id="2-3-2-优劣"><a href="#2-3-2-优劣" class="headerlink" title="2.3.2 优劣"></a><strong>2.3.2 优劣</strong></h5><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>前向渲染</td>
<td>1. 支持半透明渲染</td>
<td>1. 光源数量对计算复杂度影响巨大</td>
</tr>
<tr>
<td></td>
<td>2. 支持使用多个光照pass</td>
<td>2. 访问深度等数据需要额外计算</td>
</tr>
<tr>
<td></td>
<td>3. 支持自定义光照计算方式</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>延迟渲染</td>
<td>1. 大量光照场景优势明显</td>
<td>1. 对MSAA支持不友好</td>
</tr>
<tr>
<td></td>
<td>2. 只渲染可见像素，节省计算量</td>
<td>2. 透明物体渲染存在问题</td>
</tr>
<tr>
<td></td>
<td>3. 对后处理支持良好</td>
<td>3. 占用大量的显存带宽</td>
</tr>
<tr>
<td></td>
<td>4. 用更少的shader</td>
<td></td>
</tr>
</tbody></table>
<h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a><strong>3.其他</strong></h4><h5 id="3-1-渲染路径的设置方式"><a href="#3-1-渲染路径的设置方式" class="headerlink" title="3.1 渲染路径的设置方式"></a><strong>3.1 渲染路径的设置方式</strong></h5><p>(2021.2版本以前，URP不支持延迟渲染)</p>
<ol>
<li>项目设置Tier Settings 的Rendering Path改为延迟渲染，并勾选Use Defaults</li>
<li>相机的Rendering Path使用延迟渲染</li>
</ol>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820014419975.png" alt="image-20220820014419975"></p>
<h5 id="3-2-移动端优化"><a href="#3-2-移动端优化" class="headerlink" title="3.2 移动端优化"></a><strong>3.2 移动端优化</strong></h5><ul>
<li>两个TBDR<ul>
<li>一个是SIGGRAPH2010提出，通过分块来降低带宽内存用量</li>
<li>一个是PowerVR基于手机GPU的TBR架构提出的，通过HSR减少overdraw</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820014624273.png" alt="image-20220820014624273"></p>
<h5 id="3-3-其他渲染路径"><a href="#3-3-其他渲染路径" class="headerlink" title="3.3 其他渲染路径"></a><strong>3.3 其他渲染路径</strong></h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54694743">https://zhuanlan.zhihu.com/p/54694743</a></p>
<ul>
<li>延迟光照 Light Pre-Pass&#x2F;Deferred Lighting<ul>
<li>减少G-buffer占用的过多开销，支持多种光照模型</li>
</ul>
</li>
<li>Forward+ 即Tiled Forward Rendering，分块正向渲染<ul>
<li>减少带宽，支持多光源，强制需要一个preZ</li>
</ul>
</li>
<li>群组渲染Clustered Rendering<ul>
<li>带宽相对减少，多光源下效率提升</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li>总结延迟渲染管线的优缺点<ul>
<li>文内</li>
</ul>
</li>
<li>如何优化（移动端优化技术）<ul>
<li>3.7见</li>
</ul>
</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1244y1i7oV">https://www.bilibili.com/video/BV1244y1i7oV</a></p>
<p>【技术美术百人计划】图形 3.4  延迟渲染管线介绍</p>
<p>[2] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/08%20Deferred%20Shading/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/08%20Deferred%20Shading/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.4%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/" data-id="cmfe1kyb0002fykuhbxwv9idk" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.5 Early-z和Z-prepass" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.5%20Early-z%E5%92%8CZ-prepass/" class="article-date">
  <time datetime="2025-09-10T13:18:14.027Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-3-5-Early-z和Z-prepass-preZ"><a href="#图形-3-5-Early-z和Z-prepass-preZ" class="headerlink" title="图形 3.5 Early-z和Z-prepass(preZ)"></a>图形 3.5 Early-z和Z-prepass(preZ)</h1><h3 id="一、深度测试"><a href="#一、深度测试" class="headerlink" title="一、深度测试"></a><strong>一、深度测试</strong></h3><ul>
<li><p>fs-Alpha Test-Stencil Test-&#x3D;&#x3D;Depth Test&#x3D;&#x3D;</p>
</li>
<li><p>解决物体可见遮挡性的问题</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822155007188.png" alt="image-20220822155007188" style="zoom:50%;" />

<p>因为测试阶段发生在fs之后，片元即便被丢弃，已经经过了fs中大量的无用的计算。</p>
<h3 id="二、提前深度测试Early-Z"><a href="#二、提前深度测试Early-Z" class="headerlink" title="二、提前深度测试Early-Z"></a><strong>二、提前深度测试Early-Z</strong></h3><ul>
<li>解决过多不必要的片元计算问题</li>
<li>光栅化-&#x3D;&#x3D;EarlyZ&#x3D;&#x3D;-fs-Alpha Test-Stencil Test-&#x3D;&#x3D;Depth Test&#x3D;&#x3D;</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822155402937.png" alt="image-20220822155402937" style="zoom: 67%;" />

<ul>
<li>EarlyZ也可以基于模板测试在着色前丢弃片元</li>
<li><strong>EarlyZ剔除的最小单位不是1像素，而是像素块（2x2）</strong></li>
</ul>
<h4 id="2-1-EarlyZ失效"><a href="#2-1-EarlyZ失效" class="headerlink" title="2.1 EarlyZ失效"></a><strong>2.1 EarlyZ失效</strong></h4><p>通常在EarlyZ阶段不仅会进行深度测试，还会写入深度</p>
<ol>
<li>开启ALpha Test或Clip&#x2F;discard等手动丢弃片元操作<ul>
<li>如果手动丢弃片元，导致如果前面的片元丢弃了，深度仍然存在，后续的像素也会被丢弃。</li>
</ul>
</li>
<li>手动修改GPU插值得到的深度</li>
<li>开启Alpha Blend<ul>
<li>开启Alpha Blend的物体一般不会开启深度写入ZWrite off</li>
</ul>
</li>
<li>关闭深度测试Depth Test</li>
<li>开启Multi-Sampling：多重采样会影响周边像素，而EarlyZ无法得知周边像素是否被裁剪，无法提前剔除</li>
<li>以及其他任何导致需要混合后面颜色的操作</li>
</ol>
<p>此外，Early-Z技术会导致**深度数据冲突（depth data hazard）**的问题</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1617944-20190906001537033-642734220.png" alt="img" style="zoom:50%;" />

<p>避免深度数据冲突的方法之一是在写入深度值之前，再次与frame buffer的值进行对比：</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1617944-20190906001545523-562795391.png.png" alt="1617944-20190906001545523-562795391.png" style="zoom: 67%;" />

<h4 id="2-2-高效利用EarlyZ"><a href="#2-2-高效利用EarlyZ" class="headerlink" title="2.2 高效利用EarlyZ"></a><strong>2.2 高效利用EarlyZ</strong></h4><p>将不透明物体由近向远渲染，EarlyZ的优化效果最好</p>
<ul>
<li>CPU进行深度排序</li>
<li>场景复杂时，排序消耗增大。</li>
<li>严格按照从近到远渲染，不能同时搭配合批优化手段</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822155921813.png" alt="image-20220822155921813" style="zoom: 67%;" />



<h3 id="三、使用Z-Prepass"><a href="#三、使用Z-Prepass" class="headerlink" title="三、使用Z-Prepass"></a><strong>三、使用Z-Prepass</strong></h3><ol>
<li>在第一个pass即Z-Prepass中只写入深度，不计算输出任何颜色<ul>
<li>自动计算了最小深度的zbuffer，无需cpu排序</li>
<li>EarlyZ阶段也可以提升一点效率，虽然本来就没什么计算</li>
</ul>
</li>
<li>第二个pass关闭深度写入，并且将深度比较函数设置为相等</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Tags&#123;<span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span>&#125;</span><br><span class="line">    <span class="comment">//PreZ</span></span><br><span class="line">    Pass &#123;</span><br><span class="line">        ZWrite On 	<span class="comment">// 开启深度写入</span></span><br><span class="line">        ColorMask <span class="number">0</span> <span class="comment">// 关闭颜色输出</span></span><br><span class="line">        CGROGRAM</span><br><span class="line">        ...<span class="comment">//省略顶点变换部分</span></span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常地计算输出颜色</span></span><br><span class="line">    Pass &#123;</span><br><span class="line">        ZWrite Off	<span class="comment">// 关闭深度写入</span></span><br><span class="line">        ZTest Equal <span class="comment">// 深度相等通过</span></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        ...</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、Z-Prepass带来的问题"><a href="#四、Z-Prepass带来的问题" class="headerlink" title="四、Z-Prepass带来的问题"></a><strong>四、Z-Prepass带来的问题</strong></h3><h4 id="4-1-动态批处理问题"><a href="#4-1-动态批处理问题" class="headerlink" title="4.1 动态批处理问题"></a><strong>4.1 动态批处理问题</strong></h4><p>多pass的shader无法进行动态批处理-增加drawcall</p>
<h5 id="解决方法：提前分离的PrePass"><a href="#解决方法：提前分离的PrePass" class="headerlink" title="解决方法：提前分离的PrePass"></a>解决方法：提前分离的PrePass</h5><p>仍然使用两个pass</p>
<ol>
<li>将原先第一个pass（Z-Prepass）单独分离出来为单独一个shader，并使用这个shader将整个场景的Opaque物体渲染一遍（写入深度）</li>
<li>原先材质只剩下原先的第二个Pass，仍关闭深度写入，并且深度比较函数设置为相等</li>
</ol>
<p>两个pass都能够分别被批处理</p>
<h4 id="4-2-Z-Prepass解决透明渲染"><a href="#4-2-Z-Prepass解决透明渲染" class="headerlink" title="4.2 Z-Prepass解决透明渲染"></a><strong>4.2 Z-Prepass解决透明渲染</strong></h4><p>不写入深度的透明渲染会出现深度穿插错误的问题</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161301143(1).png" alt="image-20220822161301143(1)"></p>
<p>（无法看到透明物体的背面）</p>
<ul>
<li>如果要用Z-Prepass同时渲染物体背面<ul>
<li>需要先渲染背面，剔除正面</li>
<li>在下一个pass渲染正面，剔除背面</li>
<li>可用于头发渲染</li>
</ul>
</li>
</ul>
<h4 id="4-3-其他问题"><a href="#4-3-其他问题" class="headerlink" title="4.3 其他问题"></a><strong>4.3 其他问题</strong></h4><h5 id="计算消耗"><a href="#计算消耗" class="headerlink" title="计算消耗"></a>计算消耗</h5><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161643680.png" alt="image-20220822161643680"></p>
<p>权衡片元计算复杂性&#x2F;overdraw与Z-Prepass的消耗，根据实际情况采用</p>
<h3 id="五、Early-Z与Z-Prepass的实例应用"><a href="#五、Early-Z与Z-Prepass的实例应用" class="headerlink" title="五、Early-Z与Z-Prepass的实例应用"></a><strong>五、Early-Z与Z-Prepass的实例应用</strong></h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jaffhan/p/7382106.html">https://www.cnblogs.com/jaffhan/p/7382106.html</a></p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161834083.png" alt="image-20220822161834083" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161855886.png" alt="image-20220822161855886" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822162042913.png" style="zoom:67%;" />

<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><ol>
<li><strong>做下preZ的效果测试</strong></li>
</ol>
<p>左边的狮子是preZ，右边的狮子是普通的Alpha。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823202352241.png" alt="image-20220823202352241" style="zoom:80%;" />

<p>因为是透明渲染，所以自然而然会想到preZ的方法能否应用到之前深度测试的透视效果。</p>
<p>因为preZ记录了最前面的一个深度。透视，也就是说透明物体前面被遮挡住了，并且已经绘制了这个遮挡物体，那么就是遮挡物体的深度写入了深度缓冲。我们也就没有了被遮挡物体最近面的深度了。而之后要绘制出来，也要用Greater的判定方式，最终透明物体无法表现出自遮挡。</p>
<p>并且如果没有遮挡物的时候，物体自身最近片元就写入了深度。那么物体自己对自己形成遮挡，最后会发生没有遮挡时，绘制出了物体自身重叠部分。这种没有对透视效果做特殊处理，所以最后一次绘制物体自身的时候会覆盖（这是深度缓冲依然是物体自身最近距离，测试规则为LEqual）但是如果透视部分有特殊效果，那么正常的物体渲染可能会漏出这一部分。</p>
<p>总之结论就是，这个效果同一物体多pass的实现方法，无法用preZ来完成。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823203258886(1).png" alt="image-20220823203258886(1)"></p>
<ol start="2">
<li><strong>总结earlyZ的限制</strong></li>
</ol>
<ul>
<li><p>EarlyZ-失效</p>
<ul>
<li>开启ALpha Test或Clip&#x2F;discard等手动丢弃片元操作<ul>
<li>如果手动丢弃片元，导致如果前面的片元丢弃了，深度仍然存在，后续的像素也会被丢弃。</li>
</ul>
</li>
<li>手动修改GPU插值得到的深度</li>
<li>开启Alpha Blend<ul>
<li>开启Alpha Blend的物体一般不会开启深度写入ZWrite off</li>
</ul>
</li>
<li>关闭深度测试Depth Test</li>
<li>开启Multi-Sampling：多重采样会影响周边像素，而EarlyZ无法得知周边像素是否被裁剪，无法提前剔除</li>
<li>以及其他任何导致需要混合后面颜色的操作</li>
</ul>
</li>
<li><p>导致深度数据冲突</p>
</li>
<li><p>为了最大利用EarlyZ按照从近到远顺序渲染，但CPU阶段排序耗时，且严格按照从近到远渲染不能同时搭配合批优化手段</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FK4y1u7iw">https://www.bilibili.com/video/BV1FK4y1u7iw</a></p>
<p>【技术美术百人计划】图形 3.5 Early-z和Z-prepass</p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aM4y1g75f">https://www.bilibili.com/video/BV1aM4y1g75f</a></p>
<p>【技术美术百人计划】图形 2.7.2 GPU硬件架构概述</p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/timlly/p/11471507.html">https://www.cnblogs.com/timlly/p/11471507.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.5%20Early-z%E5%92%8CZ-prepass/" data-id="cmfe1kyb0002hykuh0q150p3o" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.6 纹理压缩" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.6%20%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9/" class="article-date">
  <time datetime="2025-09-10T13:18:14.027Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形3-6-纹理压缩"><a href="#图形3-6-纹理压缩" class="headerlink" title="图形3.6 纹理压缩"></a>图形3.6 纹理压缩</h1><h3 id="1-什么是纹理压缩"><a href="#1-什么是纹理压缩" class="headerlink" title="1. 什么是纹理压缩"></a><strong>1. 什么是纹理压缩</strong></h3><p>纹理压缩：是为了解决<strong>内存、带宽</strong>问题，专为在计算机图形渲染系统中存储纹理而使用的图像压缩技术。</p>
<h4 id="1-1-图片与纹理"><a href="#1-1-图片与纹理" class="headerlink" title="1.1 图片与纹理"></a><strong>1.1 图片与纹理</strong></h4><ul>
<li>图片格式<ul>
<li>图片格式是图片文件的存储格式，通常在磁盘、内存中储存和传输文件时使用。</li>
<li>例如：jpg、png、gif、bmp等</li>
</ul>
</li>
<li>纹理格式<ul>
<li>纹理格式是显卡能够直接进行采样的纹理数据格式，通常在向显卡中加载纹理时使用。</li>
</ul>
</li>
<li>纹理管线<ul>
<li>纹理压缩格式基于块压缩，能够更快读取像素所需字节块进行解压所以支持随机访问。</li>
<li>图片压缩格式基于整张图片进行压缩，无法直接实现单个像素的解析。</li>
<li>图片压缩格式无法被GPU识别，还需要经CPU解压缩成非压缩纹理格式才能被识别。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824164504787.png" alt="image-20220824164504787"></p>
<h3 id="2-常见纹理压缩格式"><a href="#2-常见纹理压缩格式" class="headerlink" title="2. 常见纹理压缩格式"></a><strong>2. 常见纹理压缩格式</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824164711622.png" alt="image-20220824164711622"></p>
<h4 id="2-1-非压缩格式"><a href="#2-1-非压缩格式" class="headerlink" title="2.1 非压缩格式"></a><strong>2.1 非压缩格式</strong></h4><table>
<thead>
<tr>
<th align="center">非压缩格式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">RGBA8888(RGBA32)</td>
<td>一个像素32位，包含A通道（一个像素消耗4字节）</td>
</tr>
<tr>
<td align="center">RGBA4444(RGBA16)</td>
<td>一个像素16位，包含A通道（一个像素消耗2字节）</td>
</tr>
<tr>
<td align="center">RGB888(RGB24)</td>
<td>一个像素24位，无A通道（一个像素消耗3字节）</td>
</tr>
<tr>
<td align="center">RGB565(RGB16)</td>
<td>一个像素16位，无A通道（一个像素消耗2字节）</td>
</tr>
</tbody></table>
<h4 id="2-2-压缩格式"><a href="#2-2-压缩格式" class="headerlink" title="2.2 压缩格式"></a><strong>2.2 压缩格式</strong></h4><h5 id="DXTC"><a href="#DXTC" class="headerlink" title="DXTC"></a><strong>DXTC</strong></h5><p>DXTC纹理压缩格式来源于S3公司提出的S3TC算法，基本思想是把4x4的像素块压缩成一个64或128位的数据块，优点是创建了一个固定大小且独立的编码片段，没有共享查找表或其他依赖关系，简化了解码过程。</p>
<ul>
<li><p>DXT1(BC1)</p>
<ul>
<li>每个块有2个16位RGB颜色值（RGB565），代表了此4x4像素块中颜色极端值，然后通过线性插值计算出两个中间颜色值，16个2位索引值则表示了每一个像素的颜色值索引；</li>
<li>(索引2个极端颜色+2个计算中间颜色)</li>
<li>适用于不具有透明度信息的贴图（或一位（0、1）透明信息-完全不透明或完全透明）<ul>
<li>有透明信息时，只计算一个中间颜色值，剩下的一个索引表示透明信息</li>
</ul>
</li>
<li>参照RGB24的压缩率-64&#x2F;(24*16) &#x3D;1&#x2F;6 </li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824165255015.png" alt="image-20220824165255015"></li>
</ul>
</li>
<li><p>DXT2&#x2F;3(BC2)</p>
<ul>
<li>DXT2&#x2F;3与DXT1类似，表示颜色信息的64位数据块不变，另外附加了64位数据来表示每个像素的Alpha信息，整个数据块变为128位</li>
<li>每个像素占用8位，0-3表示透明信息，4-7表示颜色信息</li>
<li>压缩率（RGBA32）：128&#x2F;(32*16) &#x3D; 1&#x2F;4</li>
</ul>
</li>
<li><p>DXT4&#x2F;5(BC3)</p>
<ul>
<li>DXT4&#x2F;5与DXT2&#x2F;3的差异在于其Alpha信息使用了线性插值，表示颜色信息的64位数据块依然不变，Alpha信息则由2个8位Alpha极端值和16个3位索引值组成。</li>
<li>压缩率（RGBA32）：128&#x2F;(32*16) &#x3D; 1&#x2F;4</li>
</ul>
</li>
<li><p>在Unity内贴图类型选为法线后会采用DXTnm压缩格式（居于DXT5），该格式会把法线贴图R通道存入A通道，然后RB通道清除为1，这样可以将法线XY信息分别存入到RGB&#x2F;A中分别进行压缩，以获得更高的精度，然后再根据XY构建出Z通道数据。</p>
</li>
</ul>
<h5 id="ATI1-2"><a href="#ATI1-2" class="headerlink" title="ATI1&#x2F;2"></a><strong>ATI1&#x2F;2</strong></h5><ul>
<li><p>ATI1</p>
<ul>
<li>为ATI公司开发的纹理压缩格式，也被称为BC4，其每个数据块存储单个颜色的数据通道，以与DXT5中的Alpha数据相同的方式进行编码，常用于存储高度图，光滑度贴图，效果与原始图像基本无差异；</li>
<li>压缩率（R8）：64&#x2F;(8*16)&#x3D;1&#x2F;2</li>
</ul>
</li>
<li><p>ATI2</p>
<ul>
<li>也被称为BC5，每个块中存储两个颜色通道的数据，同上以与DX5中Alpha数据相同的方式进行编码，相当于存储了两个BC4块。</li>
<li>压缩率（RG16）：128&#x2F;(8*16)&#x3D;1&#x2F;2</li>
</ul>
</li>
<li><p>如果是在将法线存储在XY双通道中采用BC5格式压缩，由于每个通道都有自己的索引，因此法线贴图XY信息可以比在BC1中保留更多的保真度，缺点是需要使用两倍内存，也需要更多带宽才能将纹理传递到着色器中；</p>
</li>
</ul>
<h5 id="BC6-7"><a href="#BC6-7" class="headerlink" title="BC6&#x2F;7"></a><strong>BC6&#x2F;7</strong></h5><p>仅在D3D11级图形硬件中受支持，他们每个块占用16字节，BC7针对8为RGB或RGBA数据，BC6针对RGB半精度浮点数据，因此BC6是唯一一个可以原生存储HDR的BC格式</p>
<ul>
<li>BC6是专门针对HDR图像设计的压缩算法，压缩比为1&#x2F;6</li>
<li>BC7是专门针对LDR图像设计的压缩算法，压缩比为1&#x2F;3<ul>
<li>该格式用于高质量的RGBA压缩，可以显著减少由于压缩法线带来的错误效果</li>
</ul>
</li>
</ul>
<h5 id="ETC"><a href="#ETC" class="headerlink" title="ETC"></a><strong>ETC</strong></h5><p>DirectX选择了DXTC作为标准压缩格式，对于Opengl则选择了爱立信研发的ETC格式，几乎所有安卓设备都可以支持ETC压缩，所以其在移动平台上被广泛使用。</p>
<p>ETC与DXTC具有相同的特点，将4x4的像素单元压缩成64位数据块，并将像素单元水平或竖直朝向分为两个区块，每个像素颜色等于基础颜色加上索引指向的亮度范围。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824183152849.png" alt="image-20220824183152849"></p>
<ul>
<li><p>ETC1</p>
<ul>
<li>每个数据块分区中的4位亮度索引信息会从16个内置亮度表中获取当前像素单元对应的亮度表，每个像素的2位像素索引值可以从亮度表的四个值中选取对应的亮度补充值</li>
<li>压缩率（RGB24）：64&#x2F;(16*24)&#x3D;1&#x2F;6</li>
</ul>
</li>
<li><p>ETC2</p>
<ul>
<li>ETC1的扩展，支持了Alpha通道的压缩，硬件要求Opengl ES3.0和Opengl4.3以上</li>
</ul>
</li>
<li><p>差别</p>
<ul>
<li>ETC1要求长宽为2的幂次的贴图，适用于所有安卓设备，压缩率比较高，但不适合带Alpha通道的贴图</li>
<li>ETC2要求长宽能被4整除的贴图，设备有硬件要求，支持Alpha通道压缩，内存占用大于ETC1</li>
</ul>
</li>
</ul>
<h5 id="ASTC"><a href="#ASTC" class="headerlink" title="ASTC"></a><strong>ASTC</strong></h5><p>ASTC是ARM和AMD联合开发的纹理压缩格式，各项指标都不错，</p>
<ul>
<li>优点<ul>
<li>可根据不同图片选择不同压缩率的算法</li>
<li>图片不需要为2的幂次</li>
<li>同时支持LDR和HDR</li>
</ul>
</li>
<li>缺点<ul>
<li>兼容性不够完善</li>
<li>解码时间较长</li>
</ul>
</li>
</ul>
<p>ASTC也是基于块的压缩算法，与BC7类似，数据块大小固定为128位，不同的是块中像素数量可变，从4x4到12x12像素都有。</p>
<p>每个数据块中存储了两个插值端点，但不一定存储的是颜色信息，也可能是Layer信息，这样可以用来对Normal或Alpha进行更好的压缩</p>
<p>对于块中每个像素，存储对应插值端点的权重，存储的权重数量可以少于纹素数量，可通过插值得到每一个纹素的权重值，然后再进行颜色的计算。</p>
<ul>
<li>数据块构成<ul>
<li>11位：权重、高度信息、特殊块标识</li>
<li>2位：Part数量</li>
<li>4位：16种插值端点模式（如LDR&#x2F;HDR，RGB&#x2F;RGBA）</li>
<li>111位：插值端点信息，纹素权重值，配置信息</li>
</ul>
</li>
</ul>
<h5 id="PVRTC"><a href="#PVRTC" class="headerlink" title="PVRTC"></a><strong>PVRTC</strong></h5><p>由Imagination公司专为PowerVR显卡设计，仅支持Iphone，Ipad和部分安卓机。</p>
<p>不同于DXTC和ETC这类基于块的算法，PVRTC将图像分为了低频和高频信号，低频信号由两张低分辨率图像AB组成，高频信号则是低精度的调制图像，记录了每个像素混合的权重，解码时AB图像经过双线性插值放大，然后根据调制图像的权重进行混合</p>
<ul>
<li>PVRTC<ul>
<li>PVRTC 2-bpp(bit per pixel)</li>
<li>PVRTC 4-bpp把一个4x4的像素单元压缩成一个64位数据块，每一个块中存储一个32位（每个像素2位）的调制数据，一个1位的调制标识，15位(RGB555&#x2F;RGBA4443)的颜色A，1位颜色A不透明标识（决定按照RGB还是RGBA进行存储），14位(RGB554&#x2F;RGBA4433)颜色B，1位颜色B不透明标识</li>
<li>压缩率（RGB）：64&#x2F;(24*16) &#x3D; 1&#x2F;6</li>
<li>压缩率（RGBA）：64&#x2F;(32*16) &#x3D; 1&#x2F;8</li>
</ul>
</li>
</ul>
<h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a><strong>2.3 总结</strong></h4><ul>
<li>画质比较<ul>
<li>RGBA&gt;ASTC 4x4&gt;ASTC6x6&gt;ETC2 ≈ETC1</li>
</ul>
</li>
<li>压缩比</li>
</ul>
<table>
<thead>
<tr>
<th align="center">压缩格式</th>
<th align="center">压缩率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DXT1</td>
<td align="center">1&#x2F;6</td>
</tr>
<tr>
<td align="center">DXT2&#x2F;3</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">DXT4&#x2F;5</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">ATI1</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">ATI2</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">BC6</td>
<td align="center">1&#x2F;6</td>
</tr>
<tr>
<td align="center">BC7</td>
<td align="center">1&#x2F;3</td>
</tr>
<tr>
<td align="center">ASTC</td>
<td align="center">1&#x2F;4~1&#x2F;35.95</td>
</tr>
<tr>
<td align="center">PVRTC</td>
<td align="center">1&#x2F;6</td>
</tr>
</tbody></table>
<h3 id="3-实际应用中的选择"><a href="#3-实际应用中的选择" class="headerlink" title="3. 实际应用中的选择"></a><strong>3. 实际应用中的选择</strong></h3><ul>
<li>PC<ul>
<li>低质量使用DXT1，不支持A通道，使用DXT5格式支持A通道</li>
<li>高质量使用BC7，支持A通道</li>
</ul>
</li>
<li>安卓<ul>
<li>低质量使用ETC1，不支持A通道</li>
<li>低质量使用ETC2，支持A通道（Opengl ES3.0&#x2F;Opengl 4.3以上版本）</li>
<li>高质量使用ASTC（Android5.0&#x2F;Opengl ES3.1以上版本）</li>
</ul>
</li>
<li>IOS<ul>
<li>高质量使用ASTC（Iphone6以上版本）</li>
<li>低质量使用PVRTC2（支持Iphone6以下版本）</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>结合今天课程，针对ASTC与ETC2这两个格式进行打包测试，分析内存占用占比。</p>
<p>3.7的作业正好也差不多。。。放个链接</p>
<p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/Lyp-tjMR_/#%E4%BD%9C%E4%B8%9A">https://xzyw7.github.io/post/Lyp-tjMR_/#%E4%BD%9C%E4%B8%9A</a></p>
<p>(ASTC6x6&amp;ETC2)最后包体的体积是非常接近的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824023612935.png" alt="image-20220824023612935"></p>
<p>ASCT</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024417255.png" alt="image-20220824024417255"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024516591.png" alt="image-20220824024516591"></p>
<p>ETC2</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024425619.png" alt="image-20220824024425619"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024506074.png" alt="image-20220824024506074"></p>
<p>就包体而言ASCT6x6是更大一些的，但是最后的内存占用却小了一些。</p>
<p>（帧率的差别应该主要来源于CPU的性能差别，ASTC的CPU性能占用稍高，也就是解码的消耗）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824025009019.png" alt="image-20220824025009019"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824025016354.png" alt="image-20220824025016354"></p>
<p>再用单张贴图的压缩结果来看看各种压缩格式的效果（ASTC压缩实在是有点猛，相比也会占用更多CPU时间）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021751226.png" alt="image-20220824021751226"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021823244.png" alt="image-20220824021823244"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021805123.png" alt="image-20220824021805123"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021840952.png" alt="image-20220824021840952"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021857439.png" alt="image-20220824021857439"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Av411K7bt">https://www.bilibili.com/video/BV1Av411K7bt</a></p>
<p>【技术美术百人计划】图形 3.6 纹理压缩——包体瘦身术</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.6%20%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9/" data-id="cmfe1kyb1002jykuhblvv1ldw" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.7 移动端TB(D)R架构基础" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7%20%E7%A7%BB%E5%8A%A8%E7%AB%AFTB(D)R%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2025-09-10T13:18:14.027Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形-3-7-移动端TB-D-R架构基础"><a href="#图形-3-7-移动端TB-D-R架构基础" class="headerlink" title="图形 3.7 移动端TB(D)R架构基础"></a>图形 3.7 移动端TB(D)R架构基础</h2><h3 id="一、当前移动端GPU概况"><a href="#一、当前移动端GPU概况" class="headerlink" title="一、当前移动端GPU概况"></a><strong>一、当前移动端GPU概况</strong></h3><h4 id="1-1-移动端和桌面端功耗对比"><a href="#1-1-移动端和桌面端功耗对比" class="headerlink" title="1.1 移动端和桌面端功耗对比"></a><strong>1.1 移动端和桌面端功耗对比</strong></h4><p>对于移动端我们通常用soc芯片名称来代指CPU</p>
<p>移动端GPU生产厂商主要是高通adreno，Mali和PowerVR</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822235329719.png" alt="image-20220822235329719"></p>
<h4 id="1-2-移动端和桌面端带宽对比"><a href="#1-2-移动端和桌面端带宽对比" class="headerlink" title="1.2 移动端和桌面端带宽对比"></a><strong>1.2 移动端和桌面端带宽对比</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822235406315.png" alt="image-20220822235406315"></p>
<h3 id="二、名词解释"><a href="#二、名词解释" class="headerlink" title="二、名词解释"></a><strong>二、名词解释</strong></h3><ul>
<li>System on Chip（Soc）<ul>
<li>Soc是把CPU、GPU、内存、通信基带、GPS模块等等整合在一起的芯片的称呼。常见的有A系Soc（苹果），骁龙Soc（高通），麒麟Soc（华为），联发科Soc，猎户座Soc（三星），2020年苹果推出M系Soc，暂用于Mac，这说明手机、笔记本、PC的通用芯片已经出现了。</li>
</ul>
</li>
<li>System Memory<ul>
<li>Soc中GPU和CPU共用一块片内LPDDR物理内存，就是常说的手机内存，也叫System Memory，大概几个G。</li>
<li>此外CPU和GPU还分别有自己的高速SRAM的Cache，也叫On-chip Memory，一般几百k-几M。不同距离的内存访问存在不同时间消耗，距离越近消耗越低，读取System Memory的时间消耗大概是On-chip Memory的几倍到几十倍</li>
<li>（soc上gpu和cpu共享一个（虚拟）内存地址空间）</li>
</ul>
</li>
<li>On-Chip Memory<ul>
<li>在TB(D)R架构下会存储Tile的颜色、深度和模板缓冲，读写修改都非常快。</li>
</ul>
</li>
<li>Stall停滞<ul>
<li>当一个GPU核心的两次计算结果之间有依赖关系而必须串行时，等待的过程便是Stall。</li>
</ul>
</li>
<li>FillRate<ul>
<li>像素填充率 &#x3D; ROP运行的时钟频率 * ROP的个数 * 每个时钟ROP可以处理的像素个数</li>
</ul>
</li>
<li>TB(D)R<ul>
<li>Tile-Based  (Deferred) Rendering</li>
<li>是目前主流的移动GPU渲染架构，对应一般PC上的GPU渲染架构则是IMR（Immediate Mode Rendering）</li>
<li>指屏幕被分块（16*16或32*32像素）渲染</li>
<li>TBR：VS - Defer - Rasterize - PS</li>
<li>TBDR：VS - Defer - Rasterize - Defer - PS</li>
<li>Defer字面是延迟，但从渲染数据的角度来看，Defer就是“阻塞+批处理”GPU的“一帧”的多个数据，然后一起处理</li>
</ul>
</li>
</ul>
<h3 id="三、立即渲染IMR"><a href="#三、立即渲染IMR" class="headerlink" title="三、立即渲染IMR"></a><strong>三、立即渲染IMR</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> draw <span class="keyword">in</span> renderPass:</span><br><span class="line">    <span class="keyword">for</span> primitive <span class="keyword">in</span> draw:</span><br><span class="line">        <span class="keyword">for</span> vertex <span class="keyword">in</span> primitive:</span><br><span class="line">            execute_vertex_shader(vertex)</span><br><span class="line">        <span class="keyword">if</span> primitive <span class="keyword">not</span> culled:</span><br><span class="line">            <span class="keyword">for</span> fragment <span class="keyword">in</span> primitive:</span><br><span class="line">                execute_fragment_shader(fragment)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823000924957.png" alt="image-20220823000924957"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001016993.png" alt="image-20220823001016993"></p>
<h3 id="四、基于块元的渲染TB-D-R"><a href="#四、基于块元的渲染TB-D-R" class="headerlink" title="四、基于块元的渲染TB(D)R"></a><strong>四、基于块元的渲染TB(D)R</strong></h3><p>TB(D)R宏观上分为2阶段</p>
<ol>
<li>第一阶段执行所有与几何相关的处理，并生成Primitive List，并且确定每个tile上面有哪些primitive</li>
<li>第二阶段将逐块执行光栅化及其后续处理，并在完成后将Frame Buffer从Tile Buffer写回到System Memory中。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pass one</span></span><br><span class="line"><span class="keyword">for</span> draw <span class="keyword">in</span> renderPass:</span><br><span class="line">    <span class="keyword">for</span> primitive <span class="keyword">in</span> draw:</span><br><span class="line">        <span class="keyword">for</span> vertex <span class="keyword">in</span> primitive:</span><br><span class="line">            execute_vertex_shader(vertex)</span><br><span class="line">        <span class="keyword">if</span> primitive <span class="keyword">not</span> culled:</span><br><span class="line">            append_tile_list(primitive)</span><br><span class="line"><span class="comment"># Pass two</span></span><br><span class="line"><span class="keyword">for</span> tile <span class="keyword">in</span> renderPass:</span><br><span class="line">    <span class="keyword">for</span> primitive <span class="keyword">in</span> tile:</span><br><span class="line">        <span class="keyword">for</span> fragment <span class="keyword">in</span> primitive:</span><br><span class="line">            execute_fragment_shader(fragment)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001450220.png" alt="image-20220823001450220"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001533374.png" alt="image-20220823001533374"></p>
<h3 id="五、TB-D-R的硬件渲染顺序"><a href="#五、TB-D-R的硬件渲染顺序" class="headerlink" title="五、TB(D)R的硬件渲染顺序"></a><strong>五、TB(D)R的硬件渲染顺序</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001818885.png" alt="image-20220823001818885"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>TBR的核心目的是降低带宽，减少功耗，但渲染帧率上并不比IMR块</strong></p>
<ul>
<li>优点<ul>
<li>TBR给消除Overdraw提供了机会，PowerVR用了HSR技术，Mali用了Forward Pixel Killing技术，目标一样，就是要最大限度减少被遮挡Pixel的texturing和shading。</li>
<li>TBR主要是cached friendly，在cache里读写的速度要比全局内存的速度快得多，以降低render rate的代价，降低带宽，省电</li>
</ul>
</li>
<li>缺点<ul>
<li>Binning过程是在vertex阶段之后，将输出的几何数据写入到DDR，然后才被fs读取。几何数据过多的管线，容易在此处有性能瓶颈。</li>
<li>如果某些三角形叠加在数个tile上，需要绘制数次。意味着总渲染时间将高于即时渲染模式。</li>
</ul>
</li>
</ul>
<h3 id="六、Binning过程"><a href="#六、Binning过程" class="headerlink" title="六、Binning过程"></a><strong>六、Binning过程</strong></h3><p>Binning过程（类似四叉树）&#x2F;第一个Defer</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823002346662.png" alt="image-20220823002346662"></p>
<p>确定哪些块元渲染哪些图元</p>
<h3 id="七、不同GPU的Early-Depth-Test"><a href="#七、不同GPU的Early-Depth-Test" class="headerlink" title="七、不同GPU的Early-Depth-Test"></a><strong>七、不同GPU的Early-Depth-Test</strong></h3><p>第二个Defer</p>
<ul>
<li><p>Android</p>
<ul>
<li>Qualcomm Adreno采用外置模块LRZ。在正常渲染管线前，多执行一次vs生成低精度depth texture，提前剔除不可见的triangles。直接用硬件做occlusion culling，功能类似软光栅遮挡剔除&#x2F;pre-Z</li>
<li>Arm Mali的FPK（Forward Pixel Killing）<ul>
<li>发生在Early-Z之后</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823002835382.png" alt="image-20220823002835382"></li>
</ul>
</li>
</ul>
</li>
<li><p>IOS</p>
<ul>
<li><p>PowerVR的HSR</p>
</li>
<li><p>TBDR的HSR实现</p>
<ul>
<li>HSR&#x3D;Hidden Surface Removal</li>
<li>对每个被投影光束交接的对象进行排序处理（使用分块减少数据集大小）</li>
<li>只有最近的不透明和最近的透明对象需要被渲染</li>
<li>余下的片元被剔除</li>
</ul>
</li>
<li><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823003102289.png" alt="image-20220823003102289"></p>
</li>
</ul>
</li>
</ul>
<h3 id="八、优化建议"><a href="#八、优化建议" class="headerlink" title="八、优化建议"></a><strong>八、优化建议</strong></h3><ul>
<li>不使用FrameBuffer的时候clear或者discard<ul>
<li>主要是清空积存在tile buffer上的中间数据，所以在unity里面对render texture的使用也特别说明了一下，当不再使用这个rt之前，调用一次Discard。在Opengl ES上善用glClear，glInvalidateFrameBuffer避免不必要的Resolve（Resolve就是tile buffer刷新到system memory）行为</li>
</ul>
</li>
<li>不要在一帧里面频繁切换FrameBuffer的绑定<ul>
<li>本质上就是减少tile buffer和system memory之间的stall操作</li>
</ul>
</li>
<li>对于移动平台，建议使用alpha blend而非alpha test<ul>
<li>在实际使用中，你应该分析并比较alpha test和alpha blend的表现，因为这取决于具体内容，通常在移动平台上应避免使用alpha混合来实现透明。需要进行alpha blend时，尝试缩小混合区域的覆盖范围。</li>
</ul>
</li>
<li>手机上必须要做Alpha Test，先做一遍preZ</li>
<li>图片尽量压缩，例如：ASTC，ETC2</li>
<li>图片尽量走mipmap</li>
<li>尽量使用从Vertex shader传来的Varying变量UV值采样贴图（连续的），不要在FragmentShader里动态计算贴图的UV值（非连续的），否则CacheMiss</li>
<li>在延迟渲染尽量利用Tile Buffer</li>
<li>如果你在unity里面调整ProjectSetting&#x2F;Quality&#x2F;Rendering&#x2F;Texture Quality不同的设置，或者不同分辨率下，帧率有很多变化，那么多半是带宽出问题。</li>
<li>MSAA在TBDR下反而是非常快速的。</li>
<li>少在fs中使用discard，调用gl_FragDepth从而打断Early-DT(HLSL中为Clip，GLSL中为discard)</li>
<li>在shader里面浮点数精度，有目的区分使用float，half；<ul>
<li>带宽用量减少</li>
<li>GPU中使用的周期数减少，因为着色器编译器可以优化你的代码以提高并行化程度。</li>
<li>要求的统一变量寄存器数量减少，这反过来又降低了寄存器数量溢出风险</li>
</ul>
</li>
<li>在移动端TB(D)R架构中，顶点处理部分容易成为瓶颈，避免使用曲面细分shader，置换贴图等负操作，提倡使用模型lod，本质上减少FrameData的压力，Unity中尽早在应用阶段借助umbra遮挡剔除。</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><p>结合今天的课程，将最近做的demo继续安卓平台<strong>打包</strong>，<strong>对比</strong>使用课上的优化点前后的性能变化。</p>
<p>这是第一次接触安卓平台的打包与性能分析。。关于性能分析使用了Unity的UPR工具。由于没有什么比较完整的demo，之前所有作业都是塞在一个项目里做的，就直接使用这个场景了，虽然感觉也很难触碰到性能瓶颈什么的。而且能够针对上面优化建议处理的点也不太多。于是选择了最直接的图片纹理压缩的部分（正好下一章节就会讲纹理压缩），应该也算非常适合了。</p>
<p>ASTC和ETC2两种压缩格式都非常接近</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824014740272.png" alt="image-20220824014740272"></p>
<p>而当我手动地取消所有纹理的压缩，改为8位浮点精度储存后，发现对性能的影响比想象中大得多。。。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824014834325.png" alt="image-20220824014834325"></p>
<p>首先是apk文件的大小就增大了一些。其次是最明显的纹理资源峰值这一项，UPR还贴心地提供了说明和优化建议。而且，这里Mipmap甚至已经关掉了。（其实这里做法是相反的，应该关闭压缩开启mip，这样这两个功能在纹理和渲染效率上的作用才是协同的）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824015319329.png" alt="image-20220824015319329"></p>
<p>那么在手机内存占用上，也发生了相应的变化</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020406052.png" alt="image-20220824020406052"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020414939.png" alt="image-20220824020414939"></p>
<ul>
<li><p>ReservedTotal峰值</p>
<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020439183.png" alt="image-20220824020439183"></li>
</ul>
</li>
<li><p>ReservedGFX峰值</p>
<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020513219.png" alt="image-20220824020513219"></li>
</ul>
</li>
</ul>
<p>其次就是帧率也发生了下降。这当然也是由于纹理资源数据变大，计算的速度也就下降了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824015213541.png" alt="image-20220824015213541"></p>
<p>性能分析工具本身还有很多需要去研究的地方，当然这也需要项目内容的支撑。。。鉴于现在也没有什么合适的内容，这里也只能到此为止了，算是一次小小的尝试。当打包出来的项目在手机上成功渲染出画面的时候，还是非常激动的。。。</p>
<p>（此外，曲面细分与几何着色器生成的草地没能在手机上绘制出来，想必也是手机平台不支持这两个着色器的缘故了。）</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Bb4y167zU">https://www.bilibili.com/video/BV1Bb4y167zU</a></p>
<p>【技术美术百人计划】图形 3.7 移动端TB(D)R架构基础</p>
<p>[2] <a target="_blank" rel="noopener" href="https://blog.imaginationtech.com/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/">https://blog.imaginationtech.com/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://upr.unity.cn/instructions/desktop">https://upr.unity.cn/instructions/desktop</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7%20%E7%A7%BB%E5%8A%A8%E7%AB%AFTB(D)R%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" data-id="cmfe1kyb1002lykuhbzz6dhsc" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.2 混合模式及剔除" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.2%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%89%94%E9%99%A4/" class="article-date">
  <time datetime="2025-09-10T13:18:14.026Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-3-2-混合模式及剔除"><a href="#图形-3-2-混合模式及剔除" class="headerlink" title="图形 3.2 混合模式及剔除"></a>图形 3.2 混合模式及剔除</h1><h3 id="一、什么是混合模式"><a href="#一、什么是混合模式" class="headerlink" title="一、什么是混合模式"></a>一、什么是混合模式</h3><ul>
<li>混合<ul>
<li>就是两种颜色混在一起。具体就是把某一像素位置原来的颜色和将要画上去的颜色，通过某种方式混在一起，从而实现新的效果</li>
</ul>
</li>
<li>透过红色玻璃看绿色玻璃<ul>
<li>可以先绘制绿色玻璃，再绘制红色玻璃。在绘制红色的时候，利用混合功能，把将要绘制上去的红色和原来的颜色（绿色）进行混合，于是得到新的颜色</li>
<li>也可以理解成，绿色首先对背景施加影响，无论红色玻璃存在与否，这个影响都是存在的，所以首先计算后面的绿色。然后再考虑前面的红色的影响。这也是我理解透明物体从后往前绘制的原理的一种方式。</li>
</ul>
</li>
</ul>
<p><strong>最终颜色&#x3D;Shader计算后的颜色值*源因子(SrcFactor)+累计颜色*目标因子(DstFactor)</strong></p>
<h3 id="二、混合模式的类型"><a href="#二、混合模式的类型" class="headerlink" title="二、混合模式的类型"></a>二、混合模式的类型</h3><p>PS中的混合模式</p>
<p><img src="/%E5%9B%BE%E5%BD%A23.2%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%89%94%E9%99%A4/image-20220817000953004.png" alt="image-20220817000953004"></p>
<h4 id="ShaderLab内的混合"><a href="#ShaderLab内的混合" class="headerlink" title="ShaderLab内的混合"></a>ShaderLab内的混合</h4><ol>
<li><p>如果颜色的某一分量超过1.0，则会被自动截取位1.0，不需要考虑越界的问题。</p>
</li>
<li><p>再所有着色器执行完毕，所有纹理都被应用，所有像素准备被呈现到屏幕之后，使用Blend命令来操作这些像素混合。</p>
</li>
<li><p>语法</p>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Blend Off</td>
<td>关闭blend混合（默认）</td>
</tr>
<tr>
<td align="left">Blend SrcFactor DstFactor</td>
<td>配置并启动混合计算</td>
</tr>
<tr>
<td align="left">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td>
<td>同上，但是使用不同的要素来混合Alpha通道</td>
</tr>
<tr>
<td align="left">BlendOp Value</td>
<td>如果使用BlendOp命令，则混合操作将设置为该值。否则，混合操作默认为Add。</td>
</tr>
<tr>
<td align="left">BlendOp OpColor, OpAlpha</td>
<td>同上，但是使用不同的操作来处理alpha通道</td>
</tr>
<tr>
<td align="left">AlphaToMaskOn</td>
<td>常用于开启MSAA的地表植被的渲染</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="Blend和BlendOp"><a href="#Blend和BlendOp" class="headerlink" title="Blend和BlendOp"></a>Blend和BlendOp</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">finalValue = sourceFactor * sourceValue operation destinationFactor * destinationValue</span><br><span class="line"><span class="comment">//finalValue: GPU写入目标缓冲区的值</span></span><br><span class="line"><span class="comment">//sourceFactor: Blend命令中定义</span></span><br><span class="line"><span class="comment">//sourceValue: 片元着色器输出的值</span></span><br><span class="line"><span class="comment">//operation: 混合操作</span></span><br><span class="line"><span class="comment">//destinationFactor: Blend命令中定义</span></span><br><span class="line"><span class="comment">//destinationValue: 目标缓冲区现有值的值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以写在Pass中或SubShader中(BlendOp在同一个代码块中还必须有一个Blend命令)</li>
<li>启用混合会禁用GPU上的一些优化（主要是隐藏表面去除Early-Z）</li>
</ul>
<h3 id="三、混合模式的实现方式"><a href="#三、混合模式的实现方式" class="headerlink" title="三、混合模式的实现方式"></a>三、混合模式的实现方式</h3><h4 id="Unity附带的Blend枚举"><a href="#Unity附带的Blend枚举" class="headerlink" title="Unity附带的Blend枚举"></a>Unity附带的Blend枚举</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//混合模式</span></span><br><span class="line">[Enum(UnityEngine.Rendering.BlendOp)] _BlendOp (&quot;BlendOp&quot;, <span class="type">float</span>) = <span class="number">0</span></span><br><span class="line">[Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (&quot;SrcBlend&quot;, <span class="type">float</span>) = <span class="number">1</span></span><br><span class="line">[Enum(UnityEngine.Rendering.BlendMode)]</span><br><span class="line">_DstBlend (&quot;DstBlend&quot;, <span class="type">float</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度开关</span></span><br><span class="line"><span class="comment">//ZWriteMode没有内置，只有两种状态，也可以用Toogle</span></span><br><span class="line">[Enum(Off, <span class="number">0</span>, On, <span class="number">1</span>)] _ZWriteMode (&quot;ZWriteMode&quot;, <span class="type">float</span>) = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">SubShader&#123;</span><br><span class="line">    Tag &#123;&quot;RenderType&quot; = &quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent&quot;&#125;</span><br><span class="line">    ZWrite [_ZWriteMode]</span><br><span class="line">    Blend [_SrcBlend] [_DstBlend]</span><br><span class="line">    <span class="comment">//这部分定义是CPU阶段的渲染设置，并不传入shader，不用定义uniform</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Photoshop的Blend实现方式"><a href="#Photoshop的Blend实现方式" class="headerlink" title="Photoshop的Blend实现方式"></a>Photoshop的Blend实现方式</h4><p>自己查吧</p>
<ul>
<li>普通的Blend<ul>
<li>Blend SrcAlpha OneMinusSrcAlpha<ul>
<li>&#x2F;&#x2F;Alpha混合 Alpha Blending</li>
</ul>
</li>
</ul>
</li>
<li>变暗Darken<ul>
<li>BlendOp Min</li>
<li>Blend One One</li>
<li>min(当前颜色，缓存颜色)*1</li>
</ul>
</li>
<li>正片叠底<ul>
<li>Blend Discolors Zero</li>
<li>当前颜色*缓存颜色+缓存颜色*0</li>
</ul>
</li>
<li>滤色Screen<ul>
<li>Blend OneMinusDstColor One 或Blend One OneMinusSrcColor</li>
<li>Src*(1-Dst)+Dst*1 &#x3D; Src+Dst-Src*Dst</li>
<li>当前颜色*(1-缓存颜色)+缓存颜色*1 或 当前颜色*1 + 缓存颜色* (1-缓存颜色)</li>
</ul>
</li>
<li>变亮Lighten<ul>
<li>BlendOp Max</li>
<li>Blend One One</li>
<li>max(当前颜色，缓存颜色)</li>
</ul>
</li>
<li>线性减淡LinearDodge<ul>
<li>Blend One One</li>
<li>缓存颜色*1+当前颜色*1</li>
</ul>
</li>
<li>颜色加深ColorBurn<ul>
<li>高级Opengl混合</li>
<li>此模式目前仅在具有GL_KHR_blend_equation_advanced或GL_NV_blend_equation_advanced扩展支持的Opengl硬件上可用</li>
<li>1-（1-Dst）&#x2F;Src</li>
</ul>
</li>
<li>。。。</li>
</ul>
<h3 id="四、剔除的实现方式"><a href="#四、剔除的实现方式" class="headerlink" title="四、剔除的实现方式"></a>四、剔除的实现方式</h3><ul>
<li>法线剔除<ul>
<li>也称背面消隐，根据法线朝向判断哪个面被剔除掉，可以用来控制是否双面渲染</li>
<li>Cull + [Off, Front, Back]</li>
</ul>
</li>
<li>面裁切<ul>
<li>Clip函数会参数小于某像素点直接在片元阶段丢弃，常用于制作溶解，裁剪等效果</li>
<li>Clip();&#x2F;&#x2F;默认会切掉0.5的部分，或者使用if</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(input.posInObjectCoords.y &gt; <span class="number">0.5</span>) <span class="keyword">discard</span>;</span><br><span class="line"><span class="comment">//剔除模式</span></span><br><span class="line">[Enum(UnityEngine.Rendering.CullMode)] _CullMode (&quot;CullMode&quot;, <span class="type">float</span>) = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>开启双面渲染相当于绘制了两次</li>
<li>Clip函数在某些PowerVR的机型上效率低</li>
<li>面裁切Clip使用AlphaTest队列</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>实现常用的混合模式，并设计使用界面</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sL4y1v7SS">https://www.bilibili.com/video/BV1sL4y1v7SS</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.2%20%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%89%94%E9%99%A4/" data-id="cmfe1kyaz0029ykuha73o7ec2" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.3 曲面细分与几何着色器" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.3%20%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/" class="article-date">
  <time datetime="2025-09-10T13:18:14.026Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-3-3-曲面细分与几何着色器"><a href="#图形-3-3-曲面细分与几何着色器" class="headerlink" title="图形 3.3  曲面细分与几何着色器"></a>图形 3.3  曲面细分与几何着色器</h1><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a><strong>一、背景</strong></h3><h4 id="1-1应用"><a href="#1-1应用" class="headerlink" title="1.1应用"></a><strong>1.1应用</strong></h4><ul>
<li>曲面细分着色器<ul>
<li>海浪（曲面细分+顶点位移动画）</li>
<li>（交互）雪地（曲面细分+顶点位移）</li>
<li>置换贴图（曲面细分+顶点位移）</li>
</ul>
</li>
<li>几何着色器<ul>
<li>几何动画（几何图元）</li>
<li>草地等（与曲面细分着色器结合）</li>
</ul>
</li>
</ul>
<h4 id="1-2渲染管线"><a href="#1-2渲染管线" class="headerlink" title="1.2渲染管线"></a><strong>1.2渲染管线</strong></h4><ul>
<li>顶点着色器</li>
<li>曲面细分着色器<ul>
<li>细分控制着色器Hull Shader（TCS）</li>
<li>Tessellation Primitive Generator（不可编程）</li>
<li>细分计算着色器Domain Shader（TES）</li>
</ul>
</li>
<li>几何着色器</li>
<li>片元着色器</li>
</ul>
<h4 id="1-3曲面细分着色器"><a href="#1-3曲面细分着色器" class="headerlink" title="1.3曲面细分着色器"></a><strong>1.3曲面细分着色器</strong></h4><h5 id="1-3-1TESS的输入与输出"><a href="#1-3-1TESS的输入与输出" class="headerlink" title="1.3.1TESS的输入与输出"></a><strong>1.3.1TESS的输入与输出</strong></h5><ul>
<li><p>Hull Stage</p>
<ul>
<li>Hull function<ul>
<li>每个patch每个顶点运行一次</li>
<li>输入<ul>
<li>Patch，可以看成是多个顶点的集合，包含每个顶点的属性，可以指定一个Patch包含的顶点数以及自己的属性</li>
<li>Index，指定hull shader输出patch中的哪一个顶点</li>
</ul>
</li>
<li>输出patch内对应顶点</li>
</ul>
</li>
<li>Patch Constant Function<ul>
<li>输入Patch</li>
<li>每个patch运行一次</li>
<li>输出Tessellation Factor</li>
</ul>
</li>
<li>两个阶段是并行</li>
<li>功能<ul>
<li>将图元细分（三角形、矩形等）</li>
</ul>
</li>
<li>输出<ul>
<li>细分后的顶点数据</li>
</ul>
</li>
</ul>
</li>
<li><p>Tessellation Primitive Generator</p>
<ul>
<li>为新网格的所有顶点生成重心坐标</li>
</ul>
</li>
<li><p>Domain stage</p>
<ul>
<li>输入重心坐标、Patch</li>
<li>为细分后曲面的所有顶点运行一次</li>
<li>通常在顶点着色器的逻辑操作的部分，应该放在这里</li>
</ul>
</li>
<li><p>（Geometry Stage）</p>
</li>
</ul>
<h5 id="1-3-2HULL-shader参数"><a href="#1-3-2HULL-shader参数" class="headerlink" title="1.3.2HULL shader参数"></a><strong>1.3.2HULL shader参数</strong></h5><ul>
<li>Tessellation Factor<ul>
<li>决定将一条边分成几部分</li>
<li>equal_Spacing</li>
<li>fractional_even_spacing</li>
<li>fractional_odd_spacing</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818002411909.png" alt="image-20220818002411909"></p>
<ul>
<li>Inner Tessellation Factor<ul>
<li>（与上面的参数是同一等级）将边等分后，向内延伸相交，直至内部没有交点。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818002434236.png" alt="image-20220818002434236"></p>
<h4 id="1-4几何着色器"><a href="#1-4几何着色器" class="headerlink" title="1.4几何着色器"></a><strong>1.4几何着色器</strong></h4><h5 id="1-4-1几何着色器的输入与输出"><a href="#1-4-1几何着色器的输入与输出" class="headerlink" title="1.4.1几何着色器的输入与输出"></a><strong>1.4.1几何着色器的输入与输出</strong></h5><ul>
<li>输入为图元（三角形、矩形、边）<ul>
<li>根据图元不同，shader中会出现对应不同数量的顶点</li>
</ul>
</li>
<li>输出同样为图元（一个或多个），需要自己从顶点构建，顺序很重要，同时定义最大输出的顶点数</li>
</ul>
<h3 id="二、曲面细分"><a href="#二、曲面细分" class="headerlink" title="二、曲面细分"></a><strong>二、曲面细分</strong></h3><ul>
<li>将一个Quad细分</li>
<li>与置换贴图结合<ul>
<li>注意使用置换贴图不在fs中，也是在domain shader中的vert函数进行的，GPU无法获取mipmap信息，需要使用tex2Dlod等来读取图片。</li>
<li>法线也需要重新计算</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> hull hullProgram</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> domain ds</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex tessvert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Tessellation.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">...    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexInput</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexOutput</span>&#123;</span><br><span class="line">    float4 vertex: SV_POSITION;</span><br><span class="line">    float3 normal;</span><br><span class="line">    float3 tangent;</span><br><span class="line">    float2 uv;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function">VertexOutput <span class="title">vert</span><span class="params">(VertexInput v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VertexOutput o;</span><br><span class="line">    o.uv = <span class="built_in">TRANSFORM_TEX</span>(v.uv,_MainTex);</span><br><span class="line">    o.vertex = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">    o.normal = v.normal;</span><br><span class="line">    o.tangent = v.tangent;</span><br><span class="line">&#125;<span class="comment">//顶点着色器的函数，但这里没有拿给顶点着色器，而是用来在DomainShader进行空间转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只有在能够使用曲面细分着色器的平台才能使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNITY_CAN_COMPIE_TESSELLATION</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TessVertex</span> &#123;</span><br><span class="line">	float4 vertex: INTERNALTESSPOS;</span><br><span class="line">    float3 normal: NORMAL;</span><br><span class="line">    float4 tangent: TANGENT;</span><br><span class="line">    float2 uv: TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OutputPatchConstant</span> &#123;<span class="comment">//不同的图元，该结构会有不同</span></span><br><span class="line">	<span class="type">float</span> edge[<span class="number">3</span>]: SV_TESSFACTOR;</span><br><span class="line">    <span class="type">float</span> inside: SV_INSIDETESSFACTOR;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TessVertex <span class="title">tessvert</span><span class="params">(VertexInput v)</span></span>&#123;</span><br><span class="line">    TessVertex o;</span><br><span class="line">    o.vertex = v.vertex;</span><br><span class="line">    o.normal = v.normal;</span><br><span class="line">    o.tangent = v.tangent;</span><br><span class="line">    o.uv = v.uv;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="comment">//顶点着色器，注意这里没有进行空间转换，而是在domianshader里进行的空间转换 </span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> _TessellationUniform;</span><br><span class="line"><span class="function">OutputPatchConstant <span class="title">hsconst</span><span class="params">(InputPatch&lt;TessVertex, <span class="number">3</span>&gt; patch)</span> </span>&#123;</span><br><span class="line">    OutputPatchConstant o;</span><br><span class="line">    o.edge[<span class="number">0</span>] = _TessellationUniform;</span><br><span class="line">    o.edge[<span class="number">1</span>] = _TessellationUniform;</span><br><span class="line">    o.edge[<span class="number">2</span>] = _TessellationUniform;</span><br><span class="line">    o.inside = _TessellationUniform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Hull shader的函数</span></span><br><span class="line">[<span class="built_in">UNITY_domian</span>(<span class="string">&quot;tri&quot;</span>)]<span class="comment">//指定图元</span></span><br><span class="line">[<span class="built_in">UNITY_partitioning</span>(<span class="string">&quot;fractional_odd&quot;</span>)]<span class="comment">//拆分edge的方式，equal_spacing等</span></span><br><span class="line">[<span class="built_in">UNITY_outputtopology</span>(<span class="string">&quot;triangl_cw&quot;</span>)]</span><br><span class="line">[<span class="built_in">UNITY_patchconstantfunc</span>(<span class="string">&quot;hsconst&quot;</span>)]<span class="comment">//指定patch const function。一个patch一共有三个点，但是这三个点都共用这个函数</span></span><br><span class="line">[<span class="built_in">UNITY_outputcontrolpoints</span>(<span class="number">3</span>)]<span class="comment">//不同图元会对应不同控制点</span></span><br><span class="line"><span class="function">TessVertex <span class="title">hullProgram</span><span class="params">(InputPatch&lt;TessVertex, <span class="number">3</span>&gt; patch, uint id : SV_OutputControlPointID)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> patch[id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Domian shader的函数</span></span><br><span class="line">[<span class="built_in">UNITY_domain</span>(<span class="string">&quot;tri&quot;</span>)]<span class="comment">//同样指定图元</span></span><br><span class="line"><span class="function">VertexOutput <span class="title">ds</span> <span class="params">(OutputPatchConstant tessFactors, <span class="type">const</span> OutputPatch&lt;TessVertex, <span class="number">3</span>&gt; patch, float3 bary : SV_DomainLocation)</span> </span>&#123;</span><br><span class="line"><span class="comment">//bary重心坐标</span></span><br><span class="line"><span class="comment">//计算模型空间位置</span></span><br><span class="line">    VertexInput v;</span><br><span class="line">    v.vertex = patch[<span class="number">0</span>].vertex*bary.x + patch[<span class="number">1</span>].vertex*bary.y + patch[<span class="number">2</span>].vertex*bary.z;</span><br><span class="line">    v.tangent = patch[<span class="number">0</span>].tangent*bary.x + patch[<span class="number">1</span>].tangent*bary.y + patch[<span class="number">2</span>].tangent*bary.z;</span><br><span class="line">    v.normal = patch[<span class="number">0</span>].normal*bary.x + patch[<span class="number">1</span>].normal*bary.y + patch[<span class="number">2</span>].normal*bary.z;</span><br><span class="line">    v.uv = patch[<span class="number">0</span>].uv*bary.x + patch[<span class="number">1</span>].uv*bary.y + patch[<span class="number">2</span>].uv*bary.z;</span><br><span class="line">    VertexOutput o = <span class="built_in">vert</span>(v);<span class="comment">//调用原本该在顶点着色器中的转换函数。</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="comment">//这里才终于把顶点数据拿给下一阶段</span></span><br><span class="line"></span><br><span class="line">#ENDIF</span><br><span class="line"></span><br><span class="line">float4 frag...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、几何着色器"><a href="#三、几何着色器" class="headerlink" title="三、几何着色器"></a><strong>三、几何着色器</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> geometry geo</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexInput</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexOutput</span>&#123;</span><br><span class="line">    float4 vertex: SV_POSITION;</span><br><span class="line">    float3 normal;</span><br><span class="line">    float3 tangent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意这次的顶点着色器是vert函数，上次是tessvert,同样不做任何操作</span></span><br><span class="line">VertexOutput vert;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">geometryOutput</span>&#123;</span><br><span class="line">    float4 pos: SV_POSITION;</span><br><span class="line">    float2 uv: TEXCOORD0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">geopetryOutput <span class="title">CreateGeoOutput</span><span class="params">(float3 pos, float2 uv)</span></span>&#123;</span><br><span class="line">    geometryOutput o;</span><br><span class="line">    o.pos = UnityObjectToClipPos;</span><br><span class="line">    o.uv = uv;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;<span class="comment">//在几何着色器中完成空间转换，如果同时使用曲面细分和几何着色器，也要放到几何着色器来进行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="built_in">maxvertexcount</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">geo</span><span class="params">(triangle vertexOutput IN[<span class="number">3</span>]: SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> pos = IN[<span class="number">0</span>].vertex;</span><br><span class="line">    <span class="type">float</span> vNormal = IN[<span class="number">0</span>].normal;</span><br><span class="line">    <span class="type">float</span> vTangent = IN[<span class="number">0</span>].tangent;</span><br><span class="line">    <span class="type">float</span> vBinormal = <span class="built_in">cross</span>(vNormal,vTangent)*vTangent.w;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> height = ...</span><br><span class="line">    <span class="type">float</span> width = ...</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    geometryOutput o;</span><br><span class="line">    triStream.<span class="built_in">Append</span>(<span class="built_in">CreatGeoOutput</span>(<span class="built_in">dosomething</span>(pos),<span class="built_in">dosomething</span>(uv));</span><br><span class="line">    triStream.<span class="built_in">Append</span>(<span class="built_in">CreatGeoOutput</span>(<span class="built_in">dosomething</span>(pos),<span class="built_in">dosomething</span>(uv));</span><br><span class="line">    triStream.<span class="built_in">Append</span>(<span class="built_in">CreatGeoOutput</span>(<span class="built_in">dosomething</span>(pos),<span class="built_in">dosomething</span>(uv));<span class="comment">//添加了一个新的三角形图元                            </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以添加更多图元，如：</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818013037250.png" alt="image-20220818013037250" style="zoom:50%;" />



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818013127627.png" alt="image-20220818013127627"></p>
<p>三角形的构建是triStream自动完成的。（uv是自己计算的。）</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><p>使用曲面细分、几何着色器做一些有意思的Demo</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1661109050656-1661142579854.gif" alt="1661109050656"></p>
<p>看了一圈，基本上大家都是参考那两个教程，就不多写什么了。（做到这个效果还挺想复刻一下Clannad的片头的，说不定挺适合）</p>
<p>这里主要完成了基本的曲面细分-几何着色器多pass渲染带阴影和光照的草地-风的扰动。</p>
<p>事实上，几何着色器构建的图元会覆盖原来的三角形图元，原来的表面其实消失了。这里可以再加一个pass渲染。</p>
<p>并且地面pass可以不做细分来节省开销</p>
<p>还可以进一步处理的部分：</p>
<ul>
<li>基于距离的曲面细分</li>
<li>基于RT或物体位置的草地交互</li>
</ul>
<p>继续往后做这两个方向感觉就需要考虑偏向may佬说的在项目中整体方案的思路了。</p>
<p>暂时就放一放</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XX4y1A7Ns">https://www.bilibili.com/video/BV1XX4y1A7Ns</a></p>
<p>【技术美术百人计划】图形 3.3  曲面细分与几何着色器  大规模草渲染</p>
<p>[2] <a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/">https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://roystan.net/articles/grass-shader.html">https://roystan.net/articles/grass-shader.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.3%20%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E4%B8%8E%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8/" data-id="cmfe1kyb0002dykuhfbtw0tsw" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.7 LDR与HDR" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.7%20LDR%E4%B8%8EHDR/" class="article-date">
  <time datetime="2025-09-10T13:18:14.025Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-2-7-LDR与HDR"><a href="#图形-2-7-LDR与HDR" class="headerlink" title="图形 2.7  LDR与HDR"></a>图形 2.7  LDR与HDR</h1><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>HDR &#x3D; High Dynamic Range（高动态范围）</p>
<p>LDR &#x3D; Low Dynamic Range（低动态范围）</p>
<p>动态范围 &#x3D; 最高亮度&#x2F;最低亮度</p>
<ul>
<li><p>对于显示器来说，实际的物理亮度是不同意的。因此需要匹配LDR0-1的范围</p>
</li>
<li><p>自然界中的亮度是HDR的</p>
<ul>
<li>在显示时需要转换到LDR的范围（Tone mapping色调映射）</li>
</ul>
</li>
<li><p>LDR</p>
<ul>
<li>8位精度</li>
<li>单通道0-1（0-255）</li>
<li>常用LDR图片储存格式<ul>
<li>jpg、png等</li>
</ul>
</li>
<li>拾色器、一般图片、电脑屏幕</li>
</ul>
</li>
<li><p>HDR</p>
<ul>
<li>远高于8位精度</li>
<li>单通道可以超过1</li>
<li>常用HDR图片储存格式<ul>
<li>hdr&#x2F;tif&#x2F;exr&#x2F;raw</li>
</ul>
</li>
<li>HDRI、真实世界</li>
</ul>
</li>
</ul>
<h4 id="为什么需要HDR"><a href="#为什么需要HDR" class="headerlink" title="为什么需要HDR"></a>为什么需要HDR</h4><ul>
<li>更好地色彩，更高的动态范围和更丰富的细节，并有效地防止画面国宝，超过亮度值1的色彩也能很好地表现，像素光亮度变得正常，视觉传达更真实。</li>
<li>HDR有超过1的数值，范围更大，能让bloom的表现更好。</li>
</ul>
<h4 id="一些HDR图网站"><a href="#一些HDR图网站" class="headerlink" title="一些HDR图网站"></a>一些HDR图网站</h4><p><a target="_blank" rel="noopener" href="http://www.hdrlabs.com/sibl/archive.html">http://www.hdrlabs.com/sibl/archive.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.openfootage.net/hdri-panorama/">https://www.openfootage.net/hdri-panorama/</a></p>
<h3 id="二、Unity中的HDR"><a href="#二、Unity中的HDR" class="headerlink" title="二、Unity中的HDR"></a>二、Unity中的HDR</h3><h4 id="Camera-HDR设置"><a href="#Camera-HDR设置" class="headerlink" title="Camera-HDR设置"></a>Camera-HDR设置</h4><ul>
<li>场景将渲染为HDR图像缓冲区</li>
<li>后处理：Bloom&amp;Tone mapping</li>
<li>完成转换HDR-&gt;LDR</li>
<li>LDR图像发送给显示器</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730183404967.png" alt="image-20220730183404967" style="zoom:67%;" />

<h4 id="Lightmap-HDR设置"><a href="#Lightmap-HDR设置" class="headerlink" title="Lightmap HDR设置"></a>Lightmap HDR设置</h4><ul>
<li>选择High Quality 将启用HDR光照贴图支持，而Normal Quality将切换为使用RGBM编码</li>
<li>RGBM编码：将颜色存储在RGB通道中，将乘数M储存在Alpha通道中</li>
</ul>
<p>（项目设置-Player-Other settings-Lightmap Encoding）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730183556522.png" alt="image-20220730183556522" style="zoom:67%;" />

<h4 id="拾色器HDR设置"><a href="#拾色器HDR设置" class="headerlink" title="拾色器HDR设置"></a>拾色器HDR设置</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HDR] _BackColor(&quot;BackColor&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Intensity滑动条可调整颜色强度</li>
<li>每增加1，提供的光亮增加一倍</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730183703721.png" alt="image-20220730183703721"></p>
<h4 id="HDR的优缺点"><a href="#HDR的优缺点" class="headerlink" title="HDR的优缺点"></a>HDR的优缺点</h4><ul>
<li>优点<ul>
<li>画面中亮度超过1的部分不会被截为1，增加亮部细节并减少曝光</li>
<li>减少画面较暗部分的色阶感</li>
<li>更好地支持Bloom</li>
</ul>
</li>
<li>缺点<ul>
<li>渲染速度较慢，需要更多显存</li>
<li>不支持硬件AA</li>
<li>部分手机不支持</li>
</ul>
</li>
</ul>
<h3 id="三、HDR与Bloom"><a href="#三、HDR与Bloom" class="headerlink" title="三、HDR与Bloom"></a>三、HDR与Bloom</h3><p>Bloom用于表现高光的晕光效果</p>
<p><em>为实现泛光，我们像平时那样渲染一个有光场景，提取出场景的HDR颜色缓冲以及只有这个场景明亮区域可见的图片。被提取的带有亮度的图片接着被模糊，结果被添加到HDR场景上面。（learnopengl）</em></p>
<h4 id="unity中的BLoom"><a href="#unity中的BLoom" class="headerlink" title="unity中的BLoom"></a>unity中的BLoom</h4><p>Untiy会首先进行下采样（down sample）来计算高光像素，并存在RT中，完成次数由一个参数控制，再up回去，并将下采样的RT加入进去。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730184829163.png" alt="image-20220730184829163" style="zoom:50%;" />

<p>我对这个操作目前的理解是，和learnopengl中为了完成高斯模糊是一样的</p>
<p><img src="https://learnopengl-cn.github.io/img/05/07/bloom_gaussian.png" alt="img"></p>
<p>在毛星云大佬的  《高品质后处理：十种图像模糊算法的总结与实现》中也可以看到对各种模糊算法的解释，如果说是以多次的Box filtering来近似高斯模糊或者其他模糊效果的话，就很好理解了。</p>
<h3 id="四、HDR与Tone-mapping"><a href="#四、HDR与Tone-mapping" class="headerlink" title="四、HDR与Tone mapping"></a>四、HDR与Tone mapping</h3><p>色调映射就是为了把HDR转化为LDR</p>
<ul>
<li>线性映射效果不好</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730185314765.png" alt="image-20220730185314765" style="zoom:50%;" />



<ul>
<li>把高光区域和阴影区域像中等亮度方向压缩-&gt;S曲线</li>
</ul>
<h4 id="ACES"><a href="#ACES" class="headerlink" title="ACES"></a>ACES</h4><p>ACES（Academy Color Encoding System学院颜色编码系统）</p>
<p>效果：对比度提高，很好地保留暗处和亮出的细节</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730185423773.png" alt="image-20220730185423773" style="zoom:50%;" />

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ACES</span></span><br><span class="line"><span class="comment">//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</span></span><br><span class="line">float3 ACESToneMapping(float3 color, <span class="type">float</span> adapted_lum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> A = <span class="number">2.51</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> B = <span class="number">0.03</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> C = <span class="number">2.43</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> D = <span class="number">0.59</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> E = <span class="number">0.14</span>f;</span><br><span class="line"></span><br><span class="line">	color *= adapted_lum;</span><br><span class="line">	<span class="keyword">return</span> (color * (A * color + B)) / (color * (C * color + D) + E);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他Tone mapping曲线</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730185538359.png" alt="image-20220730185538359" style="zoom:50%;" />

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reinhard</span></span><br><span class="line">float3 ReinhardToneMapping(float3 color, <span class="type">float</span> adapted_lum) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">float</span> MIDDLE_GREY = <span class="number">1</span>;</span><br><span class="line">    color *= MIDDLE_GREY / adapted_lum;</span><br><span class="line">    <span class="keyword">return</span> color / (<span class="number">1.0</span>f + color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CE</span></span><br><span class="line">float3 CEToneMapping(float3 color, <span class="type">float</span> adapted_lum) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - <span class="built_in">exp</span>(-adapted_lum * color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Filmic</span></span><br><span class="line">float3 F(float3 x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> A = <span class="number">0.22</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> B = <span class="number">0.30</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> C = <span class="number">0.10</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> D = <span class="number">0.20</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> E = <span class="number">0.01</span>f;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> F = <span class="number">0.30</span>f;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 Uncharted2ToneMapping(float3 color, <span class="type">float</span> adapted_lum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">float</span> WHITE = <span class="number">11.2</span>f;</span><br><span class="line">	<span class="keyword">return</span> F(<span class="number">1.6</span>f * adapted_lum * color) / F(WHITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LUT"><a href="#LUT" class="headerlink" title="LUT"></a>LUT</h4><p>在Color Grading的All None 模式中有一个Lookup Texture（滤镜）</p>
<ul>
<li><p>LUT在LDR之间做变换，Tone mapping是映射HDR到LDR</p>
</li>
<li><p>调整rgb三个通道的LUT被称为3D LUT</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/v2-cc29cf797d187c730f13cfc0bf520714_720w.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/v2-c7d19e036fe6edf8df4d5e694874df50_720w.jpg" alt="img"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="结合先行版基础渲染光照介绍（一）试试IBL在HDR和LDR的区别"><a href="#结合先行版基础渲染光照介绍（一）试试IBL在HDR和LDR的区别" class="headerlink" title="结合先行版基础渲染光照介绍（一）试试IBL在HDR和LDR的区别"></a>结合先行版基础渲染光照介绍（一）试试IBL在HDR和LDR的区别</h4><p>相机设置HDR</p>
<p>左侧探针设置LDR，右侧探针设置HDR，都是1024的分辨率</p>
<p>在生成的贴图上可以看到，一张是exr后缀的HDR贴图，一张是png后缀的LDR贴图。</p>
<p>把它放在我们的材质上，说实话我没看出来有啥区别……</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731223034086.png" alt="image-20220731223034086"></p>
<p>但是随着Lod层级的增加，就可以看出来区别了</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731223343672.png" alt="image-20220731223343672" style="width: 50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731223409296.png" alt="image-20220731223409296" style="width: 50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731223432177.png" alt="image-20220731223432177" style="width:50%;" />

<p>非常地合情合理，在HDR中储存的辐射度范围是大于0-1的，在mipmap中也会储存更高动态范围的光照，在ibl里的细节也就更丰富。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VA41137Wp">https://www.bilibili.com/video/BV1VA41137Wp</a> 【技术美术百人计划】图形 2.7  LDR与HDR</p>
<p>[2] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/07%20Bloom/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/07%20Bloom/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/125744132">https://zhuanlan.zhihu.com/p/125744132</a> 高品质后处理：十种图像模糊算法的总结与实现</p>
<p>[4] Unity Shader入门精要 p361,362</p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21983679">https://zhuanlan.zhihu.com/p/21983679</a> Tone mapping进化论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.7%20LDR%E4%B8%8EHDR/" data-id="cmfe1kyay0023ykuh5sn5fzf4" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.7.2 GPU硬件架构概述" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.7.2%20GPU%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2025-09-10T13:18:14.025Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-2-7-2-GPU硬件架构概述"><a href="#图形-2-7-2-GPU硬件架构概述" class="headerlink" title="图形 2.7.2 GPU硬件架构概述"></a>图形 2.7.2 GPU硬件架构概述</h1><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822162918576.png" alt="image-20220822162918576"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h3><p>GPU是Graphics Processing Unit（图形处理单元）的缩写。顾名思义，GPU最初就是用于更高效的图像的绘制和图元数据处理。和CPU相比，GPU简化了控制模块与Cache模块，但是具有大量的ALU（算术逻辑单元），并且可以进行并行运算。因此，CPU更擅长逻辑、控制、串行运算，GPU更易于运行并行程序。</p>
<p>GPU和通常所说的显卡严格来说是据有区别的，GPU是显卡（Video card、Display card、Graphics card）最核心的部件，但除了GPU，显卡还有扇热器、通讯元件、与主板和显示器连接的各类插槽。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822162950559.png" alt="image-20220822162950559"></p>
<p>我们通常所说的显卡和GPU实际上具有一定区别。GPU是显卡的核心部分，再加上散热器，以及和主板、显示器的各种插槽等，就构成了显卡。显卡不能独立工作，需要装载到主板上，结合CPU、内存、显存、显示器等硬件组成完整的PC</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822163026806.png" alt="image-20220822163026806"></p>
<p>当前市场主流的GPU厂商有Nvidia、AMD、ARM、Imagination、Qualcomm、苹果。</p>
<p>目前在PC、手机、VR一体机等设备上，GPU都发挥着作用，为我们在设备上绘制出更快速、优质的画面奠定了基础。甚至除了绘制，在人工智能领域，近几年神经网络能够成为主流，GPU在其中也起到重要的作用。</p>
<h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a><strong>发展历史</strong></h3><p>1999年，Nvidia的GeForce 256 发布，Nvidia将GPU定义为“集成了变换，照明，三角形设置&#x2F;裁剪和渲染引擎的单芯片处理器，每秒能够处理至少1000万个多边形。GeForce 256被认为是第一块完成商业化的GPU，将GPU引入市场，是市场上第一款采用硬件加速T&amp;L（Transformation&amp;Lighting）的消费级卡。而在GeForce 256之前，也并非没有“具有完整T&amp;L引擎的显卡”，但是它们从未引入市场。实际上，20世纪70年代就有了“GPU”的概念，索尼于1994年PS1推出时使用“GPU”的术语。该系统有一个32位索尼GPU（由东芝设计）。这个阶段的GPU也已经基本具备渲染、Z缓冲、Alpha混合、雾计算、模板缓冲、纹理映射、纹理过滤等功能。</p>
<p>从下面开始，以Nvidia的GPU发展过程为代表来讲述现代GPU和GPU架构的发展历史。</p>
<p>2001年的GeForce3 开始，引入了可编程的渲染管线（可编程顶点着色器，可配置的32位浮点片段着色管线）。</p>
<p>2006年推出了GeForce8 系列（G8x），也正是在这一代的GPU的基础上，开始有了GPU架构——Tesla架构。</p>
<p>2010年的Fermi架构是第一个完整的GPU计算架构，是NVIDIA GPU 架构自初代 G80 以来最重大的飞跃。后来的Kepler架构、Maxwell架构都是基于Fermi架构的基础。</p>
<p>2012年的Kepler架构显卡（600，700系列）和2014年的Maxwell架构显卡采用28nm工艺制造，使性能提高了20%。</p>
<p>2014年的Maxwell架构，立体像素全局光照VXGI技术首次让游戏GPU能够提供实时动态全局光照</p>
<p>2016年的GeForce GTX系列采用接替Maxwell的Pascal架构。Pascal 架构将处理器和数据集成在同一个程序包内，以实现更高的计算效率。1080系列、1060系列都是基于Pascal架构。</p>
<p>2017年发布的Volta 架构配备了640 个Tensor core，这是专为深度学习设计的内核，每秒可提供超过100 兆次浮点运算(TFLOPS) 的深度学习效能，比前一代的Pascal 架构快5 倍以上。使用Volta架构的Titan V显卡也是专用于AI和仿真。</p>
<p>从2018年开始的Turing架构，融合了Volta专用的Tensor Core，同时增加了RT core，这是光线追踪技术的核心。RT Core 能够以高达每秒 10 Giga Rays 的速度对光线和声音在 3D  环境中的传播进行加速计算。Turing 架构将实时光线追踪运算加速至上一代 NVIDIA Pascal架构的 25 倍，并能以高出 CPU  30 多倍的速度进行电影效果的最终帧渲染。为了体现对光线追踪的支持，NVIDIA在这之后的显卡前缀都采用了RTX。</p>
<p>2020年的RTX 30系列采用了最新的Ampere架构。Ampere架构的Tensor core采用新的Tensor Float32（TF32）与64位浮点（FP64）精度标准。RT core也进行了更新，运算能力达到第一代的两倍。</p>
<h3 id="GPU架构组成"><a href="#GPU架构组成" class="headerlink" title="GPU架构组成"></a><strong>GPU架构组成</strong></h3><p>每一代的GPU架构虽然具有差异，但也有一些相同的概念和组成部分。</p>
<p>以Fermi架构为例，Fermi架构拥有16个SM （Stream Multiprocessor 流多处理器&#x2F;计算单元）。SM支持并发执行多个thread。Kepler、Maxwell架构中甚至对SM升级为SMX、SMM。程序员编写的Shader是在SM上运行的。</p>
<p>每个SM包含：</p>
<ul>
<li>2个Warp Scheduler</li>
<li>2个Dispatch Unit（分发单元）</li>
<li>2个Warp（线程束）</li>
<li>16组LD&#x2F;ST（加载存储单元）</li>
<li>4个SFU（特殊函数单元）</li>
<li>128KB Register File（寄存器）</li>
<li>64KB Shared Memory &#x2F;L1 Cache</li>
<li>Uniform Cache（全局缓存）</li>
</ul>
<p>每个Warp包含32个Core（也叫做SP——Stream Processor）；</p>
<p>每个Core包含1个FPU（浮点数单元），1个ALU（算术逻辑单元）</p>
<p>Warp Scheduler负责Warp调度，Warp Scheduler的指令通过Dispatch Units送到运算核心（Core）执行。</p>
<p>LD&#x2F;ST(Load&#x2F;Store)加载&#x2F;存储模块用于辅助一个Warp从Shared Memory或显存加载或存储数据。</p>
<p>对于L1 Cache，部分GPU架构中是与Shared Memory共用的（如Fermi架构）。</p>
<p>Turing：</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822163459068.png" alt="image-20220822163459068"></p>
<p>共性：</p>
<ul>
<li>GPC（图形处理簇）</li>
<li>TPC（纹理处理簇）</li>
<li>Thread（线程）</li>
<li>SM、SMX、SMM（流多处理器）</li>
<li>Warp线程束、Warp Scheduler（Warp编排器）</li>
<li>SP（Streaming Processor，流处理器）</li>
<li>Core（执行数学运算的核心）</li>
<li>ALU（逻辑运算单元）</li>
<li>FPU（浮点运算单元）</li>
<li>SFU（特殊函数单元）</li>
<li>ROP（render output unit，渲染输入单元）</li>
<li>Load&#x2F;Store Unit（加载存储单元）</li>
<li>L1 Cache</li>
<li>L2 Cache</li>
<li>Shared Memory（共享内存）</li>
</ul>
<h3 id="微观物理架构"><a href="#微观物理架构" class="headerlink" title="微观物理架构"></a><strong>微观物理架构</strong></h3><ul>
<li>GPC<ul>
<li>TPC<ul>
<li>SM<ul>
<li>Poly Morph Engine（多边形引擎）</li>
<li>L1 Cache</li>
<li>Shared Memory</li>
<li>Core<ul>
<li>ALU</li>
<li>FPU</li>
<li>Execution Context（执行上下文）<ul>
<li>汇编代码会被GPU推送到执行上下文（Execution Context），然后ALU会逐条获取（Detch）、解码（Decode）汇编指令，并执行它们。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="GPU存储架构"><a href="#GPU存储架构" class="headerlink" title="GPU存储架构"></a><strong>GPU存储架构</strong></h3><h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a><strong>内存架构</strong></h4><p>GPU的存储架构分级由</p>
<ul>
<li>Register File (Memory)寄存器<ul>
<li>位于每个SM中，访问速度最快的存储体，用于存放线程执行时所需的变量</li>
</ul>
</li>
<li>Shared Memory共享内存<ul>
<li>位于每个SM中</li>
</ul>
</li>
<li>L1 Cache</li>
<li>L2 Cache</li>
<li>Constant Memory常量内存<ul>
<li>位于每个SM中和片外的RAM存储器中</li>
</ul>
</li>
<li>Texture Memory纹理内存<ul>
<li>位于每个SM中和片外的RAM存储器中</li>
</ul>
</li>
<li>Global Memory全局内存<ul>
<li>位于片外存储体。容量大，访问延迟高、传输速度较慢，使用二级缓存L2 Cache做缓冲</li>
</ul>
</li>
<li>Local Memory本地内存<ul>
<li>一般位于片内存储体，变量、数组、结构体等都存放在此处，但是有大数组、大结构体以至于寄存器区放不下他们，编译器在编译阶段就会将他们放到片外的DDR芯片中（最好的情况也会放到L2 Cache），且将他们标记为“Local”型</li>
</ul>
</li>
</ul>
<p>构成，它们的存取速度从寄存器到显存依次变慢。</p>
<p>他们物理上所在的位置，决定了他们的速度、大小以及访问规则</p>
<table>
<thead>
<tr>
<th>存储类型</th>
<th>访问周期</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1</td>
</tr>
<tr>
<td>共享内存</td>
<td>1~32</td>
</tr>
<tr>
<td>L1缓存</td>
<td>1~32</td>
</tr>
<tr>
<td>L2缓存</td>
<td>32~64</td>
</tr>
<tr>
<td>纹理、常量缓存</td>
<td>400~600</td>
</tr>
<tr>
<td>全局内存</td>
<td>400~600</td>
</tr>
</tbody></table>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>在不同的平台（PC或移动设备），GPU的存储架构分为分离式和耦合式（是否共享内存）。</p>
<p>分离式架构中CPU和GPU各自有独立的缓存和内存，通过PCI-e总线通讯，缺点是PCI-e相对于两者具有低带宽和高延迟，数据的传输成为其中的性能瓶颈。一般用于PC；</p>
<p>耦合式架构中CPU与GPU共享内存和缓存。AMD的APU采用的就是这种架构。目前主要是用在游戏主机、移动设备中，如PS4，智能手机。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1617944-20190906001850363-356121869.png" alt="img" style="zoom:67%;" />

<p>在储存管理方面，分离式架构中CPU与GPU各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式架构，GPU没有独立的内存，与CPU共享系统内存，由MMU进行存储管理。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822173521235.png" alt="image-20220822173521235"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822173644684.png" alt="image-20220822173644684"></p>
<h3 id="GPU逻辑管线"><a href="#GPU逻辑管线" class="headerlink" title="GPU逻辑管线"></a><strong>GPU逻辑管线</strong></h3><p>我们根据GPU的渲染过程来了解每个部分在GPU中发挥的作用。以Fermi的SM为例</p>
<p>1、程序通过图形API(DX、GL、WEBGL)发出draw call指令，指令会被推送到驱动程序，驱动会检查指令的合法性，然后会把指令放到GPU可以读取的Push buffer中。</p>
<p>2、经过一段时间或者显式调用flush指令后，驱动程序把Push buffer的内容发送给GPU，GPU通过主机接口（Host Interface）接受这些命令，并通过前端（Front End）处理这些命令。</p>
<p>3、在图元分配器(Primitive Distributor)中开始工作分配，处理index buffer中的顶点产生三角形分成批次(batches)，然后发送给多个GPCs（Graphics Processing Cluster）。</p>
<p>4、在GPC中，每个SM中的Poly Morph Engine负责通过三角形索引(triangle indices)取出三角形的数据(vertex data)——Vertex Fetch。</p>
<p>5、在获取数据之后，在SM中以32个线程为一组的线程束(Warp)来调度，来开始处理顶点数据。</p>
<p>6、SM的warp调度器会按照顺序分发指令给整个warp，单个warp中的线程会锁步(lock-step)执行各自的指令，如果线程碰到不激活执行的情况也会被遮掩(be masked  out)。</p>
<p>7、warp中的指令可以被一次完成，也可能经过多次调度，例如通常SM中的LD&#x2F;ST(加载存取)单元数量明显少于基础数学操作单元。</p>
<p>8、由于某些指令比其他指令需要更长的时间才能完成，特别是内存加载，warp调度器可能会简单地切换到另一个没有内存等待的warp，这是GPU如何克服内存读取延迟的关键，只是简单地切换活动线程组。为了使这种切换非常快，调度器管理的所有warp在寄存器文件中都有自己的寄存器。这里就会有个矛盾产生，Shader需要越多的寄存器，就会给warp留下越少的空间，就会产生越少的warp，这时候在碰到内存延迟的时候就会只是等待，而没有可以运行的warp可以切换。</p>
<p>9、一旦warp完成了vertex shader的所有指令，运算结果会被Viewport Transform模块处理，三角形会被裁剪然后准备栅格化，GPU会使用L1和L2缓存来进行vertex shader和pixel shader的数据通信。</p>
<p>10、接下来这些三角形将被分割，再分配给多个GPC，三角形的范围决定着它将被分配到哪个光栅引擎(raster engines)，每个raster engines覆盖了多个屏幕上的tile，这等于把三角形的渲染分配到多个tile上面。也就是像素阶段就把按三角形划分变成了按显示的像素划分了。</p>
<p>11、SM上的Attribute Setup保证了从vertex shader来的数据经过插值后是pixel shade是可读的。</p>
<p>12、GPC上的光栅引擎(raster engines)在它接收到的三角形上工作，来负责这些这些三角形的像素信息的生成（同时会处理裁剪Clipping、背面剔除和Early-Z剔除）。</p>
<p>13、32个像素线程将被分成一组，或者说8个2x2的像素块，这是在像素着色器上面的最小工作单元，在这个像素线程内，如果没有被三角形覆盖就会被遮掩，SM中的warp调度器会管理像素着色器的任务。</p>
<p>14、接下来的阶段就和vertex shader中的逻辑步骤完全一样，但是变成了在像素着色器线程中执行。 由于不耗费任何性能可以获取一个像素内的值，导致锁步执行非常便利，所有的线程可以保证所有的指令可以在同一点。</p>
<p>15、最后一步，现在像素着色器已经完成了颜色的计算还有深度值的计算，在这个点上，我们必须考虑三角形的原始api顺序，然后才将数据移交给ROP(render output  unit，渲染输入单元)，一个ROP内部有很多ROP单元，在ROP单元中处理深度测试，和framebuffer的混合，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。</p>
<h3 id="SIMD和SIMT"><a href="#SIMD和SIMT" class="headerlink" title="SIMD和SIMT"></a><strong>SIMD和SIMT</strong></h3><ul>
<li>SIMD（Single Instruction Multiple Data），单指令多数据，在GPU的ALU内，一条指令可以处理多维向量（一般是4D）的数据，比如以下shader指令<ul>
<li>float4 c&#x3D;a+b;</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;对于没有SIMD的处理单元，需要4条指令将4个float数值相加，汇编如下</span><br><span class="line">ADD c.x, a.x, b.x</span><br><span class="line">ADD c.y, a.y, b.y</span><br><span class="line">ADD c.z, a.z, b.z</span><br><span class="line">ADD c.w, a.w, b.w</span><br><span class="line">;有了SIMD技术，只需一条指令</span><br><span class="line">SIMD_ADD c,a,b</span><br></pre></td></tr></table></figure>

<ul>
<li>SIMT（Single Instruction Multiple Threads），单指令多线程，是SIMD的升级版，可对GPU中单个SM中的多个Core同时处理同一指令，并且每个Core存取的数据可以不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SIMT_ADD c,a,b</span><br><span class="line">;上述指令会被同时送入在单个SM中被编组的所有Core中，同时执行运算，但a,b,c的值可以不同</span><br><span class="line">;相当于</span><br><span class="line">__global__ void add(float *a, float *b, float *c) &#123;</span><br><span class="line">	int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">	a[i] = b[i] + c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="co-issue"><a href="#co-issue" class="headerlink" title="co-issue"></a><strong>co-issue</strong></h4><p>co-issue是为了解决SIMD运算单元无法充分利用的问题。如下图，由于float的数量不同，ALU的利用率也不同</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822171640666.png" alt="image-20220822171640666"></p>
<p>为了解决着色器在低维向量的利用率低的问题，可以通过合并1D与3D或2D与2D的指令。例如下图，DP3指令用了3D数据，ADD指令只有1D数据，co-issue会自动将它们合并，在同一个ALU只需一个指令周期即可执行完</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822171813268.png" alt="image-20220822171813268"></p>
<p>但是对于向量运算单元（Vector ALU），如果其中一个变量既是操作数又是存储数的情况，无法使用co-issue</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li>vs和fs都是在同一个单元中执行的，vs按照三角形来并行处理，fs按照像素来并行处理。</li>
<li>vs和fs中的数据通过L1和L2缓存传递</li>
<li>warp和thread都是逻辑上的概念，sm和sp、core都是物理上的概念。线程束≠流处理器数</li>
</ul>
<h4 id="优化建议："><a href="#优化建议：" class="headerlink" title="优化建议："></a><strong>优化建议：</strong></h4><ol>
<li>尽量使用自己扩展的几何实例化代替unity提供的静态合批，动态合批。前者将合并mesh增加额外的vbo内存占用。后者则会增加cpu端的耗时开销。</li>
<li>尽量减少顶点数与三角形面数。前者减少vs计算，另外可以减少gpu显存中frameData的内存存储。后者减少fs的消耗</li>
<li>避免每帧提交buffer数据，比如unity的CPU版本粒子系统。可使用GPU版本粒子系统，将修改数据移动到gpu端。另外特别提醒尽量避免大片的透明粒子特效，这将造成严重的overdraw</li>
<li>减少渲染状态的设置与获取。例如在update中获取设置shader的属性或公共变量。因为前面说到cpu通过MMIO获取寄存器数据，这将耗费更多的时间周期。</li>
<li>3D物件应使用LOD减少处理的顶点与面数消耗，开启mipmap减少贴图缓存命中的丢失</li>
<li>避免Alpha Test的使用，造成Early-Z失效</li>
<li>避免三角面过小，这会加剧过度绘制的情况。也就是一个三角形只占3个像素点，却使用了12个线程去计算像素值，然后遮蔽其余9个的计算机结果。</li>
<li>在寄存器数量与变体中寻找平衡，使用if变量达成静态分支，取代变体。一方面可以减少变体数量，一方面可以使得URP中的SRP Batch更高效合批</li>
<li>避免动态的判断分支。也就是Shader中if true和false都会走的情况</li>
<li>减少复杂函数调用。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/timlly/p/11471507.html#22-gpu%E5%8E%86%E5%8F%B2">https://www.cnblogs.com/timlly/p/11471507.html#22-gpu%E5%8E%86%E5%8F%B2</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.nvidia.cn/data-center/ampere-architecture/">https://www.nvidia.cn/data-center/ampere-architecture/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Graphics_processing_unit">图形处理单元 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aM4y1g75f">https://www.bilibili.com/video/BV1aM4y1g75f</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://www.daimajiaoliu.com/daima/486fc2a23900400">云渲染与分布式并行集群渲染技术 (daimajiaoliu.com)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.7.2%20GPU%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/" data-id="cmfe1kyay0025ykuh1tbo6dii" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>