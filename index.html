<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">XZYW7&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="XZYW7&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-hello-world" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2025/09/10/hello-world/">Hello World</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2025/09/10/hello-world/" class="article-date">
  <time datetime="2025-09-09T16:25:58.669Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p> 重新开始出发</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/hello-world/" data-id="cmfe8hf3j00019wuh9d898fw5" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形4.3实时阴影算法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/10/06/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.3%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1%E7%AE%97%E6%B3%95/">【笔记】【百人计划】图形4.3 实时阴影算法</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/10/06/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.3%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2022-10-05T16:52:45.000Z" itemprop="datePublished">2022-10-06</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>GAMES202这部分的笔记会详细一些</p>
<p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/real-time-shadows/">https://xzyw7.github.io/post/real-time-shadows/</a></p>
<h2 id="一、基于图片的实时阴影"><a href="#一、基于图片的实时阴影" class="headerlink" title="一、基于图片的实时阴影"></a><strong>一、基于图片的实时阴影</strong></h2><h3 id="1-1-平面投影阴影"><a href="#1-1-平面投影阴影" class="headerlink" title="1.1 平面投影阴影"></a><strong>1.1 平面投影阴影</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004195717680.png" alt="image-20221004195717680"></p>
<p>Shadow Volume？</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004195836867.png" alt="image-20221004195836867"></p>
<ul>
<li>Unity-Projector组件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004195901831.png" alt="image-20221004195901831"></p>
<h3 id="1-2-阴影映射"><a href="#1-2-阴影映射" class="headerlink" title="1.2 阴影映射"></a><strong>1.2 阴影映射</strong></h3><p>略</p>
<h3 id="1-3-屏幕空间阴影映射"><a href="#1-3-屏幕空间阴影映射" class="headerlink" title="1.3 屏幕空间阴影映射"></a><strong>1.3 屏幕空间阴影映射</strong></h3><ol>
<li>渲染屏幕空间深度图</li>
<li>从光源渲染shadow map</li>
<li>屏幕空间做一次阴影收集计算（Shadows Collector），得到一张屏幕空间阴影纹理</li>
<li>绘制物体的时候，用物体的屏幕UV坐标，采样该屏幕空间阴影纹理</li>
</ol>
<h2 id="二、Shadow-Mapping的优化"><a href="#二、Shadow-Mapping的优化" class="headerlink" title="二、Shadow Mapping的优化"></a><strong>二、Shadow Mapping的优化</strong></h2><h3 id="2-1-自阴影问题"><a href="#2-1-自阴影问题" class="headerlink" title="2.1 自阴影问题"></a><strong>2.1 自阴影问题</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004201408133.png" alt="image-20221004201408133"></p>
<p>不建议叫Z-fighting</p>
<ul>
<li>当比较深度时，为了避免表面自阴影，需要设置容错阈值<ul>
<li>深度偏移（Depth Bias）</li>
<li>法线偏移（Normal Bias）</li>
</ul>
</li>
<li>偏移过大会出现阴影悬浮，也叫做Peter Panning</li>
</ul>
<h4 id="自阴影的优化-偏移优化"><a href="#自阴影的优化-偏移优化" class="headerlink" title="自阴影的优化&#x2F;偏移优化"></a><strong>自阴影的优化&#x2F;偏移优化</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004201710705.png" alt="image-20221004201710705"></p>
<p>由于shadow map采样率，这一片都对应了同一个深度</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004202709240.png" alt="image-20221004202709240"></p>
<ul>
<li>深度偏移：增加深度偏移使该像素向光源靠近</li>
<li>法线偏移沿法线方向向外偏移</li>
<li>偏移单位是shadow map的纹素</li>
<li>在Shadow Receive计算阶段，逐像素进行</li>
<li>只会在阴影深度测试时使用，不影响场景</li>
</ul>
<h4 id="Unity中的偏移优化"><a href="#Unity中的偏移优化" class="headerlink" title="Unity中的偏移优化"></a><strong>Unity中的偏移优化</strong></h4><ul>
<li>Shadow Caster阶段基于顶点的Normal Bias</li>
<li>在Shadow Caster阶段让遮蔽物进行反向偏移</li>
<li>优点：性能高</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004203141895.png" alt="image-20221004203141895"></p>
<h3 id="2-2-走样问题"><a href="#2-2-走样问题" class="headerlink" title="2.2 走样问题"></a><strong>2.2 走样问题</strong></h3><ul>
<li>初始采样<ul>
<li>渲染shadow map</li>
<li>透视走样</li>
</ul>
</li>
<li>重采样<ul>
<li>摄像机视角对采样信号（shadow map）重采样</li>
</ul>
</li>
</ul>
<h4 id="2-2-1-透视走样的原因及解决方案"><a href="#2-2-1-透视走样的原因及解决方案" class="headerlink" title="2.2.1 透视走样的原因及解决方案"></a><strong>2.2.1 透视走样的原因及解决方案</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004203316892.png" alt="image-20221004203316892"></p>
<h5 id="级联阴影映射"><a href="#级联阴影映射" class="headerlink" title="级联阴影映射"></a><strong>级联阴影映射</strong></h5><ul>
<li>透视走样最有效的解决方案</li>
<li>把视锥体分割为多个子视锥体</li>
<li>为每个子视锥体计算独立的相等大小的Shadow map</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004203530303.png" alt="image-20221004203530303"></p>
<h4 id="2-2-2-重采样的原因及解决方案"><a href="#2-2-2-重采样的原因及解决方案" class="headerlink" title="2.2.2 重采样的原因及解决方案"></a><strong>2.2.2 重采样的原因及解决方案</strong></h4><ul>
<li>阴影映射是一张动态生成的纹理</li>
<li>滤波-纹理采样误差的解决方案<ul>
<li>阴影的滤波<ul>
<li>使用一部分Shadow map采样点来计算某个指定View采样点的最终阴影结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004203705456.png" alt="image-20221004203705456"></p>
<ul>
<li>采样数<ul>
<li>规则滤波，3x3或5x5</li>
<li>采用Poisson Disk等的形式来分布一定数量的采样点</li>
</ul>
</li>
<li>滤波核函数<ul>
<li>高斯函数作为滤波核函数</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><ol>
<li>总结实时阴影的优化方案</li>
<li>尝试自己实现一套阴影系统</li>
</ol>
<p>直接放GAMES202的作业在这了</p>
<p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/guo-cheng-ji-lu-games202-huan-jing-pei-zhi-yu-shi-shi-yin-ying/">https://xzyw7.github.io/post/guo-cheng-ji-lu-games202-huan-jing-pei-zhi-yu-shi-shi-yin-ying/</a></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221005194550816.png" alt="image-20221005194550816"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Jf4y1P7ch">https://www.bilibili.com/video/BV1Jf4y1P7ch</a> </p>
<p>【技术美术百人计划】图形 4.3 实时阴影介绍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/06/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.3%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1%E7%AE%97%E6%B3%95/" data-id="cmfe8hf4e004l9wuh1k42czxu" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/GAMES/作业过程记录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/10/06/TA/Graphics/GAMES/%E4%BD%9C%E4%B8%9A%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/">【过程记录】【GAMES202】环境配置与实时阴影</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/10/06/TA/Graphics/GAMES/%E4%BD%9C%E4%B8%9A%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2022-10-05T16:45:04.000Z" itemprop="datePublished">2022-10-06</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="作业0"><a href="#作业0" class="headerlink" title="作业0"></a><strong>作业0</strong></h3><p>作业0就配置下环境，但是会遇到模型有时候加载不出来的问题，论坛里说得很清楚。</p>
<p><a target="_blank" rel="noopener" href="https://games-cn.org/forums/topic/zuoye0-jieguobuwendingyoushimoxingxianshibuquan/">https://games-cn.org/forums/topic/zuoye0-jieguobuwendingyoushimoxingxianshibuquan/</a></p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221003152423968.png" alt="image-20221003152423968" style="zoom:50%;" />

<img src="%E4%BD%9C%E4%B8%9A%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/image-20221003152437594.png" alt="image-20221003152437594" style="zoom:50%;" />

<p>由于异步处理，如果这张材质图片是后加载的就看不见了，因此解决操作是把它预先加载。</p>
<p>其次是在框架上编写Phong模型的shader，跟着说明做就行了。</p>
<h3 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a><strong>作业1</strong></h3><h4 id="CalcLightMVP"><a href="#CalcLightMVP" class="headerlink" title="CalcLightMVP"></a><strong>CalcLightMVP</strong></h4><p>第一步需要完成shadow mapping的部分，计算方向光下的MVP矩阵。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">CalcLightMVP</span>(translate, scale) &#123;</span><br><span class="line">    <span class="keyword">let</span> lightMVP = mat4.<span class="title function_">create</span>();</span><br><span class="line">    <span class="keyword">let</span> modelMatrix = mat4.<span class="title function_">create</span>();</span><br><span class="line">    <span class="keyword">let</span> viewMatrix = mat4.<span class="title function_">create</span>();</span><br><span class="line">    <span class="keyword">let</span> projectionMatrix = mat4.<span class="title function_">create</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Model transform</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// View transform</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Projection transform</span></span><br><span class="line"></span><br><span class="line">    mat4.<span class="title function_">multiply</span>(lightMVP, projectionMatrix, viewMatrix);</span><br><span class="line">    mat4.<span class="title function_">multiply</span>(lightMVP, lightMVP, modelMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lightMVP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提供了translate和scale的参数，没有rotation，那就不用。</p>
<p>并且我们在Mesh Render当中可以找到camera计算MVP的部分</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221003161324505.png" alt="image-20221003161324505"></p>
<p>Model的部分可以直接照抄了，这里也是没有Rotation的，可见估计是为了方便，省去了四元数等等的旋转计算，就没有做旋转变换。</p>
<p>接下来是View矩阵的部分。在方向光的构造函数中，提供了一些东西，有lightPos和focalPoint，我们就可以计算出front，有up，那么view矩阵就很好算出来了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221003161532352.png" alt="image-20221003161532352"></p>
<p>但是我一直没有找到这个框架矩阵运算的api，只能看里面已经有的怎么用我就怎么用……上面有个lookAt的方法，那就用它了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221003161736551.png" alt="image-20221003161736551"></p>
<p>猜也很好猜（输出，相机位置，focal位置，up向量）</p>
<p>还是给找到了，矩阵运算的api用了一个gl-matrix-min的库，这个东西就来自于gl-matrix，百度搜到文档</p>
<p><a target="_blank" rel="noopener" href="https://glmatrix.net/docs/module-mat4.html">https://glmatrix.net/docs/module-mat4.html</a></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221003163223666.png" alt="image-20221003163223666"></p>
<p>最后变成就这么几行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="title class_">CalcLightMVP</span>(translate, scale) &#123;</span><br><span class="line">      <span class="keyword">let</span> lightMVP = mat4.<span class="title function_">create</span>();</span><br><span class="line">      <span class="keyword">let</span> modelMatrix = mat4.<span class="title function_">create</span>();</span><br><span class="line">      <span class="keyword">let</span> viewMatrix = mat4.<span class="title function_">create</span>();</span><br><span class="line">      <span class="keyword">let</span> projectionMatrix = mat4.<span class="title function_">create</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Model transform</span></span><br><span class="line"><span class="comment">//mat4.identity(modelMatrix);</span></span><br><span class="line">mat4.<span class="title function_">translate</span>(modelMatrix, modelMatrix, translate);</span><br><span class="line">mat4.<span class="title function_">scale</span>(modelMatrix, modelMatrix, scale);</span><br><span class="line"><span class="comment">// View transform</span></span><br><span class="line">      <span class="comment">//mat4.identity(viewMatrix);</span></span><br><span class="line">      mat4.<span class="title function_">lookAt</span>(viewMatrix, <span class="variable language_">this</span>.<span class="property">lightPos</span>, <span class="variable language_">this</span>.<span class="property">focalPoint</span>, <span class="variable language_">this</span>.<span class="property">lightUp</span>);</span><br><span class="line"><span class="comment">// Projection transform</span></span><br><span class="line"><span class="comment">//mat4.identity(projectionMatrix);</span></span><br><span class="line">      mat4.<span class="title function_">ortho</span>(projectionMatrix,-<span class="number">150</span>, <span class="number">150</span>, -<span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">      mat4.<span class="title function_">multiply</span>(lightMVP, projectionMatrix, viewMatrix);</span><br><span class="line">      mat4.<span class="title function_">multiply</span>(lightMVP, lightMVP, modelMatrix);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> lightMVP;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="useShadowMap"><a href="#useShadowMap" class="headerlink" title="useShadowMap"></a><strong>useShadowMap</strong></h4><p>下一步就是完成fs中的可见性计算，框架给我们准备得很好，可以看到包括后面进阶部分的PCF和PCSS，都封装好了，只需要填函数就可以了。</p>
<p>首先需要完成的是useShadowMap来做一个简单的shadow map</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221003163729535.png" alt="image-20221003163729535"></p>
<p>首先我们要用shadow Coord去采样shadow Map来获得着色点在灯光视角下的该位置的最小深度。因此采样我们应该在灯光的齐次裁剪空间坐标下。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221003164831105.png" alt="image-20221003164831105"></p>
<p>顶点着色器已经把它做好了，就是vPositionFromLight。</p>
<p>我们也可以在shadowFragment当中看到在light pass中对深度的处理</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221003174719233.png" alt="image-20221003174719233"></p>
<p>将片元的深度进行了pack。注意这里的深度，是在片元着色器阶段，因此，齐次裁剪空间的坐标需要经过透视除法。（虽然正交投影没有影响）</p>
<p>还要注意，采样贴图需要在0-1完成，这使得我们需要做一个映射操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec3 shadowCoord = (vPositionFromLight.xyz/vPositionFromLight.w) * 0.5+vec3(0.5);</span><br></pre></td></tr></table></figure>

<p>但是问题来了，在learnopengl中，因为深度贴图储存范围在0-1，所以深度也需要做这个映射，我们这里把深度用pack的方法保存存了，为什么还要做这个映射呢？不是只需要映射xy就行了吗？</p>
<p>问题的根节是，framebuffer中存储的深度到底是什么深度？pack暂且不管，也就是说，gl_FragCoord.z到底是什么？首先像上面说的，肯定是在NDC空间的z经过了透视除法之后，但这一部分也是在[-1,1]^3中，（由于平台差异，如D3D的NDC空间的z就是[0,1]）那么为了写入深度缓冲，Opengl自己做了这一部分的映射</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66175070">https://zhuanlan.zhihu.com/p/66175070</a></p>
<p>这一点只要记住就行了，总得来说，gl_FragCoord.z就是深度缓冲中的值，也就是[-1,1]&#x3D;&gt;[0,1]变换过后的NDC的z值。总之，这里虽然整体*0.5+0.5，做了变换，但意义是不同的。</p>
<p>那么最后在shadow map的部分，提取出深度拿来比较一下就好了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float <span class="title function_">useShadowMap</span>(<span class="params">sampler2D shadowMap, vec4 shadowCoord</span>)&#123;</span><br><span class="line">  float depth = <span class="title function_">unpack</span>(<span class="title function_">texture2D</span>(shadowMap, shadowCoord.<span class="property">xy</span>));</span><br><span class="line">  float currentDepth = shadowCoord.<span class="property">z</span>;</span><br><span class="line">  float bias = <span class="number">0.005</span>;</span><br><span class="line">  <span class="keyword">return</span> depth&lt;currentDepth - bias ? <span class="number">0.0</span> : <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004003325365.png" alt="image-20221004003325365"></p>
<p>这一部分算是完成了。</p>
<h4 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a><strong>PCF</strong></h4><p>这一部分也很容易，跟着learnopengl也能做，不过作业框架中提出，我们可以对比一下两种采样的区别</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">uniformDiskSamples</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">in</span> vec2 randomSeed </span>) &#123;</span><br><span class="line"></span><br><span class="line">  float randNum = <span class="title function_">rand_2to1</span>(randomSeed);</span><br><span class="line">  float sampleX = <span class="title function_">rand_1to1</span>( randNum ) ;</span><br><span class="line">  float sampleY = <span class="title function_">rand_1to1</span>( sampleX ) ;</span><br><span class="line"></span><br><span class="line">  float angle = sampleX * <span class="title class_">PI2</span>;</span><br><span class="line">  float radius = <span class="title function_">sqrt</span>(sampleY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>( int i = <span class="number">0</span>; i &lt; <span class="variable constant_">NUM_SAMPLES</span>; i ++ ) &#123;</span><br><span class="line">    poissonDisk[i] = <span class="title function_">vec2</span>( radius * <span class="title function_">cos</span>(angle) , radius * <span class="title function_">sin</span>(angle)  );</span><br><span class="line"></span><br><span class="line">    sampleX = <span class="title function_">rand_1to1</span>( sampleY ) ;</span><br><span class="line">    sampleY = <span class="title function_">rand_1to1</span>( sampleX ) ;</span><br><span class="line"></span><br><span class="line">    angle = sampleX * <span class="title class_">PI2</span>;</span><br><span class="line">    radius = <span class="title function_">sqrt</span>(sampleY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float <span class="title function_">findBlocker</span>(<span class="params"> sampler2D shadowMap,  vec2 uv, float zReceiver </span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做的是单位圆盘上的随机采样，把一个vec2储存到了poisonDisk的数组上。那么我们只需要在采样shadowmap的纹理坐标上，增加一个这个位置的样本即可。要注意的是我们的纹理采样是在0-1范围上的，因此这个位置也应该根据纹素大小进行放缩（如果把纹素大小看作单位长度的话）。这一部分learnopengl直接用了textureSize的API，但我们使用的opengl ES版本似乎不支持这个api，但是能够在engine.js中找到对framebuffer的定义</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004010329214.png" alt="image-20221004010329214"></p>
<p>因此只需要除以2048即可。我们也可以通过对这个采样范围进行任意的放缩，相当于不同size的kernel。（比较喜欢这个框架的采样的处理方式，learnopengl中的遍历纹素就太笨重了）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">float <span class="title function_">PCF</span>(<span class="params">sampler2D shadowMap, vec4 coords</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">poissonDiskSamples</span>(coords.<span class="property">xy</span>);</span><br><span class="line">  float currentDepth = coords.<span class="property">z</span>;</span><br><span class="line">  float bias = <span class="number">0.005</span>;</span><br><span class="line">  float shadow = <span class="number">0.0</span>;</span><br><span class="line">  float texelSize = <span class="number">1.0</span> / <span class="number">2048.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(int i =<span class="number">0</span>; i &lt;<span class="variable constant_">NUM_SAMPLES</span>;i++) &#123;</span><br><span class="line">    float depth = <span class="title function_">unpack</span>(<span class="title function_">texture2D</span>(shadowMap, coords.<span class="property">xy</span> + poissonDisk[i] * texelSize * <span class="number">10.0</span>));</span><br><span class="line">    shadow += depth&lt;currentDepth - bias ? <span class="number">0.0</span> : <span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  shadow = shadow/<span class="title function_">float</span>(<span class="variable constant_">NUM_SAMPLES</span>);</span><br><span class="line">  <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004010532040.png" alt="image-20221004010532040" style="zoom:50%;" />

<p>边缘是被模糊了，但是如果我们想要更多的模糊，会发现模型其他部分也受到了影响，出现一些噪声。</p>
<p><strong>Uniform：</strong></p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004010749880.png" alt="image-20221004010749880" style="zoom: 80%;" />

<p><strong>Poisson：</strong></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221004010801969.png" alt="image-20221004010801969"></p>
<p>关于泊松圆盘采样，这里说得很好，一张图就可以解释</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484414050">https://zhuanlan.zhihu.com/p/484414050</a></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/v2-b8033730c574ca0b7b24944011bb893d_720w.webp" alt="img"></p>
<h4 id="PCSS"><a href="#PCSS" class="headerlink" title="PCSS"></a><strong>PCSS</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">findBlocker</span><span class="params">( sampler2D shadowMap,  vec2 uv, <span class="type">float</span> zReceiver )</span> </span>&#123;</span><br><span class="line">  <span class="built_in">poissonDiskSamples</span>(uv);</span><br><span class="line">  <span class="type">float</span> texelSize = <span class="number">1.0</span> / <span class="number">2048.0</span>;</span><br><span class="line">  <span class="type">float</span> blockDepth = <span class="number">0.0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">float</span> radius =<span class="number">40.0</span>;</span><br><span class="line">  <span class="type">float</span> bias = <span class="number">0.005</span>;</span><br><span class="line">  <span class="type">int</span> blockNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; BLOCKER_SEARCH_NUM_SAMPLES; i++) &#123;</span><br><span class="line">    <span class="type">float</span> depth = <span class="built_in">unpack</span>(<span class="built_in">texture2D</span>(shadowMap, uv + poissonDisk[i] * texelSize * radius));</span><br><span class="line">    <span class="keyword">if</span> (depth &lt; zReceiver - bias) &#123;</span><br><span class="line">      blockDepth += depth;</span><br><span class="line">      blockNum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (blockNum == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  blockDepth /= <span class="built_in">float</span>(blockNum);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> blockDepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">PCSS</span><span class="params">(sampler2D shadowMap, vec4 coords)</span></span>&#123;</span><br><span class="line">  <span class="built_in">poissonDiskSamples</span>(coords.xy);</span><br><span class="line">  <span class="type">float</span> receiverDepth = coords.z;</span><br><span class="line">  <span class="type">float</span> LightSize =<span class="number">40.0</span>;</span><br><span class="line">  <span class="type">float</span> texelSize = <span class="number">1.0</span> / <span class="number">2048.0</span>;</span><br><span class="line">  <span class="comment">// STEP 1: avgblocker depth</span></span><br><span class="line">  <span class="type">float</span> blockDepth = <span class="built_in">findBlocker</span>(shadowMap, coords.xy, receiverDepth);</span><br><span class="line">  <span class="comment">/*if (abs(blockDepth - receiverDepth) &lt;0.010) &#123;</span></span><br><span class="line"><span class="comment">    return -1.0;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">  <span class="comment">// STEP 2: penumbra size</span></span><br><span class="line">  <span class="type">float</span> penumbraSize = (receiverDepth - blockDepth)  / blockDepth* LightSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// STEP 3: filtering</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">  <span class="type">float</span> bias = <span class="number">0.005</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;PCF_NUM_SAMPLES;i++) &#123;</span><br><span class="line">    <span class="type">float</span> depth = <span class="built_in">unpack</span>(<span class="built_in">texture2D</span>(shadowMap, coords.xy + poissonDisk[i] * texelSize * penumbraSize));</span><br><span class="line">    shadow += depth&lt;receiverDepth - bias ? <span class="number">0.0</span> : <span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  shadow = shadow/<span class="built_in">float</span>(PCF_NUM_SAMPLES);</span><br><span class="line">  <span class="keyword">return</span> shadow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些小小的filterSize的可视化</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221005174516925.png" alt="image-20221005174516925"></p>
<p>可以注意到这种边缘的地方实际上存在artifacts</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221005174555733.png" alt="image-20221005174555733"></p>
<p>解决方法如下</p>
<p><a target="_blank" rel="noopener" href="https://games-cn.org/forums/topic/zuoye1-dibanbianyuanjianbianhuisejiejuefangfa/">https://games-cn.org/forums/topic/zuoye1-dibanbianyuanjianbianhuisejiejuefangfa/</a></p>
<p><a target="_blank" rel="noopener" href="https://games-cn.org/forums/topic/zuoye1guanyuplanebianjiezaodiandecaiceyujiejue/">https://games-cn.org/forums/topic/zuoye1guanyuplanebianjiezaodiandecaiceyujiejue/</a></p>
<p>（但也不能完全解决）</p>
<p>Shadow的可视化</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221005174914204.png" alt="image-20221005174914204"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221005175747835.png" alt="image-20221005175747835"></p>
<p>增加一点高质量的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221005194550816.png" alt="image-20221005194550816"></p>
<p>下一部分就直接进入PRT了，就不接在这儿了，不然太长了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/06/TA/Graphics/GAMES/%E4%BD%9C%E4%B8%9A%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" data-id="cmfe8hf5100ca9wuh8wu3cc19" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Advanced/" rel="tag">CG Advanced</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAMES/" rel="tag">GAMES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" rel="tag">过程记录</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形4.5 Dof景深基础" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/10/04/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/">【笔记】【百人计划】图形4.5 Dof景深基础</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/10/04/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-10-04T15:18:00.000Z" itemprop="datePublished">2022-10-04</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形4-5-Dof景深基础"><a href="#图形4-5-Dof景深基础" class="headerlink" title="图形4.5 Dof景深基础"></a>图形4.5 Dof景深基础</h2><h2 id="一、景深"><a href="#一、景深" class="headerlink" title="一、景深"></a>一、景深</h2><p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221004232304423.png" alt="image-20221004232304423"></p>
<ul>
<li>景深<ul>
<li>相机对焦点前后相对清晰的成像范围。</li>
<li>虽然透镜只能将光聚到一个固定的距离（焦距），远离此点则会逐渐模糊，但在一段特定的距离内，模糊的程度是无法察觉的，这段距离称之为景深。</li>
<li>当焦点设在超焦距处时，景深会从超焦距的一半延伸到无限远，对于一个固定的光圈来说，这是最大的景深。</li>
</ul>
</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221004232630406.png" alt="image-20221004232630406"></p>
<p>脱焦的点扩大到超过像素大小以后，就会出现模糊</p>
<h2 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h2><ul>
<li>选择性突出或强调画面中的一部分，吸引观察者的注意力到画面中清晰对焦的部分，忽略其他模糊部分的细节</li>
<li>强调所拍摄场景的深度，增加画面的层次立体感</li>
<li>艺术意境的表达</li>
<li>表达主观的视线。在电影学中，通过调节浅景深的镜头，使之对焦在不同位置上，来表示某个人的主观视线的转移</li>
<li>交代人物之间的关系。在电影学中，通过景深聚焦位置的变化来表达前景和背景人物之间的关系</li>
</ul>
<h2 id="三、移动端景深实现"><a href="#三、移动端景深实现" class="headerlink" title="三、移动端景深实现"></a>三、移动端景深实现</h2><ul>
<li>制作思路<ul>
<li>模拟景深制作mask</li>
<li>模糊场景</li>
<li>正常场景</li>
<li>合并</li>
</ul>
</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221004233203292.png" alt="image-20221004233203292"></p>
<p>计算时对于从深度图中获取深度的处理，需要乘以远裁面的大小，获得绝对的相机深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half depth = <span class="built_in">Linear01Depth</span>(<span class="built_in">tex2Dd</span>(_CameraDepthTexture,i.uv))*_ProjectionParams.z;</span><br></pre></td></tr></table></figure>

<p>（这一部分感觉可以替换成恢复线性深度的处理）</p>
<p>因为我们不希望远裁面的位置影响到我们的景深效果（吗？我觉得这一点可以再斟酌一下）</p>
<p>然后通过焦距设置以及该深度计算景深Mask</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> focusNear = _FocusDistance - _DepthOfField;</span><br><span class="line"><span class="type">float</span> focusFar = _FocusDistance + _DepthOfField;</span><br><span class="line"></span><br><span class="line">half finnal_depth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((depth &gt;= focusNear) &amp;&amp; (depth &lt;= focusFar));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(depth &lt; focusNear)</span><br><span class="line">		finnal_depth = <span class="built_in">saturate</span>(<span class="built_in">abs</span>(focusNear - depth));</span><br><span class="line">	<span class="keyword">if</span>(depth &gt; focusFar)</span><br><span class="line">		finnal_depth = <span class="built_in">saturate</span>(<span class="built_in">abs</span>(depth - focusFar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搞了一个如下的Mask效果，靠近焦距就不模糊（0），远离焦距就模糊（1）</p>
<p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221004234304634.png" alt="image-20221004234304634"></p>
<p>接下来的计算就很自然了，卷积，然后根据mask和原图进行插值。</p>
<p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221004234515207.png" alt="image-20221004234515207"></p>
<p>通过降采样多次迭代处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRenderImage</span><span class="params">(RenderTexture src, RenderTexture dest)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        material.<span class="built_in">SetFloat</span>(<span class="string">&quot;_DepthOfField&quot;</span>, _DepthOfField);</span><br><span class="line">        material.<span class="built_in">SetFloat</span>(<span class="string">&quot;_FocusDistance&quot;</span>, _FocusDistance);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> width = (<span class="type">int</span>)(src.width/ _DownSample);</span><br><span class="line">        <span class="type">int</span> height = (<span class="type">int</span>)(src.height/ _DownSample);</span><br><span class="line">        </span><br><span class="line">        RenderTexture RT1 = RenderTexture.<span class="built_in">GetTemporary</span>(width, height);</span><br><span class="line">        RenderTexture RT2 = RenderTexture.<span class="built_in">GetTemporary</span>(width, height);</span><br><span class="line">        </span><br><span class="line">        material.<span class="built_in">SetVector</span>(<span class="string">&quot;_BlurOffset&quot;</span>, <span class="keyword">new</span> <span class="built_in">Vector4</span>(_BlurRadius / wdith, _BlurRadius / height, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        Graphics.<span class="built_in">Blit</span>(src,RT1,material,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt;_Iteration;i++)&#123;</span><br><span class="line">            RenderTexture.<span class="built_in">ReleaseTemporary</span>(RT2);</span><br><span class="line">            width /= <span class="number">2</span>;</span><br><span class="line">            height /= <span class="number">2</span>;</span><br><span class="line">            RT2 = RenderTexture.<span class="built_in">GetTemporary</span>(width, height);</span><br><span class="line">            Graphics.<span class="built_in">Blit</span>(RT1,RT2,material,<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            RenderTexture.<span class="built_in">ReleaseTemporary</span>(RT1);</span><br><span class="line">            width /= <span class="number">2</span>;</span><br><span class="line">            height /= <span class="number">2</span>;</span><br><span class="line">            RT1 = RenderTexture.<span class="built_in">GetTemporary</span>(width, height);</span><br><span class="line">            Graphics.<span class="built_in">Blit</span>(RT2,RT1,material,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt;_Iteration;i++)&#123;</span><br><span class="line">            RenderTexture.<span class="built_in">ReleaseTemporary</span>(RT2);</span><br><span class="line">            width *= <span class="number">2</span>;</span><br><span class="line">            height *= <span class="number">2</span>;</span><br><span class="line">            RT2 = RenderTexture.<span class="built_in">GetTemporary</span>(width, height);</span><br><span class="line">            Graphics.<span class="built_in">Blit</span>(RT1,RT2,material,<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            RenderTexture.<span class="built_in">ReleaseTemporary</span>(RT1);</span><br><span class="line">            width *= <span class="number">2</span>;</span><br><span class="line">            height *= <span class="number">2</span>;</span><br><span class="line">            RT1 = RenderTexture.<span class="built_in">GetTemporary</span>(width, height);</span><br><span class="line">            Graphics.<span class="built_in">Blit</span>(RT2,RT1,material,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        material.<span class="built_in">SetTexture</span>(<span class="string">&quot;_BlurTex&quot;</span>,RT1);</span><br><span class="line">        Graphics.<span class="built_in">Blit</span>(src,dest,material,<span class="number">1</span>);</span><br><span class="line">        RenderTexture.<span class="built_in">ReleaseTemporary</span>(RT1);</span><br><span class="line">        RenderTexture.<span class="built_in">ReleaseTemporary</span>(RT2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见在实际操作中，为了获得好的模糊效果，是在第一个pass中完成多次的降采样与卷积，然后在第二个pass中进行mask的提取与插值</p>
<p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221004235732752.png" alt="image-20221004235732752"></p>
<h2 id="四、高级景深效果思路拓展"><a href="#四、高级景深效果思路拓展" class="headerlink" title="四、高级景深效果思路拓展"></a>四、高级景深效果思路拓展</h2><p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221005000034529.png" alt="image-20221005000034529"></p>
<h3 id="颜色泄露"><a href="#颜色泄露" class="headerlink" title="颜色泄露"></a>颜色泄露</h3><p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221005000123337.png" alt="image-20221005000123337"></p>
<h3 id="模糊不连续缺陷"><a href="#模糊不连续缺陷" class="headerlink" title="模糊不连续缺陷"></a>模糊不连续缺陷</h3><p>焦点在背景时，前景会被截断——前后景分离</p>
<p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221005000357241.png" alt="image-20221005000357241"></p>
<h3 id="散景的模拟"><a href="#散景的模拟" class="headerlink" title="散景的模拟"></a>散景的模拟</h3><p><img src="/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/image-20221005000627815.png" alt="image-20221005000627815"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li>实现景深效果</li>
<li>分析官方后处理插件PPS中的景深实现</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dv411u7KA">https://www.bilibili.com/video/BV1dv411u7KA</a>  </p>
<p>【技术美术百人计划】图形 4.5 Dof景深基础</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/04/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.5%20Dof%E6%99%AF%E6%B7%B1%E5%9F%BA%E7%A1%80/" data-id="cmfe8hf4f004s9wuh0wr1gbq3" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形4.4抗锯齿概述" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/10/04/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.4%E6%8A%97%E9%94%AF%E9%BD%BF%E6%A6%82%E8%BF%B0/">【笔记】【百人计划】图形4.4 抗锯齿概述</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/10/04/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.4%E6%8A%97%E9%94%AF%E9%BD%BF%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2022-10-04T12:42:00.000Z" itemprop="datePublished">2022-10-04</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形4-4-抗锯齿概述"><a href="#图形4-4-抗锯齿概述" class="headerlink" title="图形4.4 抗锯齿概述"></a>图形4.4 抗锯齿概述</h2><h2 id="一、锯齿的产生"><a href="#一、锯齿的产生" class="headerlink" title="一、锯齿的产生"></a>一、锯齿的产生</h2><p><img src="/%E5%9B%BE%E5%BD%A24.4%20%E6%8A%97%E9%94%AF%E9%BD%BF%E6%A6%82%E8%BF%B0/image-20221004205004631.png" alt="image-20221004205004631"></p>
<h2 id="二、基本的抗锯齿"><a href="#二、基本的抗锯齿" class="headerlink" title="二、基本的抗锯齿"></a>二、基本的抗锯齿</h2><h3 id="MSAA"><a href="#MSAA" class="headerlink" title="MSAA"></a>MSAA</h3><p><img src="/%E5%9B%BE%E5%BD%A24.4%20%E6%8A%97%E9%94%AF%E9%BD%BF%E6%A6%82%E8%BF%B0/image-20221004205207193.png" alt="image-20221004205207193"></p>
<h3 id="SSAA"><a href="#SSAA" class="headerlink" title="SSAA"></a>SSAA</h3><p><img src="/%E5%9B%BE%E5%BD%A24.4%20%E6%8A%97%E9%94%AF%E9%BD%BF%E6%A6%82%E8%BF%B0/image-20221004205116428.png" alt="image-20221004205116428"></p>
<p>(这个实例图好像有哪里不对劲，意思到了就行了)</p>
<h3 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a>TAA</h3><ul>
<li>把每次采样过程分布到每一帧去，每一帧都平均前面几帧保存下来的数据</li>
<li>每一帧会有一定的偏移，继承了MSAA采样</li>
<li>用Motion Vector保存每帧移动的偏移</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A24.4%20%E6%8A%97%E9%94%AF%E9%BD%BF%E6%A6%82%E8%BF%B0/image-20221004205308465.png" alt="image-20221004205308465"></p>
<h3 id="FXAA"><a href="#FXAA" class="headerlink" title="FXAA"></a>FXAA</h3><p>FXAA快速近似抗锯齿（Fast Approximate Anti-Aliasing）</p>
<ul>
<li>利用边缘检测进行有效的模糊混合</li>
<li>在后处理完成，不依赖硬件支持</li>
</ul>
<p>抗锯齿速度排序</p>
<ol>
<li>FXAA</li>
<li>TAA</li>
<li>MSAA</li>
<li>SSAA</li>
</ol>
<h2 id="三、更多的抗锯齿"><a href="#三、更多的抗锯齿" class="headerlink" title="三、更多的抗锯齿"></a>三、更多的抗锯齿</h2><ul>
<li>前向渲染<ul>
<li>SSAA</li>
<li>MSAA</li>
<li>CSAA</li>
<li>RGSS</li>
</ul>
</li>
<li>延迟渲染<ul>
<li>FXAA</li>
<li>MLAA</li>
<li>SMAA</li>
</ul>
</li>
<li>基于深度学习<ul>
<li>DLSS</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/106341932">https://zhuanlan.zhihu.com/p/106341932</a></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li>对比各个抗锯齿方案的优劣（效果、效率）</li>
<li>（有能力的可以进行各个方案真机测试）</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VR4y1J7KT">https://www.bilibili.com/video/BV1VR4y1J7KT</a> </p>
<p>【技术美术百人计划】图形 4.4 抗锯齿概论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/04/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.4%E6%8A%97%E9%94%AF%E9%BD%BF%E6%A6%82%E8%BF%B0/" data-id="cmfe8hf4f004p9wuhgi825y8o" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/GAMES/A Glimpse of Industrial Solutions" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/10/03/TA/Graphics/GAMES/A%20Glimpse%20of%20Industrial%20Solutions/">【笔记】【GAMES202】A Glimpse of Industrial Solutions</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/10/03/TA/Graphics/GAMES/A%20Glimpse%20of%20Industrial%20Solutions/" class="article-date">
  <time datetime="2022-10-02T17:41:51.000Z" itemprop="datePublished">2022-10-03</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="A-Glimpse-of-Industrial-Solutions"><a href="#A-Glimpse-of-Industrial-Solutions" class="headerlink" title="A Glimpse of Industrial Solutions"></a><strong>A Glimpse of Industrial Solutions</strong></h2><h3 id="Anti-aliasing"><a href="#Anti-aliasing" class="headerlink" title="Anti-aliasing"></a><strong>Anti-aliasing</strong></h3><h4 id="Temporal-Anti-Aliasing-TAA"><a href="#Temporal-Anti-Aliasing-TAA" class="headerlink" title="Temporal Anti-Aliasing(TAA)"></a><strong>Temporal Anti-Aliasing(TAA)</strong></h4><ul>
<li><p>Why aliasing</p>
<ul>
<li>光栅化中逐像素采样率不足</li>
<li>因此，终极解决方案是使用更多样本</li>
</ul>
</li>
<li><p>TAA</p>
<ul>
<li>复用上一帧的样本</li>
<li>Almost exactly the same as in RTRT</li>
</ul>
</li>
<li><p>Notes on AA</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002193628481.png" alt="image-20221002193628481"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002194058432.png" alt="image-20221002194058432"></p>
<h4 id="Temporal-Super-Resolution"><a href="#Temporal-Super-Resolution" class="headerlink" title="Temporal Super Resolution"></a><strong>Temporal Super Resolution</strong></h4><ul>
<li>Super resolution(super sampling)<ul>
<li>Literal understanding: increasing resolution</li>
<li>Source 1(DLSS 1.0): out of nowhere&#x2F;completely guessed</li>
<li>Source 2(DLSS 2.0): from temporal information</li>
<li>Key idea of DLSS 2.0<ul>
<li>TAA-like application</li>
<li>Temporally reuse samples to increase resolution</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Super-sampling-and-DLSS"><a href="#Super-sampling-and-DLSS" class="headerlink" title="Super sampling and DLSS"></a><strong>Super sampling and DLSS</strong></h3><ul>
<li>DLSS2.0 Main Problem<ul>
<li>Upon temporal failure, clamping is no longer an option</li>
<li>Because we need a clear value for each smaller pixel</li>
<li>Key is <strong>how to use temporal info</strong> smarter than clamping</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002195029254.png" alt="image-20221002195029254"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002195128656.png" alt="image-20221002195128656"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002195713542.png" alt="image-20221002195713542"></p>
<h3 id="Deferred-Shading"><a href="#Deferred-Shading" class="headerlink" title="Deferred Shading"></a><strong>Deferred Shading</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002200002876.png" alt="image-20221002200002876"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002200406831.png" alt="image-20221002200406831"></p>
<h3 id="Tiled-Shading"><a href="#Tiled-Shading" class="headerlink" title="Tiled Shading"></a><strong>Tiled Shading</strong></h3><ul>
<li>Improvement: tiled shading<ul>
<li>subdivide the screen into tiles</li>
</ul>
</li>
<li>Key observation<ul>
<li>Not all lights can illuminate a specific tile</li>
<li>Mostly due to the <strong>square falloff with distance</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002200639721.png" alt="image-20221002200639721"></p>
<h4 id="Clustered-Shading"><a href="#Clustered-Shading" class="headerlink" title="Clustered Shading"></a><strong>Clustered Shading</strong></h4><p>除了屏幕空间的分块，还要在深度上分割</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002200758956.png" alt="image-20221002200758956"></p>
<h3 id="LoD-solutions"><a href="#LoD-solutions" class="headerlink" title="LoD solutions"></a><strong>LoD solutions</strong></h3><ul>
<li>Choosing the right lod to use can save computation</li>
<li>The use of multiple lod<ul>
<li>Called “Cascaded” by the RTR industry</li>
</ul>
</li>
<li>EX:<ul>
<li>Cascaded shadow maps</li>
<li>Cascaded LPV</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002201617049.png" alt="image-20221002201617049"></p>
<ul>
<li>Key challenge<ul>
<li>Transition between different Levels</li>
<li>Usually need some &#x3D;&#x3D;overlapping and blending&#x3D;&#x3D; near boundaries</li>
</ul>
</li>
<li>Another Example: Geometric LOD<ul>
<li>生成一套不同三角面数的简化的模型</li>
<li>基于相机距离选择合适的物体(or part of obj, s.t. no triangle  will be larger than a pixel)</li>
<li>Popping artifacts（突然出现）——leave it to TAA</li>
<li>Nanite in UE5（动态选取Lod）</li>
<li>Technical difficulties<ul>
<li>不同的部位使用不同层级，如何处理接缝cracks?</li>
<li>动态加载(load)和调度(schedule)不同层级，如何最好地利用缓存(cache)和带宽(bandwidth)？</li>
<li>Representing geometry using triangles or geometry textures(几何纹理)</li>
<li>Clipping and culling for faster performance</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="GI-Solutions"><a href="#GI-Solutions" class="headerlink" title="GI Solutions"></a><strong>GI Solutions</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002202736585.png" alt="image-20221002202736585"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002202944302.png" alt="image-20221002202944302"></p>
<h3 id="Uncovered-Topic"><a href="#Uncovered-Topic" class="headerlink" title="Uncovered Topic"></a><strong>Uncovered Topic</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002203533485.png" alt="image-20221002203533485"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/03/TA/Graphics/GAMES/A%20Glimpse%20of%20Industrial%20Solutions/" data-id="cmfe8hf4h00559wuhc7h3653b" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Advanced/" rel="tag">CG Advanced</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAMES/" rel="tag">GAMES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/GAMES/Real-time Ray Tracing" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/10/03/TA/Graphics/GAMES/Real-time%20Ray%20Tracing/">【笔记】【GAMES202】Real-time Ray Tracing实时光线追踪</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/10/03/TA/Graphics/GAMES/Real-time%20Ray%20Tracing/" class="article-date">
  <time datetime="2022-10-02T17:41:22.000Z" itemprop="datePublished">2022-10-03</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="Real-time-Ray-Tracing实时光线追踪"><a href="#Real-time-Ray-Tracing实时光线追踪" class="headerlink" title="Real-time Ray Tracing实时光线追踪"></a><strong>Real-time Ray Tracing实时光线追踪</strong></h2><h3 id="1-Real-time-Ray-Tracing实时光线追踪"><a href="#1-Real-time-Ray-Tracing实时光线追踪" class="headerlink" title="1. Real-time Ray Tracing实时光线追踪"></a><strong>1. Real-time Ray Tracing实时光线追踪</strong></h3><p>2018年，NVIDIA发布GeForce RTX系列（Turing架构）</p>
<p>RTX在硬件上可以发射10 Giga rays per second（RT core）</p>
<p>但是在实际应用中只能做到 1 sample per pixel。</p>
<p>1SPP path tracing &#x3D;</p>
<ul>
<li>1 rasterization(primary) + (实际用光栅化方法来代替第一条光线)</li>
<li>1ray(primary visibility)  +</li>
<li>1ray(secondary bounce)+</li>
<li>1ray(secondary visibility)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531004928902.png" alt="image-20220531004928902"></p>
<p>1SPP存在极大噪声，RTRT关键部分在于&#x3D;&#x3D;Denoising降噪&#x3D;&#x3D; 。</p>
<h4 id="Basic-idea"><a href="#Basic-idea" class="headerlink" title="Basic idea"></a><strong>Basic idea</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531005843306.png" alt="image-20220531005843306"></p>
<p>工业界的解决方案中最重要的是Temporal滤波</p>
<ul>
<li>关键思路：<ul>
<li>假设当前帧的前一阵是降噪的，因此可以复用。</li>
<li>使用motion vectors来找到前一帧的对应位置。</li>
<li>用上一帧的结果来计算当前帧结果。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531010312714.png" alt="image-20220531010312714"></p>
<h4 id="Motion-Vector"><a href="#Motion-Vector" class="headerlink" title="Motion Vector"></a><strong>Motion Vector</strong></h4><h5 id="G-Buffers（Geometry-buffer）"><a href="#G-Buffers（Geometry-buffer）" class="headerlink" title="G-Buffers（Geometry buffer）"></a><strong>G-Buffers（Geometry buffer）</strong></h5><p>在渲染过程中，可以获得一些额外的信息，如每像素的深度、法线、世界坐标等。生成G-buffer是比较容易的，只有屏幕空间信息。</p>
<h5 id="Back-Projection"><a href="#Back-Projection" class="headerlink" title="Back Projection"></a><strong>Back Projection</strong></h5><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531010731693.png" alt="image-20220531010731693"></p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531011038829.png" alt="image-20220531011038829" style="zoom:100%;" />

<p>x’就是当前帧像素对应的世界坐标位置对应到上一帧该位置所在的像素。</p>
<h4 id="Temporal-accumulation-filtering"><a href="#Temporal-accumulation-filtering" class="headerlink" title="Temporal accumulation&#x2F;filtering"></a><strong>Temporal accumulation&#x2F;filtering</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531011719293.png" alt="image-20220531011719293"></p>
<p>在这种1spp的结果下，回顾蒙特卡洛路径追踪，它的结果应该是无偏的，之所以看起来暗，是因为有很多的采样点原本的值是非常大的，但在显示器的clamp下，变成了1（255），因此看起来暗了。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531011848928.png" alt="image-20220531011848928" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531012013416.png" alt="image-20220531012013416" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531012109486.png" alt="image-20220531012109486" style="zoom:67%;" />

<h4 id="Failure-cases"><a href="#Failure-cases" class="headerlink" title="Failure cases"></a><strong>Failure cases</strong></h4><h5 id="Switching-scenes（burn-in-period）"><a href="#Switching-scenes（burn-in-period）" class="headerlink" title="Switching scenes（burn-in period）"></a><strong>Switching scenes（burn-in period）</strong></h5><p>切换场景、快速的镜头切换</p>
<h5 id="Walking-backwards-in-a-hallway（screen-space-issue）"><a href="#Walking-backwards-in-a-hallway（screen-space-issue）" class="headerlink" title="Walking backwards in a hallway（screen space issue）"></a><strong>Walking backwards in a hallway（screen space issue）</strong></h5><p>镜头中的信息是增加的</p>
<h5 id="Suddenly-appearing-background（disocclusion）"><a href="#Suddenly-appearing-background（disocclusion）" class="headerlink" title="Suddenly appearing background（disocclusion）"></a><strong>Suddenly appearing background（disocclusion）</strong></h5><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531012552050.png" alt="image-20220531012552050"></p>
<p>造成拖尾（Lagging）的结果</p>
<h5 id="More-Temporal-Failure"><a href="#More-Temporal-Failure" class="headerlink" title="More Temporal Failure"></a><strong>More Temporal Failure</strong></h5><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531013222285.png" alt="image-20220531013222285"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531013349160.png" alt="image-20220531013349160"></p>
<h4 id="Adjustments-to-Temp-Failure"><a href="#Adjustments-to-Temp-Failure" class="headerlink" title="Adjustments to Temp. Failure"></a><strong>Adjustments to Temp. Failure</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531012830984.png" alt="image-20220531012830984"></p>
<h3 id="2-Filtering-techniques-and-implementation"><a href="#2-Filtering-techniques-and-implementation" class="headerlink" title="2. Filtering techniques and implementation"></a><strong>2. Filtering techniques and implementation</strong></h3><h4 id="Implementation-of-filtering"><a href="#Implementation-of-filtering" class="headerlink" title="Implementation of filtering"></a><strong>Implementation of filtering</strong></h4><ul>
<li>图像低通滤波<ul>
<li>消除了高频信号</li>
<li>只关注频域（Spatial domain）</li>
</ul>
</li>
<li>图像+滤波器（filter kernel）-&gt;输出图像</li>
<li>Gaussian filter<ul>
<li>对于任何像素取周围范围的贡献，基于像素和周围的距离</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531142014296.png" alt="image-20220531142014296"></p>
<ul>
<li>Bilateral FIltering<ul>
<li>背景<ul>
<li>Gaussian filtering 出现的问题是整体模糊，包括边缘</li>
<li>但是我们希望边界能够保持高频</li>
<li>边界&lt;-&gt;理解为颜色剧烈变化的部分</li>
</ul>
</li>
<li>思路<ul>
<li>如何保留边界</li>
<li>如果像素j和i相差特别大，就让j对i的贡献减少</li>
<li>只需要控制kernel</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531144557877.png" alt="image-20220531144557877"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002143754221.png" alt="image-20221002143754221"></p>
<p>问题：如果噪声本来颜色差异就比较大，无法区分这部分噪声和边界。</p>
<h4 id="Cross-Joint-bilateral-filtering"><a href="#Cross-Joint-bilateral-filtering" class="headerlink" title="Cross &#x2F; Joint bilateral filtering"></a><strong>Cross &#x2F; Joint bilateral filtering</strong></h4><ul>
<li>Gaussian filtering以距离作为标准</li>
<li>Bilateral filtering用位置距离、颜色距离作为标准</li>
<li>联合双边滤波采用更多的标准<ul>
<li>G-buffers<ul>
<li>Normal,depth,position,object ID,etc</li>
</ul>
</li>
<li>G-buffers是没有噪声的。</li>
</ul>
</li>
<li>特别适用于路径追踪的降噪</li>
<li>Gaussian函数不是唯一的选择，任何随“距离”衰减的函数都可以，如Exponential（absolute），cosine（clamped）</li>
</ul>
<p><img src="/Real-time%20Ray%20Tracing/image-20221002145335668.png" alt="image-20221002145335668"></p>
<h4 id="Implementing-Large-filters"><a href="#Implementing-Large-filters" class="headerlink" title="Implementing Large filters"></a><strong>Implementing Large filters</strong></h4><p>对于Kernel过大的情况</p>
<ul>
<li>Separate Passes<ul>
<li>对于2D Gaussian filter</li>
<li>将它分成水平的pass和竖直的pass(N^2 -&gt;N+N)</li>
<li>2D Gaussian filter kernel is separable</li>
<li>$G_{2D}(x,y)&#x3D;G_{1D}(x) \cdot G_{1D}(y)$</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531152145590.png" alt="image-20220531152145590"></p>
<p>理论上双边滤波不能拆分实现。</p>
<ul>
<li>Progressively Growing Size<ul>
<li>用逐步增大filter进行多次滤波</li>
<li>为什么要用逐步增大的filter   <ul>
<li>去除更低的频率</li>
</ul>
</li>
<li>为什么可以跳过一些samples<ul>
<li>Sampling&#x3D; repeating the spectrum</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531152445354.png" alt="image-20220531152445354"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531153055367.png" alt="image-20220531153055367"></p>
<h4 id="Outlier-removal（and-temporal-clamping）"><a href="#Outlier-removal（and-temporal-clamping）" class="headerlink" title="Outlier removal（and temporal clamping）"></a><strong>Outlier removal（and temporal clamping）</strong></h4><p>滤波后结果中还是会有一些特别亮的outlier（本来需要等更多的sample）</p>
<ul>
<li>在滤波前去除outlier</li>
<li>Outlier detection<ul>
<li>计算像素neighbor的均值和方差</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531154410403.png" alt="image-20220531154410403"></p>
<ul>
<li>Outlier removal</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531154735195.png" alt="image-20220531154735195"></p>
<ul>
<li>Temporal Clamping</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220531155436586.png" alt="image-20220531155436586"></p>
<h3 id="3-Specific-filtering-approaches-for-RTRT"><a href="#3-Specific-filtering-approaches-for-RTRT" class="headerlink" title="3. Specific filtering approaches for RTRT"></a><strong>3. Specific filtering approaches for RTRT</strong></h3><h4 id="Spatiotemporal-Variance-Guided-Filtering（SVGF）"><a href="#Spatiotemporal-Variance-Guided-Filtering（SVGF）" class="headerlink" title="Spatiotemporal Variance-Guided Filtering（SVGF）"></a><strong>Spatiotemporal Variance-Guided Filtering（SVGF）</strong></h4><ul>
<li>similar to the basic spatio-temporal denoising scheme</li>
<li>with some additional variance analysis and tricks</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002154314018.png" alt="image-20221002154314018"></p>
<ul>
<li><p>Joint Bilateral Filtering</p>
</li>
<li><p>3 factors</p>
<ul>
<li><p>Depth</p>
<ul>
<li>$w_z&#x3D;\exp(-\frac{|z(p)-z(q)|}{\sigma_z|\nabla z(p)\cdot(p-q)|+\epsilon})$</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002154947127.png" alt="image-20221002154947127"></li>
</ul>
</li>
<li><p>Normal</p>
<ul>
<li>$$<br>w_n&#x3D;\max(0,n(p)\cdot n(q))^{\sigma_n}<br>$$</li>
</ul>
</li>
<li><p>Luminance(grayscale color value)</p>
<ul>
<li><p>$$<br>w_l&#x3D;\exp(-\frac{|l_i(p)-l_i(q)|}{\sigma_l\sqrt{g_{3\times3}(Var(l_i(p)))}+\epsilon})<br>$$</p>
</li>
<li><p>Variance</p>
<ul>
<li>Calculate spatially in 7x7</li>
<li>Also averaged over time using motion vectors</li>
<li>Take another 3x3 spatial filter before use</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Recurrent-AutoEncoder-RAE"><a href="#Recurrent-AutoEncoder-RAE" class="headerlink" title="Recurrent AutoEncoder(RAE)"></a><strong>Recurrent AutoEncoder(RAE)</strong></h4><p>Interactive Reconstruction of Monte Carlo Image Sequences using a Recurrent denoising Auto Encoder</p>
<ul>
<li>A post-processing network that does denoising</li>
<li>with the help of G-buffers</li>
<li>The network automatically performs temporal accumulation</li>
</ul>
<p>Key architecture design</p>
<ul>
<li><p>Auto Encoder(or U-Net) structure</p>
</li>
<li><p>Recurrent convolutional block</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002175327278.png" alt="image-20221002175327278" style="zoom:50%;" />


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/03/TA/Graphics/GAMES/Real-time%20Ray%20Tracing/" data-id="cmfe8hf4i005b9wuhc315g2pg" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Advanced/" rel="tag">CG Advanced</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAMES/" rel="tag">GAMES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/GAMES/Real-time Physically-Based Materials" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/10/02/TA/Graphics/GAMES/Real-time%20Physically-Based%20Materials/">【笔记】【GAMES202】Real-time Physically-Based Materials(Surface models)</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/10/02/TA/Graphics/GAMES/Real-time%20Physically-Based%20Materials/" class="article-date">
  <time datetime="2022-10-02T05:58:43.000Z" itemprop="datePublished">2022-10-02</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="Real-time-Physically-Based-Materials-Surface-models"><a href="#Real-time-Physically-Based-Materials-Surface-models" class="headerlink" title="Real-time Physically-Based Materials(Surface models)"></a><strong>Real-time Physically-Based Materials(Surface models)</strong></h2><h3 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a><strong>PBR</strong></h3><h4 id="PBR与PBR材质"><a href="#PBR与PBR材质" class="headerlink" title="PBR与PBR材质"></a><strong>PBR与PBR材质</strong></h4><ul>
<li><p>PBR</p>
<ul>
<li>一切基于物理，如材质、光照、相机、light transport等</li>
<li>不仅限于材质，但通常指材质</li>
</ul>
</li>
<li><p>RTR中的PBR</p>
<ul>
<li>实时渲染的材质种类、准确度等是不如离线的</li>
<li>实时渲染的PB通常并不真的physically based</li>
</ul>
</li>
</ul>
<h4 id="RTR中的PBR材质"><a href="#RTR中的PBR材质" class="headerlink" title="RTR中的PBR材质"></a><strong>RTR中的PBR材质</strong></h4><ul>
<li>Surface<ul>
<li>大部分是微表面模型（使用错误，所以不太PBR）与Disney原则的BRDF（美术友好，但也不太PBR）</li>
</ul>
</li>
<li>Volumes<ul>
<li>大部分关注性能和近似的single&#x2F;multiple scattering（云、头发、皮肤等）</li>
</ul>
</li>
<li>通常在使用上会使用很多hacks，并且非常关注性能</li>
</ul>
<h3 id="Microfacet-BRDF微表面BRDF"><a href="#Microfacet-BRDF微表面BRDF" class="headerlink" title="Microfacet BRDF微表面BRDF"></a><strong>Microfacet BRDF微表面BRDF</strong></h3><p>在GAMES101中根据微表面模型提出了以下的BRDF模型吧<br>$$<br>f(i,o)&#x3D;\frac{F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)}<br>$$</p>
<h4 id="Fresnel"><a href="#Fresnel" class="headerlink" title="Fresnel"></a><strong>Fresnel</strong></h4><ul>
<li>反射随着grazing angle（掠射角）增加会增多</li>
</ul>
<p>在物理上需要考虑光线的极化-s极化与p极化</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220928111429350.png" alt="image-20220928111429350"></p>
<ul>
<li>近似-Schlick’s approx<br>$$<br>R(\theta)&#x3D;R_0+(1-R_0)(1-\cos\theta)^5<br>\R_0&#x3D;(\frac{n_1-n_2}{n_1+n_2})^2<br>$$</li>
</ul>
<h4 id="Normal-Distribution-Function"><a href="#Normal-Distribution-Function" class="headerlink" title="Normal Distribution Function"></a><strong>Normal Distribution Function</strong></h4><p>描述微表面的法线分布</p>
<ul>
<li><p>法线集中</p>
<ul>
<li>Glossy-specular</li>
</ul>
</li>
<li><p>法线分散</p>
<ul>
<li>Diffuse</li>
</ul>
</li>
<li><p>常用的法线分布函数模型</p>
<ul>
<li>Bechmann</li>
<li>GGX</li>
<li>其他Detailed Model</li>
</ul>
</li>
</ul>
<h5 id="Bechmann-NDF"><a href="#Bechmann-NDF" class="headerlink" title="Bechmann NDF"></a><strong>Bechmann NDF</strong></h5><p>$$<br>D(h)&#x3D;\frac{e^{-\frac{\tan^2\theta_h}{\alpha^2}}}{\pi\alpha^2\cos^4\theta_h}<br>$$</p>
<ul>
<li>$\alpha$: roughness</li>
<li>$\theta_h$ : 半程向量h与法线夹角</li>
<li>近似于用高斯函数来建立模型，alpha描述了标准差，也即光滑程度</li>
<li>分母归一化保证了projected solid angle的积分域为1</li>
<li>定义在slope space（坡度空间）上<ul>
<li>高斯函数的surpport（支撑集） 是无限大的，但可以映射到-90~90度的空间</li>
</ul>
</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220928114334006.png" alt="image-20220928114334006"></li>
<li>描述的是各向同性的结果</li>
</ul>
<h5 id="GGX（Trowbridge-Reitz）"><a href="#GGX（Trowbridge-Reitz）" class="headerlink" title="GGX（Trowbridge-Reitz）"></a><strong>GGX（Trowbridge-Reitz）</strong></h5><ul>
<li>Long tail(拖尾表现更好)</li>
<li>过渡渐变看起来更自然</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001172957712.png" alt="image-20221001172957712" style="zoom:50%;" />



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001174745586.png" alt="image-20221001174745586"></p>
<h5 id="Extending-GGX-GTR"><a href="#Extending-GGX-GTR" class="headerlink" title="Extending GGX(GTR)"></a><strong>Extending GGX(GTR)</strong></h5><ul>
<li>GTR（Generalized Trowbridge-Reitz）</li>
<li>更长的拖尾</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001175309985.png" alt="image-20221001175309985"></p>
<h4 id="Shadowing-Masking-Term"><a href="#Shadowing-Masking-Term" class="headerlink" title="Shadowing-Masking Term"></a><strong>Shadowing-Masking Term</strong></h4><ul>
<li>Geometry term G（几何遮蔽项）</li>
<li>表示微表面自遮挡的数量，表现为入射光线被遮挡产生shadow，反射到眼睛的光线被遮挡为mask<ul>
<li>Shadowing-light</li>
<li>Masking-eye</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001180224677.png" alt="image-20221001180224677"></p>
<ul>
<li>为什么需要几何遮蔽项<ul>
<li>考虑如果没有G项，掠射角的入射和出射会发生什么？</li>
<li>根据Fresnel，在掠射部分的反射会变成1，</li>
<li>BRDF分母接近0，最后的结果是在边缘部分接近白色，这是不合理的。</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001181331248.png" alt="image-20221001181331248"></li>
</ul>
</li>
</ul>
<h5 id="Smith-Shadowing-masking-term"><a href="#Smith-Shadowing-masking-term" class="headerlink" title="Smith Shadowing-masking term"></a><strong>Smith Shadowing-masking term</strong></h5><p>假设法线为一种统计学分布模型，</p>
<ul>
<li>将shadowing和masking的部分分开考虑</li>
<li>假设$G(i,o,m)\simeq G_1(i,m)G_1(o,m)$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001182858495.png" alt="image-20221001182858495"></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h4><ul>
<li>在Multiple Bounces（多次弹射）中产生的能量损失（在粗糙度高时更明显）</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001183353105.png" alt="image-20221001183353105" style="zoom:50%;" />

<p>（如下图）在仅有的Uniform的全局光照下去照亮物体，对于specular的物体发生的正确反射，导致和背景融为一体。(<strong>白炉测试</strong>)</p>
<p>Roughness的部分会使反射光更容易被遮挡。因此在实际光线多次发生Bounce的过程中，只考虑一次Bounce，会导致能量损失</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001183951640.png" alt="image-20221001183951640"></p>
<ul>
<li>Accurate methods[Heitz et al. 206]</li>
<li>在实时渲染中较慢</li>
<li>Basic idea<ul>
<li>Being occluded &#x3D; next bounce happening</li>
<li>被遮挡代表着下一次弹射发生</li>
</ul>
</li>
</ul>
<h4 id="Kulla-county-Approx"><a href="#Kulla-county-Approx" class="headerlink" title="Kulla-county Approx"></a><strong>Kulla-county Approx</strong></h4><p><a target="_blank" rel="noopener" href="https://fpsunflower.github.io/ckulla/data/s2017_pbs_imageworks_slides_v2.pdf">https://fpsunflower.github.io/ckulla/data/s2017_pbs_imageworks_slides_v2.pdf</a></p>
<ul>
<li><p>依据经验来补全多次反射的能量</p>
</li>
<li><p>2D BRDF lobe中出射的总能量<br>$$<br>E(\mu_0)&#x3D;\int^{2\pi}_0\int^1_0f(\mu_o,\mu_i,\phi)\mu_id\mu_id\phi<br>\\mu&#x3D;\sin\theta<br>$$</p>
</li>
</ul>
<p>在上式中注意$\mu d\mu d\phi$ 的部分，换成$\sin\theta$ ，即$\cos\theta\sin\theta d\theta d\phi$ ，也即球面参数化（$\theta$, $\phi$）的表达。</p>
<ul>
<li>丢失的能量<ul>
<li>我们可以设计一个 additiional lobe，使得这部分积分为$1-E(\mu_o)$ </li>
<li>出射的BRDF lobe和入射方向是不同的</li>
<li>考虑交换性，可以是如下形式$c(1-E(\mu_i))(1-E(\mu_o))$</li>
</ul>
</li>
</ul>
<p>$$<br>f_{ms}(\mu_o,\mu_i)&#x3D;\frac{(1-E(\mu_i))(1-E(\mu_o))}{\pi(1-E_{avg})}<br>\E_{avg}&#x3D;2\int_0^1E(\mu)\mu d\mu<br>$$</p>
<ul>
<li>$E_{avg}$ 的处理<ul>
<li>对于复杂的积分，在split sum中，我们的处理方式是——precompute&#x2F;tabulate预计算或制表</li>
<li>$E_{avg}$ 的维度是多少 &#x2F; $E_{avg}$ 有多少参数<ul>
<li>只需考虑$\mu_0$ 和roughness</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001194632992.png" alt="image-20221001194632992"></p>
<ul>
<li>验证</li>
</ul>
<p>$$<br>E_{ms}(\mu_o)&#x3D;\int^{2\pi}<em>0\int^1_0f</em>{ms}(\mu_o,\mu_i,\phi)\mu_id\mu_id\phi<br>\&#x3D;2\pi\int^1_0\frac{(1-E(\mu_i))(1-E(\mu_o))}{\pi(1-E_{avg})}\mu_id\mu_i<br>\&#x3D;2\frac{1-E(\mu_o)}{1-E_{avg}}\int_0^1(1-E(\mu_i))\mu_id\mu_i<br>\&#x3D;\frac{1-E(\mu_o)}{1-E_{avg}}(1-E_{avg})<br>\&#x3D;1-E(\mu_o)<br>$$</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001194824094.png" alt="image-20221001194824094"></p>
<ul>
<li>以上的内容基于没有颜色（白色）的BRDF</li>
<li>但如果考虑其他颜色，也就代表着光线能量的吸收，也即能量的减少（损失）<ul>
<li>因此我们只需要计算整体的能量损失</li>
</ul>
</li>
<li>定义Average Fresnel平均菲涅尔<ul>
<li>忽略入射角每次反射平均反射的能量</li>
</ul>
</li>
</ul>
<p>$$<br>F_{avg}&#x3D;\frac{f_0^1F(\mu)\mu d\mu}{f_0^1\mu d\mu}&#x3D;2\int_0^1F(\mu)\mu d\mu<br>$$</p>
<p>而$E_{avg}$ 代表我们能看到的能量（不参与多次bounce）</p>
<p>所以最后的能量可以分类为：</p>
<ul>
<li>直接看到的能量$F_{avg}E_{avg}$</li>
<li>一次弹射后被看到的能量$F_{avg}(1-E_{avg})F_{avg}E_{avg}$</li>
<li>….</li>
<li>k次弹射后被看到的能量$F_{avg}^k(1-E_{avg})^kF_{avg}E_{avg}$</li>
</ul>
<p>相加起来的级数求和（这一部分直接和没有颜色的BRDF相乘）<br>$$<br>\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001200140171.png" alt="image-20221001200140171"></p>
<p>再来解释一遍带颜色的多次弹射的能量损失。</p>
<p>我们之间所做的计算都是基于没有颜色，也就是白色，也就是不吸收能量，所得到的结果。但是，如果物体存在颜色，也即会吸收能量，那么，在multi-bounces的过程中，每次弹射，都会吸收对应的能量，而我们用平均的菲涅尔来定义，这样就能忽略弹射的角度，而把所有的弹射加起来后，把这一部分由于颜色吸收能量带来的损失，和前面的乘起来，就是最后的结果。</p>
<h5 id="Undesirable-Hack"><a href="#Undesirable-Hack" class="headerlink" title="Undesirable Hack"></a><strong>Undesirable Hack</strong></h5><ul>
<li>将Microfacet BRDF和一个diffuse lobe结合起来（在CV中的材质识别普遍使用）</li>
<li>这是不科学的（Cook-Torrance BRDF就是这么干的）</li>
<li>微表面已经将表面解释成表面的某种分布了，又怎么会加上一部分的理想漫反射呢<ul>
<li>物理不正确，且能量不守恒</li>
<li>（但也有加上diffuse后保证能量守恒的处理方式，这肯定也是存在的）</li>
</ul>
</li>
</ul>
<h3 id="Linearly-Transformed-Cosines（LTC）"><a href="#Linearly-Transformed-Cosines（LTC）" class="headerlink" title="Linearly Transformed Cosines（LTC）"></a><strong>Linearly Transformed Cosines（LTC）</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001213010346.png" alt="image-20221001213010346"></p>
<p>线性变换余弦方法——多边形光照下的微表面BRDF着色</p>
<ul>
<li><p>解决microfacet model 的shading问题</p>
</li>
<li><p>主要基于GGX法线分布（其他模型也是可以的）</p>
</li>
<li><p>不考虑shadows</p>
</li>
<li><p>多边形光源</p>
</li>
<li><p>想法</p>
<ul>
<li>任意2D的BRDF lobe可以被线性变换为余弦</li>
<li>光源的形状也可以被变换</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001213451716.png" alt="image-20221001213451716" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<p>在cosine lobe上积分变换后的光源是有解析解的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001213822511.png" alt="image-20221001213822511"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221001213659851.png" alt="image-20221001213659851"></p>
<h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a><strong>做法</strong></h4><p>认为多边形光源内部发出的光是uniform的，即Li是相同的，即从任意位置观察的多边形光源的Li是相同的<br>$$<br>\omega_i&#x3D;\frac{M\omega_i’}{||M\omega_i’||}<br>\L(\omega_o)&#x3D;L_i\cdot \int_PF(\omega_i)d\omega_i<br>\&#x3D;L_i\cdot \int_P\cos(\omega_i’)d\frac{M\omega_i’}{||M\omega_i’||}<br>\&#x3D;L_i\cdot \int_{P’}\cos(\omega_i’)Jd \omega_i’<br>$$</p>
<h3 id="Disney-Principled-BRDF迪士尼原则的BRDF"><a href="#Disney-Principled-BRDF迪士尼原则的BRDF" class="headerlink" title="Disney Principled BRDF迪士尼原则的BRDF"></a><strong>Disney Principled BRDF迪士尼原则的BRDF</strong></h3><ul>
<li>微表面模型的缺陷<ul>
<li>微表面模型不适合表现真实的物理材质</li>
<li>微表面模型缺少diffuse项</li>
<li>解释不了多层的材质</li>
<li>基于物理的参数艺术上不好用<ul>
<li>反射率n-ik（复数）</li>
</ul>
</li>
</ul>
</li>
<li>Disney Principled BRDF<ul>
<li>Art directable, 不要求物理上正确</li>
<li>实时渲染中认为是PBR的</li>
<li>需要使用更直接的参数，使用尽可能少的参数</li>
<li>参数最好是0-1的。如果有必要，也最好允许能够超出这个范围</li>
<li>所有有关联的参数应该鲁棒且合理</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002112204105.png" alt="image-20221002112204105" style="zoom:50%;" />

<ul>
<li>sheen<ul>
<li>类似天鹅绒的光泽效果</li>
</ul>
</li>
<li>clearcoat<ul>
<li>清漆</li>
</ul>
</li>
</ul>
<h2 id="Non-Photorrealistic-rendering-NPR"><a href="#Non-Photorrealistic-rendering-NPR" class="headerlink" title="Non-Photorrealistic rendering(NPR)"></a><strong>Non-Photorrealistic rendering(NPR)</strong></h2><p>NPR——stylization（fast and reliable）</p>
<ul>
<li>来源于真实感渲染</li>
<li>利用抽象</li>
<li>强化重点</li>
</ul>
<p>应用</p>
<ul>
<li>艺术</li>
<li>可视化</li>
<li>指示说明</li>
<li>教育</li>
<li>娱乐</li>
</ul>
<p>风格化</p>
<ul>
<li>描边</li>
<li>阴影</li>
<li>色块</li>
<li>。。。</li>
</ul>
<h3 id="Outline-Rendering"><a href="#Outline-Rendering" class="headerlink" title="Outline Rendering"></a><strong>Outline Rendering</strong></h3><ul>
<li>描边不只是轮廓</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002121116909.png" alt="image-20221002121116909"></p>
<ul>
<li><p>Boundary</p>
</li>
<li><p>Crease</p>
<ul>
<li>折痕</li>
</ul>
</li>
<li><p>Material edge</p>
</li>
<li><p>Silhouette</p>
<ul>
<li>在物体外部轮廓上，要求有多个面共享的边界</li>
</ul>
</li>
</ul>
<h4 id="shading方法"><a href="#shading方法" class="headerlink" title="shading方法"></a><strong>shading方法</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002121509079.png" alt="image-20221002121509079"></p>
<ul>
<li>描边粗细不一致</li>
</ul>
<h4 id="Geometry方法"><a href="#Geometry方法" class="headerlink" title="Geometry方法"></a><strong>Geometry方法</strong></h4><p>背面渲染成黑色沿顶点法线外扩</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002121836905.png" alt="image-20221002121836905"></p>
<h4 id="postprocess方法"><a href="#postprocess方法" class="headerlink" title="postprocess方法"></a><strong>postprocess方法</strong></h4><p>图像边缘检测的方法</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002132828971.png" alt="image-20221002132828971" style="zoom:50%;" />

<h3 id="Color-blocks色块"><a href="#Color-blocks色块" class="headerlink" title="Color blocks色块"></a><strong>Color blocks色块</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002133535272.png" alt="image-20221002133535272"></p>
<ul>
<li>Hard shading： thresholding on shading</li>
<li>posterization： thresholding on final image</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002133741767.png" alt="image-20221002133741767"></p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002133857329.png" alt="image-20221002133857329" style="zoom: 67%;" />

<h3 id="Strokes-Surfaces-Stylization"><a href="#Strokes-Surfaces-Stylization" class="headerlink" title="Strokes Surfaces Stylization"></a><strong>Strokes Surfaces Stylization</strong></h3><ul>
<li>sketch</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002134051191.png" alt="image-20221002134051191" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20221002135210430.png" alt="image-20221002135210430" style="zoom:50%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/02/TA/Graphics/GAMES/Real-time%20Physically-Based%20Materials/" data-id="cmfe8hf4h00529wuh3fg4b3lu" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Advanced/" rel="tag">CG Advanced</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAMES/" rel="tag">GAMES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/Opengl learning_04" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/09/24/TA/OpenGL/Opengl%20learning_04/">【笔记】Cherno Opengl Tutorial note 04</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/09/24/TA/OpenGL/Opengl%20learning_04/" class="article-date">
  <time datetime="2022-09-24T08:54:56.000Z" itemprop="datePublished">2022-09-24</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="24-Setting-up-a-Test-Framework"><a href="#24-Setting-up-a-Test-Framework" class="headerlink" title="24 Setting up a Test Framework"></a><strong>24 Setting up a Test Framework</strong></h2><p>  这次我们要对代码进行一些整理，为之后做好铺垫。</p>
<p>因为如果我们想让系统变得更复杂的话，像这样做是不行的。</p>
<p>首先清理下代码的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;GlewInit fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line"></span><br><span class="line">    Renderer renderer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup Dear ImGui context</span></span><br><span class="line">    <span class="built_in">IMGUI_CHECKVERSION</span>();</span><br><span class="line">    ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">    ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup Platform/Renderer backends</span></span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(window, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        renderer.<span class="built_in">Clear</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">        ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">Render</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//glDeleteProgram(shader);//有析构函数</span></span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_Shutdown</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">    ImGui::<span class="built_in">DestroyContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后添加test</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test::TestClearColor test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">OnUpdate</span>(<span class="number">0.0f</span>);</span><br><span class="line">    test.<span class="built_in">OnRender</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">    ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">OnImGuiRender</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以看到如下结果</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917153535589.png" alt="image-20220917153535589" style="zoom:50%;" />

<p>test的部分结构如下</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917153643711.png" alt="image-20220917153643711"></p>
<p>Test.h</p>
<p>作为Test的父类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Test</span>() &#123;&#125;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Test</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TestClearColor.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">TestClearColor</span> : <span class="keyword">public</span> Test &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">TestClearColor</span>();</span><br><span class="line">		~<span class="built_in">TestClearColor</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">float</span> m_ClearColor[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//TestClearColor.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestClearColor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">	TestClearColor::<span class="built_in">TestClearColor</span>() </span><br><span class="line">		: m_ClearColor &#123;<span class="number">0.2f</span>,<span class="number">0.3f</span>,<span class="number">0.8f</span>,<span class="number">1.0f</span>&#125; &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TestClearColor::~<span class="built_in">TestClearColor</span>() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(m_ClearColor[<span class="number">0</span>],</span><br><span class="line">                            m_ClearColor[<span class="number">1</span>],m_ClearColor[<span class="number">2</span>],m_ClearColor[<span class="number">3</span>]));</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnImGuiRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Clear Color&quot;</span>, m_ClearColor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就建立好了test的架构。</p>
<p>其实基于这个架构，我们可以做很多事了，例如在imgui上用菜单控制各种变量、贴图。。。</p>
<p>接下来我们要建立一个test的菜单，而不是直接打开test</p>
<h2 id="25-Creating-Tests"><a href="#25-Creating-Tests" class="headerlink" title="25 Creating Tests"></a><strong>25 Creating Tests</strong></h2><p>Test.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>&#123;&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">TestMenu</span> : <span class="keyword">public</span> Test &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//void OnUpdate(float deltaTime) override;</span></span><br><span class="line">		<span class="comment">//void OnRender() override;</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">		<span class="comment">// 构造一个pari传入m_Tests中，分别是我们获得的名称和lambda，lambda的类型来自模板类型</span></span><br><span class="line">		<span class="comment">// lambda这里C++还没看过，以及function的标准函数也不太了解，到时候要去补一下C++这部分</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">RegisterTest</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Registering test &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">			m_Tests.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(name, []() &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;));</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Test*&amp; m_CurrentTest;<span class="comment">//我们的按钮会控制当前的Test, 把当前Test的引用传递到这里的成员指针</span></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 我们并不想直接要一个test的指针，这样就代表这个实例已经被创建了</span></span><br><span class="line">		<span class="comment">// 而我们希望的是按下按钮，才创建和构造一个test的实例</span></span><br><span class="line">		<span class="comment">// 因此我们提供一个lambda的function，来构造一个test</span></span><br><span class="line">		<span class="comment">//vector储存一个pari，每个pari里有一个string表示Test的名称，function返回一个test的指针</span></span><br><span class="line"></span><br><span class="line">		std::vector&lt;std::pair&lt;std::string, std::function&lt;Test* ()&gt;&gt;&gt; m_Tests;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">    TestMenu::<span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer) </span><br><span class="line">        : <span class="built_in">m_CurrentTest</span>(currentTestPointer) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestMenu::OnImGuiRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; test : m_Tests) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(test.first.<span class="built_in">c_str</span>()))</span><br><span class="line">                m_CurrentTest = test.<span class="built_in">second</span>();<span class="comment">//按下按钮，则自动构造一个test实例，并把指针传递给m_CurrentTest</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">test::Test* currentTest = <span class="literal">nullptr</span>;</span><br><span class="line">test::TestMenu* testMenu = <span class="keyword">new</span> test::<span class="built_in">TestMenu</span>(currentTest);</span><br><span class="line">currentTest = testMenu;</span><br><span class="line"><span class="comment">//这样做的结果是，menu里的m_CurrentTest当前就储存的自己。</span></span><br><span class="line"><span class="comment">//因为我们没有必要每次都要设置一个初始的Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望这样来设置Test，传入模板参数提供类型，以及对应的名称</span></span><br><span class="line"><span class="comment">//作者提出一种模块化coding的方式，就是先假装以及有这个功能，然后去使用，再回来实现</span></span><br><span class="line">testMenu-&gt;<span class="built_in">RegisterTest</span>&lt;test::TestClearColor&gt;(<span class="string">&quot;Clear Color&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">    ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTest) &#123;</span><br><span class="line">        currentTest-&gt;<span class="built_in">OnUpdate</span>(<span class="number">0.0f</span>);</span><br><span class="line">        currentTest-&gt;<span class="built_in">OnRender</span>();</span><br><span class="line">        ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (currentTest != testMenu &amp;&amp; ImGui::<span class="built_in">Button</span>(<span class="string">&quot;&lt;-&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> currentTest;</span><br><span class="line">            currentTest = testMenu;</span><br><span class="line">        &#125;<span class="comment">//删除当前Test后，回到testMenu</span></span><br><span class="line">        currentTest-&gt;<span class="built_in">OnImGuiRender</span>();</span><br><span class="line">        ImGui::<span class="built_in">End</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> currentTest;<span class="comment">//currentTest 的实例创建是模板的lambda里做的</span></span><br><span class="line"><span class="keyword">if</span> (currentTest != testMenu)</span><br><span class="line">    <span class="keyword">delete</span> testMenu;</span><br></pre></td></tr></table></figure>

<p>我们运行后，啥都没有</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917170520171.png" alt="image-20220917170520171" style="zoom:50%;" />



<p>但是点击Clear Color的button以后，就获得了前面的Clear Color的功能，并且包含一个回退按钮，再点击这个回退按钮</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917170553457.png" alt="image-20220917170553457" style="zoom:50%;" />

<p>再点击这个回退按钮，这个Test实例就被注销了，并且UI也回到原来的界面，但由于Opengl是状态机修改，所以背景色的状态没有变回去</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917170625931.png" alt="image-20220917170625931" style="zoom:50%;" />

<p>作者在循环开始时加上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure>

<p>这样就能保证不存在TestClearColor实例时，有一个固定的背景色。（即注销实例后，背景色会清空）</p>
<p>为了防止内存溢出，在循环结束后，我们还要把new出来的test删掉</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> currentTest;</span><br><span class="line"><span class="keyword">if</span> (currentTest != testMenu)</span><br><span class="line">    <span class="keyword">delete</span> testMenu;</span><br></pre></td></tr></table></figure>





<h2 id="26-Creating-a-Texture-Test"><a href="#26-Creating-a-Texture-Test" class="headerlink" title="26 Creating a Texture Test"></a><strong>26 Creating a Texture Test</strong></h2><p>以上搭建的框架，其实就是建立了一个类似于沙盒，我们可以在里面设置各种测试Test</p>
<p>在之后的工作会进行Batch Rendering</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBufferLayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">TestTexture2D</span> : <span class="keyword">public</span> Test &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">TestTexture2D</span>();</span><br><span class="line">		~<span class="built_in">TestTexture2D</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::unique_ptr&lt;VertexArray&gt; m_VAO;</span><br><span class="line">		std::unique_ptr&lt;IndexBuffer&gt; m_IndexBuffer;</span><br><span class="line">		std::unique_ptr&lt;Shader&gt; m_Shader;</span><br><span class="line">		std::unique_ptr&lt;Texture&gt; m_Texture;</span><br><span class="line">		std::unique_ptr&lt;VertexBuffer&gt; m_VertexBuffer;</span><br><span class="line">		glm::mat4 m_Proj, m_View;</span><br><span class="line">		glm::vec3 m_TranslationA, m_TranslationB;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TestTexture2D.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestTexture2D.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glm/glm.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glm/gtc/matrix_transform.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">	TestTexture2D::<span class="built_in">TestTexture2D</span>() </span><br><span class="line">		: <span class="built_in">m_Proj</span>(glm::<span class="built_in">ortho</span>(<span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">-1.5f</span>, <span class="number">1.5f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)),</span><br><span class="line">		  <span class="built_in">m_View</span>(glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))),</span><br><span class="line">		<span class="built_in">m_TranslationA</span>((<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>)), <span class="built_in">m_TranslationB</span>((<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">		 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="type">float</span> positions[<span class="number">16</span>] = &#123;</span><br><span class="line">			<span class="number">-2.0f</span>, <span class="number">-1.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">			 <span class="number">2.0f</span>, <span class="number">-1.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">			 <span class="number">2.0f</span>,  <span class="number">1.5f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">			<span class="number">-2.0f</span>,  <span class="number">1.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">				&#125;;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">			<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">			<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">		<span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		m_VAO = std::<span class="built_in">make_unique</span>&lt;VertexArray&gt;();</span><br><span class="line">		m_VertexBuffer = std::<span class="built_in">make_unique</span>&lt;VertexBuffer&gt;(positions, <span class="number">4</span> * <span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">		VertexBufferLayout layout;</span><br><span class="line">		layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">		layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">		m_VAO-&gt;<span class="built_in">AddBuffer</span>(*m_VertexBuffer, layout);</span><br><span class="line">		m_IndexBuffer = std::<span class="built_in">make_unique</span>&lt;IndexBuffer&gt;(indices, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		m_Shader = std::<span class="built_in">make_unique</span>&lt;Shader&gt;(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line">		m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">		m_Shader-&gt;<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		m_Texture = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">&quot;res/textures/2.png&quot;</span>);</span><br><span class="line">		m_Texture-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">		m_Shader-&gt;<span class="built_in">SetUniform1i</span>(<span class="string">&quot;u_Texture&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TestTexture2D::~<span class="built_in">TestTexture2D</span>() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>));</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">		Renderer renderer;</span><br><span class="line"></span><br><span class="line">		m_Texture-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationA);</span><br><span class="line">			glm::mat4 mvp =m_Proj * m_View * model;</span><br><span class="line">			m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">			m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">			renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationB);</span><br><span class="line">			glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line">			m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">			m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">			renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnImGuiRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">&quot;Translation A&quot;</span>, &amp;m_TranslationA.x, <span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">		ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">&quot;Translation B&quot;</span>, &amp;m_TranslationB.x, <span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">		ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里完成后，只需在main中注册。</p>
<h2 id="Batch-Rendering"><a href="#Batch-Rendering" class="headerlink" title="Batch Rendering"></a><strong>Batch Rendering</strong></h2><ul>
<li><p>在处理Texture的时候要注意，由于最大的Texture slot数量的限制（比如上一章节讲texture里提过当前windows最大的数量32），同一个batch往往不能容纳足够的Texture，那么只能把多余的texture对应的网格渲染放到下一个batch，以此类推。</p>
</li>
<li><p>假如100个submesh，对应100个texture，每32个texture对应的mesh合批，这样也只需要4个drawcall</p>
</li>
<li><p>静态合批大抵就是如此（把不同mesh的vertex组合起来）</p>
</li>
</ul>
<h3 id="Dynamic-Geometry"><a href="#Dynamic-Geometry" class="headerlink" title="Dynamic Geometry"></a><strong>Dynamic Geometry</strong></h3><p>这一段就是讲动态合批。</p>
<ul>
<li><p>静态合批是我们一开始就设定好了合批的数据，每一帧只需要渲染这些已经传递到GPU的数据。</p>
</li>
<li><p>而我们希望对于动态的物体也能进行合批。</p>
</li>
<li><p>重要的依然是这两部分：vertex buffer和index buffer</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220924145750783.png" alt="image-20220924145750783" style="zoom: 67%;" />

<p>除了提前准备了这一部分数据，我们还使用</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFER,<span class="built_in">sizeof</span>(vertices),vertices,GL_STATIC_DRAW)</span><br></pre></td></tr></table></figure>

<p>在update前将数据储存到GPU。</p>
<p>而为了动态改变数据，我们可以只创建buffer，但是先不传递数据，即传递一个空指针。</p>
<p>我们也可以根据我们的顶点结构和需要的顶点数量来决定buffer的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span>&#123;</span><br><span class="line">	<span class="type">float</span> Position[<span class="number">3</span>];</span><br><span class="line">    <span class="type">float</span> Color[<span class="number">4</span>];</span><br><span class="line">    <span class="type">float</span> TexCoords[<span class="number">2</span>];</span><br><span class="line">    <span class="type">float</span> TexID;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后就是绘制方式，不再是Static，我们要换成dynamic</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFER,<span class="number">1000</span>*<span class="built_in">sizeof</span>(Vertex),<span class="literal">nullptr</span>,GL_DYNAMIC_DRAW)</span><br></pre></td></tr></table></figure>

<p>其他关于顶点属性绑定之类都是一样的，只不过可以利用Vertex的结构来让它变得更通用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexArrayAttrib</span>(m_QuadVB,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>,<span class="number">3</span>,GL_FLOAT,GL_FALSE,<span class="built_in">sizeof</span>(Vertex), (<span class="type">const</span> <span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, Position));</span><br><span class="line"><span class="built_in">glEnableVertexArrayAttrib</span>(m_QuadVB,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>,<span class="number">4</span>,GL_FLOAT,GL_FALSE,<span class="built_in">sizeof</span>(Vertex), (<span class="type">const</span> <span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, Color));</span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<p>IB在合批中也不应该被改变。虽然我们动态地改变了顶点的属性，但是这些跟IB有什么关系。</p>
<p>在数量庞大的vertices当中，往往也需要用for loop来构建indices。（去年可视化的性能优化工作就是手动做了静态合批这件事……虽然当时并不知道合批这个概念）</p>
<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a><strong>Update</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220924153010284.png" alt="image-20220924153010284"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set dynamic buffer</span></span><br><span class="line"><span class="comment">//OnUpdate</span></span><br><span class="line"><span class="comment">//float vertices[] =&#123;....&#125;;之后在这里我们每一帧都可能对顶点数据做出改变</span></span><br><span class="line"><span class="comment">//也可以用一些封装的方法</span></span><br><span class="line"><span class="comment">//这里作者也出现一个问题，就是前面Vertex的结构里定义的是数组，不能直接赋值一个结构，因此他改成了vec的结构</span></span><br><span class="line"><span class="keyword">auto</span> q0 = <span class="built_in">CreateQuad</span>(<span class="number">-1.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>);<span class="comment">//x,y,texID</span></span><br><span class="line"><span class="keyword">auto</span> q1 = <span class="built_in">CreateQuad</span>(<span class="number">0.5f</span>,<span class="number">-0.5f</span>,<span class="number">1.0f</span>);</span><br><span class="line">Vertex vertices[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(vertices,q<span class="number">0.</span><span class="built_in">data</span>(), q<span class="number">0.</span><span class="built_in">size</span>()*<span class="built_in">sizeof</span>(Vertex));</span><br><span class="line"><span class="built_in">memcpy</span>(vertices+q<span class="number">0.</span><span class="built_in">size</span>(),q<span class="number">1.</span><span class="built_in">data</span>(), q<span class="number">1.</span><span class="built_in">size</span>()*<span class="built_in">sizeof</span>(Vertex));</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_QuadVB);</span><br><span class="line"><span class="comment">//glMapBuffer()我们可以用这个方法直接将数据写入缓冲</span></span><br><span class="line"><span class="comment">//也有glUnmapBuffer，把buffer从GPU上卸载下来</span></span><br><span class="line"><span class="comment">//但是这个方法会慢一点</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER,<span class="number">0</span>,<span class="built_in">sizeof</span>(vertices),vertices);</span><br><span class="line"><span class="comment">//这个方法和glBufferData很像，但它不分配缓冲，仅仅是将数据放进去</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们就可以通过各种方式来改变绘制的顶点数据</p>
<p>比如通过gui来控制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OnImGuiRender</span></span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Controls&quot;</span>);</span><br><span class="line">ImGui::<span class="built_in">DragFloat2</span>(<span class="string">&quot;Quad Pos&quot;</span>,m_QuadPosition, <span class="number">0.1f</span>);</span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//OnUpdate</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//q0 = Create(m_QuadPosition[0],m_QuadPosition[1],0.0f);</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>这样就完成了动态的vertex buffer绘制，以及动态合批，我们只创建了一个vertex buffer，调用了一次drawcall。</p>
<h4 id="Indices"><a href="#Indices" class="headerlink" title="Indices"></a><strong>Indices</strong></h4><p>对于两个quad，我们很简单地就可以直接写出合批的indices</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是对于数量更多的mesh，我们也可以有一定的规律来写出。</p>
<p>首先依然要决定我们要绘制多少个四边形，以1000个为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> MaxQuadCount = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//这既决定Vertex的数量，也决定indices的数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> MaxVertexCount = MaxQuadCount * <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> MaxIndexCount = MaxQuadCount * <span class="number">6</span>;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER,<span class="built_in">sizeof</span>(Vertex) * MaxVertexCount,<span class="literal">nullptr</span>,GL_DYNAMIC_DRAW);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="type">uint32_t</span> indices[MaxIndexCount];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;MaxIndexCount;i+=<span class="number">6</span>)&#123;</span><br><span class="line">    indices[i<span class="number">+0</span>]=<span class="number">0</span>+offset;</span><br><span class="line">    indices[i<span class="number">+1</span>]=<span class="number">1</span>+offset;</span><br><span class="line">    indices[i<span class="number">+2</span>]=<span class="number">2</span>+offset;</span><br><span class="line">    indices[i<span class="number">+3</span>]=<span class="number">2</span>+offset;</span><br><span class="line">    indices[i<span class="number">+4</span>]=<span class="number">3</span>+offset;</span><br><span class="line">    indices[i<span class="number">+5</span>]=<span class="number">0</span>+offset;</span><br><span class="line">    </span><br><span class="line">    offset += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/24/TA/OpenGL/Opengl%20learning_04/" data-id="cmfe8hf43002h9wuh1rcbancy" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Opengl/" rel="tag">Opengl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/Opengl learning_03" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/09/12/TA/OpenGL/Opengl%20learning_03/">【笔记】Cherno Opengl Tutorial note 03</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/09/12/TA/OpenGL/Opengl%20learning_03/" class="article-date">
  <time datetime="2022-09-12T04:05:40.000Z" itemprop="datePublished">2022-09-12</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="16-Writing-a-Basic-Renderer"><a href="#16-Writing-a-Basic-Renderer" class="headerlink" title="16 Writing a Basic Renderer"></a><strong>16 Writing a Basic Renderer</strong></h2><p>目前为止，如果我们每次想要绘制东西，都需要完成所有步骤-绑定-drawcall</p>
<p>希望能够提供</p>
<p>Renderer</p>
<p>unbind不是绝对的，但在debug中很有用，也许也能减少一些错误。但是实际上没有必要要，因为绑定下一个对象，就等于解绑了。</p>
<h3 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a><strong>Renderer</strong></h3><p>要注意Renderer.h这里有一些小坑，就是作者include了VertexArray.h，其中又include了VertexBufferLayout。但是之前为了方便把debug的函数写在了Renderer当中，导致这里出现了相互include。解决方法就是把VertexArray.h中对VertexBufferLayout的include去掉，改成对这个class的声明，然后因为VertexArray.h还是需要使用其内部方法，在VertexArray.cpp 中再include VertexBufferLayout。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Renderer.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexArray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IndexBuffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">const</span> VertexArray&amp; va, <span class="type">const</span> IndexBuffer&amp; ib, <span class="type">const</span> Shader&amp; shader)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">//vertex array, index buffer, shader</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Renderer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Clear</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Draw</span><span class="params">(<span class="type">const</span> VertexArray&amp; va, <span class="type">const</span> IndexBuffer&amp; ib, <span class="type">const</span> Shader&amp; shader)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    va.<span class="built_in">Bind</span>();</span><br><span class="line">    ib.<span class="built_in">Bind</span>();</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, ib.<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>drawcall</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    renderer.<span class="built_in">Clear</span>();</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line">    shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line">    r += increment;</span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在renderer当中有顶点数组和索引缓冲区以及一个shader。</p>
<p>但是相比于shader，在传统的渲染器中采用的是材质material。材质就是shader加上一组数据（uniforms）。</p>
<p>这样将material传递给renderer，它将直接把shader和uniform绑定，然后再进行drawcall。。。</p>
<p>在本教程中也许不会涉及，但是在Game Engine中一定需要做。</p>
<h2 id="17-Textures"><a href="#17-Textures" class="headerlink" title="17 Textures"></a><strong>17 Textures</strong></h2><p>我们会忽略游戏中使用的纹理格式，但反正肯定不是png</p>
<ul>
<li>将图片加载到cpu memory</li>
<li>将pixel array 传递到GPU</li>
<li>使用shader读取到texture</li>
</ul>
<p>我们这里将会使用#include &lt;stb_image.h&gt;来处理png图片</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h">stb&#x2F;stb_image.h at master · nothings&#x2F;stb (github.com)</a></p>
<p>(直接拿图形学课的框架里的用了)，我们实际上只需要使用stb_image.h</p>
<p>在项目中新建stb_image.h和stb_image.cpp文件，把头文件直接复制进去，并且根据注释说明，在cpp文件中添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>这样就可以使用了。</p>
<p>然后我们要添加texture类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Texture.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	std::string m_FilePath;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* m_LocalBuffer;</span><br><span class="line">	<span class="type">int</span> m_Width, m_Height, m_BPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path);</span><br><span class="line">	~<span class="built_in">Texture</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// windows有32个 slot，移动平台如iphone有8个slot，这取决于GPU</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Width; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Height; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Texture.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Texture.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vendor/stb_image/stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Texture::<span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path)</span><br><span class="line">	: <span class="built_in">m_RendererID</span>(<span class="number">0</span>),	<span class="built_in">m_FilePath</span>(path), 	<span class="built_in">m_LocalBuffer</span>(<span class="literal">nullptr</span>), </span><br><span class="line">	<span class="built_in">m_Width</span>(<span class="number">0</span>),	<span class="built_in">m_Height</span>(<span class="number">0</span>), <span class="built_in">m_BPP</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//opengl希望pixel坐标从bottom-left开始</span></span><br><span class="line">	<span class="comment">//通常以扫描线的方式加载图片，左上角是起始点</span></span><br><span class="line"></span><br><span class="line">	m_LocalBuffer = <span class="built_in">stbi_load</span>(path.<span class="built_in">c_str</span>(), &amp;m_Width, &amp;m_Height, &amp;m_BPP, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;m_RendererID));</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_RendererID));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, m_Width, m_Height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_LocalBuffer)</span><br><span class="line">		<span class="built_in">stbi_image_free</span>(m_LocalBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Texture::~<span class="built_in">Texture</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">glDeleteTextures</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Texture::Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glActiveTexture</span>( GL_TEXTURE0 + slot);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Texture::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这中间还有一些需要修改的，比如uniform、shader中的varying变量(in、out)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::SetUniform1i</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUniform1i</span>(<span class="built_in">GetUniformLocation</span>(name), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当画出来的屏幕是黑的时候，加上GLCall()来debug就显得非常好用了</p>
<p>直接提示到我们</p>
<p>是这句发生了错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, m_Width, m_Height, <span class="number">0</span>, GL_RGBA8, GL_UNSIGNED_BYTE, m_LocalBuffer);</span><br><span class="line"><span class="comment">//对照教程，需要改成</span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, m_Width, m_Height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer);</span><br></pre></td></tr></table></figure>

<p>根据文档，这里两个format分别是internal format和format。internal format是opengl储存纹理的方法。format是提供的纹理的格式。所以我们提供GL_RGBA8告诉opengl储存单通道8位。而我们提供的纹理则是GL_RGBA格式的。</p>
<p>这样就非常完美地画出了薰。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911011136266.png" alt="image-20220911011136266"></p>
<p>(作者由于透明度混合设置的问题，图片出现了失真。)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br></pre></td></tr></table></figure>



<h2 id="18-Blending"><a href="#18-Blending" class="headerlink" title="18 Blending"></a><strong>18 Blending</strong></h2><p>Blending determines how we combine our output color with what is already in our target buffer.</p>
<ul>
<li>output<ul>
<li>the color we output from our fragment shader</li>
</ul>
</li>
<li>Target buffer<ul>
<li>the buffer our fs is drawing to (destination)</li>
</ul>
</li>
</ul>
<p>如何控制Blending</p>
<ul>
<li>glEnable(GL_BLEND)-glDisable(GL_BLEND)</li>
<li>glBlendFunc(src, dest)<ul>
<li>src &#x3D; how the src RGBA factor is computed(default is GL_ONE)</li>
<li>dest &#x3D; how the dest RGBA factor is computed(default is GL_ZERO)</li>
</ul>
</li>
<li>glBlendEquation(mode)（BlendOp）<ul>
<li>mode &#x3D; how we combine the src and dest colors</li>
<li>Defualt value is GL_FUNC_ADD</li>
</ul>
</li>
</ul>
<h2 id="19-Maths"><a href="#19-Maths" class="headerlink" title="19 Maths"></a><strong>19 Maths</strong></h2><p>ignored</p>
<p>在该教程中会使用glm（适用于opengl的数学库）。并且适配与opengl列主序的矩阵。</p>
<p>通常在我们自己写跨平台的引擎时，也会自己写数学库。可以是行主序的。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/g-truc/glm/releases">Releases · g-truc&#x2F;glm (github.com)</a></p>
<p>我们可以在glm的git上下到release版，这里还是就直接把之前的复制到Dependencies里了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911170351237.png" alt="image-20220911170351237"></p>
<p>实际上我们只需要glm文件夹里的东西。</p>
<p>作者把它也放进了vendor文件夹里。</p>
<p>（其实我也更倾向放到Dependencie里作为附加包含目录）</p>
<p>GLM也是一个只包含头文件的库，没有cpp文件，不需要编译</p>
<p>事实上，作者随后就把vendor文件夹放到了附加包含目录里。。。</p>
<h2 id="20-Projection-Matrices"><a href="#20-Projection-Matrices" class="headerlink" title="20 Projection Matrices"></a><strong>20 Projection Matrices</strong></h2><p>在projection中我们完成了归一化齐次坐标[-1,1]^3</p>
<p>略了</p>
<h2 id="21-Model-View-Projection-Matrices"><a href="#21-Model-View-Projection-Matrices" class="headerlink" title="21 Model View Projection Matrices"></a><strong>21 Model View Projection Matrices</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">-1.5f</span>, <span class="number">1.5f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">glm::mat4 mvp = proj * view * model;</span><br></pre></td></tr></table></figure>

<p>在这里对view的处理很简单，就是我们向右移动相机，等同于向左移动物体。</p>
<h2 id="22-ImGui"><a href="#22-ImGui" class="headerlink" title="22 ImGui"></a><strong>22 ImGui</strong></h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><strong>环境配置</strong></h3><p>这里只是简单地将imgui移植到我们的opengl中，</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui">ocornut&#x2F;imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a></p>
<p>下载到release的source code</p>
<p>它提供了我们一个vs工程文件和一大堆各种平台的项目，我们也可以在这里面找到关于glfw_opengl3的example</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911224925272.png" alt="image-20220911224925272" style="zoom:50%;" />

<p>而我们实际需要的是根目录下的那些头文件和cpp文件。总之我们把他们复制到vendor中的imgui文件夹，就可以用了。</p>
<p>我对比了一下这里的以及图形学课用的框架里的，多了这四个文件</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911225155782.png" alt="image-20220911225155782"></p>
<p>可以看到这是imgui对glfw和opengl的实现（implementation）。在作者下载的imgui版本中，它们存在于examples当中（opengl3_example），但是我这里下载的版本已经更新了。</p>
<p>找了一下，它们已经更换了目录结构，现在这些impl文件都在backends文件夹中</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911230018016.png" alt="image-20220911230018016"></p>
<p>所以我们还是得把这四个文件复制过去。</p>
<p>作者的版本当中的imgl_glfw使用了gl3w，有提示需要改成glew，但在我们这里没有这个问题。</p>
<p>但我们编译时会发现它新增了一个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modern desktop OpenGL doesn&#x27;t have a standard portable header file to load OpenGL function pointers.</span></span><br><span class="line"><span class="comment">// Helper libraries are often used for this purpose! Here we are using our own minimal custom loader based on gl3w.</span></span><br><span class="line"><span class="comment">// In the rest of your app/engine, you can use another loader of your choice (gl3w, glew, glad, glbinding, glext, glLoadGen, etc.).</span></span><br><span class="line"><span class="comment">// If you happen to be developing a new feature for this backend (imgui_impl_opengl3.cpp):</span></span><br><span class="line"><span class="comment">// - You may need to regenerate imgui_impl_opengl3_loader.h to add new symbols. See https://github.com/dearimgui/gl3w_stripped</span></span><br><span class="line"><span class="comment">// - You can temporarily use an unstripped version. See https://github.com/dearimgui/gl3w_stripped/releases</span></span><br><span class="line"><span class="comment">// Changes to this backend using new APIs should be accompanied by a regenerated stripped loader version.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMGL3W_IMPL</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui_impl_opengl3_loader.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>意思就是。。。他们还是自己搞了一个gl3w，并且封装在这个loader头文件中了。。。我们直接删掉这是两行换成glew，看看理解对不对</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GL/glew.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>如下</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911234624507.png" alt="image-20220911234624507"></p>
<p>然而不对，这里后面会用到gl3w的api</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/issues/4445">OpenGL 后端现在嵌入了自己的 GL 加载程序 （imgui_impl_opengl3_loader.h） ·问题 #4445 ·ocornut&#x2F;imgui (github.com)</a></p>
<p>后来感觉这样还是不行，loader里面就是对gl3w的实现了，我们应该直接换glew。因此注释掉上面两行以后，定位到接下来的问题</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911233503486.png" alt="image-20220911233503486"></p>
<p>对于这里的初始化，我们直接给换成glewInit。这样就顺利运行了。</p>
<p>还是踩了些小坑，麻烦的话就直接跟着教程版本一致就好了。</p>
<h3 id="使用imgui"><a href="#使用imgui" class="headerlink" title="使用imgui"></a><strong>使用imgui</strong></h3><p>我们还是可以参考example中main里面的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup Dear ImGui context</span></span><br><span class="line"><span class="built_in">IMGUI_CHECKVERSION</span>();</span><br><span class="line">ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>(); (<span class="type">void</span>)io;</span><br><span class="line"><span class="comment">//io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls</span></span><br><span class="line"><span class="comment">//io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup Dear ImGui style</span></span><br><span class="line">ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"><span class="comment">//ImGui::StyleColorsClassic();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup Platform/Renderer backends</span></span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(window, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_Init</span>(glsl_version);</span><br></pre></td></tr></table></figure>

<p>和教程里面稍有变化（瑟瑟发抖，感觉坑会越来越多了，有点后悔），幸好和图形学课里的框架还是比较接近的，还算能参考一下。</p>
<p>助教的框架向上再封装了一层。这个教程这里大概是为了简单，直接写在了main函数里。</p>
<p>直接把上面的初始化复制上去，然后回头添加头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;imgui/imgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;imgui/imgui_impl_glfw.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;imgui/imgui_impl_opengl3.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>还有个glsl_version变量，在example里面是定义的。但是我们去这个函数里看一看，其实如果直接给NULL的话，是有默认值的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Store GLSL version string so we can refer to it later in case we recreate shaders.</span></span><br><span class="line">    <span class="comment">// Note: GLSL version is NOT the same as GL version. Leave this to NULL if unsure.</span></span><br><span class="line">    <span class="keyword">if</span> (glsl_version == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(IMGUI_IMPL_OPENGL_ES2)</span></span><br><span class="line">        glsl_version = <span class="string">&quot;#version 100&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(IMGUI_IMPL_OPENGL_ES3)</span></span><br><span class="line">        glsl_version = <span class="string">&quot;#version 300 es&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__APPLE__)</span></span><br><span class="line">        glsl_version = <span class="string">&quot;#version 150&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        glsl_version = <span class="string">&quot;#version 130&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>并且注释很贴心地告诉我们，如果不确定glsl的版本，就直接留空</p>
<p>所以这个glsl_version变量我们直接删掉。</p>
<p>虽然和教程里面不一样，会多一些步骤，但像这样自己解决掉问题还是会很有成就感的吧，其实也不难对吧。</p>
<p>（实际上作者也跳过了里面io的初始化，这个我们也可以删掉）</p>
<p>然后是循环中的newframe步骤（作者仅需一行，我们这里变成了三行）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the Dear ImGui frame</span></span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">ImGui::<span class="built_in">NewFrame</span>();</span><br></pre></td></tr></table></figure>

<p>关于位置，助教框架的做法是——先渲染画面，再渲染gui。这一部分放在一个renderframe函数中，向上封装的流程是——输入输出处理-renderframe-swapbuffer-pollEvent</p>
<p>这也很符合逻辑，我们就也把这部分放在交换缓冲之前好了。（其实作者提出放哪里都行，只要Imgui的代码是放在这里面end之前就好了）</p>
<p>然后我们添加render命令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">Render</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在循环结束后，我们还要shutdown</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ImGui_ImplOpenGL3_Shutdown</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">ImGui::<span class="built_in">DestroyContext</span>();</span><br></pre></td></tr></table></figure>

<p>然后关于gui里的具体内容我们就复制一下example的就好了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Hello, world!&quot;</span>);                          <span class="comment">// Create a window called &quot;Hello, world!&quot; and append into it.</span></span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;This is some useful text.&quot;</span>);               <span class="comment">// Display some text (you can use a format strings too)</span></span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Demo Window&quot;</span>, &amp;show_demo_window);      <span class="comment">// Edit bools storing our window open/close state</span></span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Another Window&quot;</span>, &amp;show_another_window);</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;float&quot;</span>, &amp;f, <span class="number">0.0f</span>, <span class="number">1.0f</span>);            <span class="comment">// Edit 1 float using a slider from 0.0f to 1.0f</span></span><br><span class="line">    ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;clear color&quot;</span>, (<span class="type">float</span>*)&amp;clear_color); <span class="comment">// Edit 3 floats representing a color</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>))                            <span class="comment">// Buttons return true when clicked (most widgets return true when edited/activated)</span></span><br><span class="line">        counter++;</span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;counter = %d&quot;</span>, counter);</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（还有三个小变量，直接复制一下就好了）</p>
<p>非常好用。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220912001607129.png" alt="image-20220912001607129" style="zoom:50%;" />



<p>然后我们要开始改造自己需要的gui了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translation);</span><br><span class="line">glm::mat4 mvp = proj * view * model;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#123;</span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">&quot;Translation&quot;</span>, &amp;translation.x, <span class="number">-2.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们把model的修改移动到主循环当中，也非常好用。</p>
<p>这里我们使用的Float3，只提供了第一个translation.x 的指针。在使用的时候我们也要注意，glm::vec3这种结构储存的数据在内存上是不是连续的。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220912003032134.png" alt="image-20220912003032134" style="zoom:50%;" />



<h2 id="23-Rendering-Multiple-Objects"><a href="#23-Rendering-Multiple-Objects" class="headerlink" title="23 Rendering Multiple Objects"></a><strong>23 Rendering Multiple Objects</strong></h2><p>回顾我们之前的drawcall的部分，主要是这几个步骤</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shader.<span class="built_in">Bind</span>();</span><br><span class="line">va.<span class="built_in">Bind</span>();</span><br><span class="line">ib.<span class="built_in">Bind</span>();</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, ib.<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>

<p>分析shader当中，我们想要画出另一个位置的物体，我们可以提供一个不同的vertex buffer</p>
<p>那么当然也可以使用另一个mvp（这当然也更快）。</p>
<p> 当我们要绘制同一个物体很多次时（如tile类型的这种东西）我们没有必要用for loop像这样去绘制很多次，而是可以用&#x3D;&#x3D;batching&#x3D;&#x3D; 合批的方法，只调用一次drawcall，把所有的东西放到一个vertex buffer里。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/12/TA/OpenGL/Opengl%20learning_03/" data-id="cmfe8hf42002f9wuh7vwyao8i" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Opengl/" rel="tag">Opengl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>