<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">XZYW7&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="XZYW7&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-TA/百人计划/图形2.8 flowmap的实现" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.8%20flowmap%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2025-09-10T13:18:14.025Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形2-8-flowmap的实现——流动效果实现"><a href="#图形2-8-flowmap的实现——流动效果实现" class="headerlink" title="图形2.8 flowmap的实现——流动效果实现"></a>图形2.8 flowmap的实现——流动效果实现</h1><h3 id="一、Flowmap是什么"><a href="#一、Flowmap是什么" class="headerlink" title="一、Flowmap是什么"></a>一、Flowmap是什么</h3><ul>
<li>Flowmap的实质<ul>
<li>一张记录了2D向量信息的纹理</li>
<li>Flowmap上的颜色（RG）记录该处向量场的方向，让模型上某一点表现出定量流动的特征</li>
<li>通过在shader中偏移uv再对纹理进行采样，来模拟流动效果。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220806235307299.png" alt="image-20220806235307299"></p>
<p>&#x3D;&#x3D;ue4与unity相比反转了绿通道&#x3D;&#x3D;</p>
<h3 id="二、Flowmap-shader"><a href="#二、Flowmap-shader" class="headerlink" title="二、Flowmap shader"></a>二、Flowmap shader</h3><ol>
<li>采样Flowmap获取向量场信息<ul>
<li>Flowmap不能直接使用，需要从0，1映射到-1，1</li>
</ul>
</li>
<li>用向量场信息，使采样贴图时的uv随时间变化</li>
<li>对同一贴图以半个周期的相位差采集两次，并线性插值，使贴图流动连续</li>
</ol>
<ul>
<li>随着时间进行，变形越来越大，为了把偏移控制在一定范围内</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> phase = frac(_Time);</span><br><span class="line"><span class="comment">// 解决frac产生的跳变</span></span><br><span class="line"><span class="comment">// 构造周期相同，相位相差半个周期的波形函数</span></span><br><span class="line"><span class="type">float</span> phase0 = frac(_Time * <span class="number">0.1</span> * _TimeSpeed);</span><br><span class="line"><span class="type">float</span> phase1 = frac(_Time * <span class="number">0.1</span> * _TimeSpeed + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220807000102114.png" alt="image-20220807000102114"></p>
<ul>
<li>用相位差半个周期的两层采样进行加权混合，使纹理流动一个周期重新开始时的不自然情况被另一层采样覆盖</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220807000117694.png" alt="image-20220807000117694"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float2 tiling_uv = i.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">half3 tex0 = tex2D(_MainTex, tiling_uv - floatDir.xy * phase0);</span><br><span class="line">half3 tex1 = tex2D(_MainTex, tiling_uv - floatDir.xy * phase1);</span><br><span class="line"><span class="comment">//构造函数计算随波形函数变化的权值，</span></span><br><span class="line"><span class="comment">//使得纹理采样值在接近最大偏移时有权值0，并因此消隐，构造较平滑的循环</span></span><br><span class="line"><span class="type">float</span> flowLerp = <span class="built_in">abs</span>((<span class="number">0.5</span>-phase0)/<span class="number">0.5</span>);</span><br><span class="line">half3 finalColor = lerp(tex0,tex1,flowLerp);</span><br></pre></td></tr></table></figure>



<h3 id="三、Flowmap的制作"><a href="#三、Flowmap的制作" class="headerlink" title="三、Flowmap的制作"></a>三、Flowmap的制作</h3><h4 id="Flowmap-painter"><a href="#Flowmap-painter" class="headerlink" title="Flowmap painter"></a>Flowmap painter</h4><p>Flowmap painter是unity制作的绘制flowmap的工具（用该工具得到的flowmap是线性空间颜色，不需要gamma矫正，在unity中取消勾选sRGB）</p>
<p>本来还以为这种东西要手动在ps里画RG通道。。。有点头疼来着，没想到这个工具这么方便，并且可以支持flow的效果实时可视化。</p>
<h4 id="Houdini-Labs"><a href="#Houdini-Labs" class="headerlink" title="Houdini Labs"></a>Houdini Labs</h4><p>Houdini Labs是内置在Houdini中的一组游戏开发相关的节点，可以在github中搜索sidefx Labs或直接在houdini中安装（在较早版本中的shoudini中无法在shelf内找到，在这些未被内置到houdini的版本中，这组工具名称为gamedev）</p>
<ol>
<li><strong>flowmap相关节点功能</strong></li>
</ol>
<ul>
<li>grid<ul>
<li>细分</li>
</ul>
</li>
<li>flowmap<ul>
<li>初始化向量场</li>
</ul>
</li>
<li>flowmap_brush<ul>
<li>向量场笔刷</li>
</ul>
</li>
<li>flowmap_to_color<ul>
<li>将向量映射到颜色</li>
<li>并添加uv（如有uv则直接沿用）</li>
</ul>
</li>
<li>flowmap_visualize<ul>
<li>可视化flowmap效果</li>
</ul>
</li>
<li>maps_baker<ul>
<li>导出</li>
<li>输出顶点色，并设置gamma（1-线性空间）</li>
</ul>
</li>
<li>flowmap_guide<ul>
<li>输入flowmap field(flowmap向量场)和曲线</li>
<li>利用曲线修改向量场</li>
</ul>
</li>
<li>flowma_obstacle<ul>
<li>输入模型和向量场</li>
<li>以模型和flowmap绘制平面进行检测，模型作为障碍，阻挡flow</li>
</ul>
</li>
</ul>
<h4 id="Flowmap的烘焙和相关设置"><a href="#Flowmap的烘焙和相关设置" class="headerlink" title="Flowmap的烘焙和相关设置"></a>Flowmap的烘焙和相关设置</h4><ul>
<li><p>flowmap贴图设置：</p>
<ul>
<li>无压缩或高质量</li>
<li>确认色彩空间</li>
</ul>
</li>
<li><p>Houdini</p>
<ul>
<li>Labs Map Baker节点</li>
<li>导出时注意gamma矫正选项、uv匹配</li>
<li>用Labs UV transfer节点来匹配高模和低模的UV</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="实现流动效果"><a href="#实现流动效果" class="headerlink" title="实现流动效果"></a>实现流动效果</h4><p>我也是第一次听说flowmap这个概念，然后看看我的桌面壁纸发现：</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802184553447.png" alt="image-20220802184553447"></p>
<p>这不就是flowmap做的水流效果吗？也是非常有趣。</p>
<p>作业直接拿去年图形学作业用的水面贴图拿过来用了。flowmap是用Flowmap painter画的。</p>
<p>中间平滑插值的一步看到图像其实很想用三角函数来做，但实操发现影响好像不太大，并且这个计算比起教程里的消耗会更大一点，所以还是没什么必要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float flowLerp = (cos(2*UNITY_PI * _Time*0.1 * _TimeSpeed)+1)/2;//abs((0.5-phase0)/0.5);//</span><br></pre></td></tr></table></figure>

<p>中间过程中一直发现有锯齿，最后发现是纹理压缩的问题，默认是法线质量压缩，在一些边缘处就会出现奇怪的锯齿</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816163919751.png" alt="image-20220816163919751"></p>
<p>把压缩模式换成无压缩就好了（这也是为什么人家工具导出的就是png格式）。</p>
<p>感觉flowmap很适合放在球面上，加一点自发光和半透明，做成朝一个方向旋转的水元素效果。一时间想不起来这种效果的案例哪里有了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/Flowmap.gif" alt="Flowmap"></p>
<p>感觉可以再进一步做一个顶点噪声扰动也许效果更好</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zq4y157c9">https://www.bilibili.com/video/BV1Zq4y157c9</a> </p>
<p>【技术美术百人计划】图形 2.8 flowmap的实现——流动效果实现</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.8%20flowmap%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="cmfe1kyaz0027ykuh4xmtbyjn" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.1 深度与模板测试" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.1%20%E6%B7%B1%E5%BA%A6%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95/" class="article-date">
  <time datetime="2025-09-10T13:18:14.025Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形3-1-深度与模板测试"><a href="#图形3-1-深度与模板测试" class="headerlink" title="图形3.1 深度与模板测试"></a><strong>图形3.1 深度与模板测试</strong></h2><h3 id="一、模板测试Stencil-Test"><a href="#一、模板测试Stencil-Test" class="headerlink" title="一、模板测试Stencil Test"></a><strong>一、模板测试Stencil Test</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816182543699.png" alt="image-20220816182543699"></p>
<h4 id="1-1-渲染管线中的逐片元操作"><a href="#1-1-渲染管线中的逐片元操作" class="headerlink" title="1.1 渲染管线中的逐片元操作"></a><strong>1.1 渲染管线中的逐片元操作</strong></h4><ul>
<li>逐片元操作（可配置，不可编程）<ul>
<li>像素权限测试Pixel Ownership Test（屏幕窗口使用权限，如scene和game窗口区分）</li>
<li>裁剪测试Scissor Test（可以对渲染部分区域进行控制）</li>
<li>透明度测试Alpha Test（片元透明度大于阈值，则通过测试，否则剔除——只能实现不透明和全透明）</li>
<li>模板测试Stencil Test</li>
<li>深度测试Depth Test</li>
<li>混合Blending</li>
<li>Dithering</li>
<li>Logic Op</li>
</ul>
</li>
</ul>
<h4 id="1-2-模板测试理解"><a href="#1-2-模板测试理解" class="headerlink" title="1.2 模板测试理解"></a><strong>1.2 模板测试理解</strong></h4><ul>
<li>通过一定条件来判断是对该片元抛弃还是保留</li>
<li>模板缓冲区<ul>
<li>和颜色缓冲区、深度缓冲区类似</li>
<li>为屏幕上每个像素点保存一个uint8</li>
<li>可以用这个值与预先设定的参考值比较，根据结果来决定是否更新对应像素的颜色。</li>
<li>这个比较的过程被称为模板测试</li>
</ul>
</li>
<li>发生在透明度测试后，深度测试前</li>
<li>通过测试，则更新像素点，否则不更新语法表示</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stencil&#123;</span><br><span class="line">    Ref referenceValue</span><br><span class="line">    ReadMask readMask</span><br><span class="line">    WriteMask writeMask</span><br><span class="line">    Comp comparisonFunction</span><br><span class="line">    Pass stencilOperation</span><br><span class="line">    Fail stencilOperation</span><br><span class="line">    ZFail stencilOperation<span class="comment">//模板测试通过了，但是深度测试没通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(referenceValue&amp;readMask comparisonFunction stencilBufferValue&amp;readMask)</span><br><span class="line">pass</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">discard</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-1-比较函数Comparison-Function"><a href="#1-2-1-比较函数Comparison-Function" class="headerlink" title="1.2.1 比较函数Comparison Function"></a><strong>1.2.1 比较函数Comparison Function</strong></h5><table>
<thead>
<tr>
<th align="center">Greater</th>
<th align="center">GEqual</th>
<th align="center">Less</th>
<th align="center">LEqual</th>
<th align="center">Equal</th>
<th align="center">NotEqual</th>
<th align="center">Always</th>
<th align="center">Never</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$&gt;$</td>
<td align="center">$\geq$</td>
<td align="center">$&lt;$</td>
<td align="center">$\leq$</td>
<td align="center">$&#x3D;$</td>
<td align="center">$\neq$</td>
<td align="center">总是通过</td>
<td align="center">总是失败</td>
</tr>
</tbody></table>
<h5 id="1-2-2-模板（更新）操作stencilOperation"><a href="#1-2-2-模板（更新）操作stencilOperation" class="headerlink" title="1.2.2 模板（更新）操作stencilOperation"></a><strong>1.2.2 模板（更新）操作stencilOperation</strong></h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Keep</td>
<td align="center">保留当前缓冲内容，即stencilBufferValue不变</td>
</tr>
<tr>
<td align="center">Zero</td>
<td align="center">将0写入缓冲，即stencilBufferValue变为0</td>
</tr>
<tr>
<td align="center">Replace</td>
<td align="center">将参考值写入缓冲，即将stencilBufferValue赋值为referenceValue</td>
</tr>
<tr>
<td align="center">IncrSat</td>
<td align="center">stencilBufferValue加1，如果超过255，则保留为255</td>
</tr>
<tr>
<td align="center">DecrSat</td>
<td align="center">stencilBufferValue减1，如果小于0，则保留为0</td>
</tr>
<tr>
<td align="center">Invert</td>
<td align="center">将stencilBufferValue按位取反</td>
</tr>
<tr>
<td align="center">IncrWarp</td>
<td align="center">stencilBufferValue加1，如果超过255，则变成0（然后继续自增）</td>
</tr>
<tr>
<td align="center">DecrWarp</td>
<td align="center">stencilBufferValue减1，如果小于0，则变成255（然后继续自减）</td>
</tr>
</tbody></table>
<h4 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a><strong>1.3 总结</strong></h4><ul>
<li><p>使用模板缓冲区最重要的两个值：当前模板缓冲值stencilBufferValue和模板参考值referenceValue</p>
</li>
<li><p>模板测试主要就是对这两个值使用特定的比较操作</p>
</li>
<li><p>模板测试之后要对模板缓冲区的值进行更新操作，Keep，Zero，Replace等</p>
</li>
<li><p>模板测试之后可以根据结果对模板缓冲区做不同的更新操作，比如测试成功操作pass，测试失败操作fail，深度测试失败Zfail，还有正对正面和背面精确更新操作PassBack，PassFront，FailBack等</p>
</li>
<li><p>应用</p>
<ul>
<li>描边<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816205437129.png" alt="image-20220816205437129"></li>
</ul>
</li>
<li>多边形填充<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816205429461.png" alt="image-20220816205429461"></li>
</ul>
</li>
<li>反射区域控制<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816205345560.png" alt="image-20220816205345560"></li>
</ul>
</li>
<li>Shadow Volume</li>
</ul>
</li>
</ul>
<h3 id="二、深度测试Depth-Test"><a href="#二、深度测试Depth-Test" class="headerlink" title="二、深度测试Depth Test"></a><strong>二、深度测试Depth Test</strong></h3><ul>
<li>一些特性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816205656742.png" alt="image-20220816205656742"></p>
<p>在这里面值得注意的是最后一张，greater的部分，绿色的部分消失了。这是因为蓝色外面的部分还没有渲染，是无穷远，greater的比较无法通过，就不被渲染。像这种涉及无穷远比较的，比如天空盒，要多注意深度测试的比较方式。</p>
<h4 id="2-1-渲染管线中的深度测试"><a href="#2-1-渲染管线中的深度测试" class="headerlink" title="2.1 渲染管线中的深度测试"></a><strong>2.1 渲染管线中的深度测试</strong></h4><blockquote>
<p>  Early-Z</p>
<p>  现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</p>
<p>  片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。</p>
<p>  ——LearnOpengl</p>
</blockquote>
<ul>
<li><p>（Early-Z）</p>
</li>
<li><p>片元着色器</p>
</li>
<li><p>逐片元操作（可配置，不可编程）</p>
<ul>
<li>像素权限测试Pixel Ownership Test（屏幕窗口使用权限，如scene和game窗口区分）</li>
<li>裁剪测试Scissor Test（可以对渲染部分区域进行控制）</li>
<li>透明度测试Alpha Test（片元透明度大于阈值，则通过测试，否则剔除——只能实现不透明和全透明）</li>
<li>模板测试Stencil Test</li>
<li>深度测试Depth Test</li>
<li>混合Blending</li>
<li>Dithering</li>
<li>Logic Op</li>
</ul>
</li>
</ul>
<h4 id="2-2-深度测试理解"><a href="#2-2-深度测试理解" class="headerlink" title="2.2 深度测试理解"></a><strong>2.2 深度测试理解</strong></h4><p>深度测试就是当前对象在屏幕（Frame Buffer）对应的像素点，将对象自身的深度值与该当前该像素点缓存的深度值进行比较，如果通过，本对象在该像素点才会将颜色写入颜色缓冲，否则不会写入。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度缓冲区</span></span><br><span class="line"><span class="keyword">if</span>(ZWrite On &amp;&amp; (currentDepthValue ComparisonFunction DepthBufferValue))</span><br><span class="line">写入深度</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">忽略深度</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色缓冲区</span></span><br><span class="line"><span class="keyword">if</span>(currentDepthValue Comparison Function DepthBufferValue)</span><br><span class="line">写入颜色缓冲</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">不写入颜色缓冲</span><br></pre></td></tr></table></figure>

<ul>
<li>从发展角度理解<ul>
<li>控制渲染顺序<ul>
<li>画家算法</li>
<li>Z-Buffer算法</li>
</ul>
</li>
<li>控制Z-Buffer对深度的储存<ul>
<li>Z-Test</li>
<li>Z-Write</li>
</ul>
</li>
<li>控制不同类型物体渲染顺序<ul>
<li>透明物体</li>
<li>不透明物体</li>
<li>渲染队列</li>
</ul>
</li>
<li>减少overdraw<ul>
<li>Early-Z</li>
<li>Z-Cull</li>
<li>Z-check</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-2-1-深度缓冲区Z-Buffer"><a href="#2-2-1-深度缓冲区Z-Buffer" class="headerlink" title="2.2.1 深度缓冲区Z-Buffer"></a><strong>2.2.1 深度缓冲区Z-Buffer</strong></h5><p>深度缓冲就像颜色缓冲，在每个片段中储存了信息，并且和颜色缓冲一样拥有宽度和高度，深度缓冲是由窗口系统自动创建的，他会以16、24、32位float的形式储存深度值。在大部分系统中深度缓冲精度都是24位。（Z-Buffer中储存的是当前深度信息，对于每个像素储存一个深度值）</p>
<p>通过Z-Write和Z-Test来调用Z-Buffer，实现想要的渲染结果</p>
<h5 id="2-2-2-深度写入Z-Write"><a href="#2-2-2-深度写入Z-Write" class="headerlink" title="2.2.2 深度写入Z-Write"></a><strong>2.2.2 深度写入Z-Write</strong></h5><p>深度写入包括两种状态：Z-Write On 与Z-Write Off</p>
<p>当我们开启深度写入时，物体被渲染时，对应每个像素的深度都写入到深度缓冲区。反之，不会写入。但是物体写入深度，除了需要深度写入开启，还需要通过深度测试。</p>
<p>Z-Test分为通过和不通过两种情况，Z-Write分为开启和关闭两种情况，一共就是四种情况</p>
<table>
<thead>
<tr>
<th align="center">深度测试</th>
<th align="center">深度写入</th>
<th align="center">深度缓冲区</th>
<th align="center">颜色缓冲区</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通过</td>
<td align="center">开启</td>
<td align="center">写入</td>
<td align="center">写入</td>
</tr>
<tr>
<td align="center">通过</td>
<td align="center">关闭</td>
<td align="center">不写入</td>
<td align="center">写入</td>
</tr>
<tr>
<td align="center">失败</td>
<td align="center">开启</td>
<td align="center">不写入</td>
<td align="center">不写入</td>
</tr>
<tr>
<td align="center">失败</td>
<td align="center">关闭</td>
<td align="center">不写入</td>
<td align="center">不写入</td>
</tr>
</tbody></table>
<p>这里顺便附上之前用Opengl做天空盒时对深度测试的理解。（现在看来glDepthMask就是开启深度写入，glDepthFunc就是比较函数，只有开启深度测试，深度写入才有用）可以根据上面的表格来更深入地理解下面的描述。</p>
<blockquote>
<p>  此外，还额外进行了天空盒的绘制，天空盒其实也就是先绘制一个立方体，然后将其z坐标取为w，使得在坐标归一化除以w时，z&#x3D;1位于无限远的位置，这样能够使得天空的面永远在无限远处。</p>
<p>  期间还需要对深度缓存进行一些操作。以下是我的理解。</p>
<p>  &#x2F;&#x2F;在不进行天空盒z&#x3D;w操作的基础上，我们先渲染一遍天空盒，并且在此期间关闭深度遮罩不写入深度缓存，渲染完毕后开启深度遮罩，渲染其他物体，此时，其他物体覆盖在天空盒上,正常渲染</p>
<p>  &#x2F;&#x2F;(是否写入深度缓存结果上也等同于是否进行深度测试，即可以关闭深度遮罩，也可以关闭深度测试)</p>
<pre><code>//如果不关闭深度遮罩，天空盒深度将写入深度缓存，如果物体在天空盒后面，则被遮挡。



//理解测试：那么在不进行z=w的时候，先绘制天空盒，不关闭深度遮罩，但是在绘制完天空盒之后，清除深度缓存，能正常绘制其他物体。测试正确。

//现在进行z=w的操作，并且先渲染天空盒，采用关闭深度测试的方式，即便z=1.0，也能正常渲染（未写入深度缓冲）。但是如果把天空盒放在最后渲染,天空盒将覆盖所有物体。

//如果是采用关闭深度遮罩的方式呢？只是不写入深度缓存，但实际上还是会进行深度测试，z=1.0无法渲染天空盒，因为原本就是1，但如果用LEQUAL,则可以渲染天空盒（默认为LESS）

//实际上，天空盒深度值已经是1.0的情况，开启深度遮罩没有任何意义（开启深度遮罩只是为了避免天空盒深度小于其他物体的情况，1.0已经最大），渲染天空盒和物体的顺序也不会有影响

//但是，后渲染天空盒，保留深度测试，可以利用深度测试提升性能
</code></pre>
</blockquote>
<h5 id="2-2-3-比较函数Comparison-Function"><a href="#2-2-3-比较函数Comparison-Function" class="headerlink" title="2.2.3 比较函数Comparison Function"></a><strong>2.2.3 比较函数Comparison Function</strong></h5><table>
<thead>
<tr>
<th align="center">Greater</th>
<th align="center">GEqual</th>
<th align="center">Less</th>
<th align="center">LEqual</th>
<th align="center">Equal</th>
<th align="center">NotEqual</th>
<th align="center">Always</th>
<th align="center">Never</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$&gt;$</td>
<td align="center">$\geq$</td>
<td align="center">$&lt;$</td>
<td align="center">$\leq$</td>
<td align="center">$&#x3D;$</td>
<td align="center">$\neq$</td>
<td align="center">总是通过</td>
<td align="center">总是失败</td>
</tr>
</tbody></table>
<h5 id="2-2-4-默认状态"><a href="#2-2-4-默认状态" class="headerlink" title="2.2.4 默认状态"></a><strong>2.2.4 默认状态</strong></h5><p>Z-Write On，Z-Test Lequal，深度缓存一开始为无穷大。（这些和Opengl是不一样的）</p>
<h4 id="2-3-渲染队列"><a href="#2-3-渲染队列" class="headerlink" title="2.3 渲染队列"></a><strong>2.3 渲染队列</strong></h4><h5 id="2-3-1-Unity中的渲染队列"><a href="#2-3-1-Unity中的渲染队列" class="headerlink" title="2.3.1 Unity中的渲染队列"></a><strong>2.3.1 Unity中的渲染队列</strong></h5><p>Unity中设置队列</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816220946497.png" alt="image-20220816220946497"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot; = &quot;Transparent&quot;&#125;<span class="comment">//默认是Geometry</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">渲染队列</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Background（1000）</td>
<td>最早被渲染的物体的队列</td>
</tr>
<tr>
<td align="center">Geometry（2000）</td>
<td>不透明物体的渲染队列。大多数物体都应该是用该队列进行渲染（默认渲染队列）</td>
</tr>
<tr>
<td align="center">AlphaTest（2450）</td>
<td>有透明通道，需要进行AlphaTest的物体的队列，比在Geometry中更有效</td>
</tr>
<tr>
<td align="center">Transparent（3000）</td>
<td>半透明物体。一般是不写入深度的物体，Alpha Blend等的在该队列渲染</td>
</tr>
<tr>
<td align="center">Overlay（4000）</td>
<td>最后被渲染的物体。一般是覆盖效果，如镜头光晕，屏幕贴片。</td>
</tr>
</tbody></table>
<ul>
<li>渲染队列的物体排序：根据深度排序，深度小的在最前，深度大的在最后</li>
<li>不透明物体的渲染顺序：从前往后</li>
<li>透明物体的渲染顺序：从后往前（OverDraw）</li>
</ul>
<h5 id="2-3-2-Tips"><a href="#2-3-2-Tips" class="headerlink" title="2.3.2 Tips"></a><strong>2.3.2 Tips</strong></h5><p>多pass shader中，unity会选择所有pass里队列最靠前的作为物体的队列，然后根据pass的编写顺序逐pass执行</p>
<h4 id="2-4-Early-Z"><a href="#2-4-Early-Z" class="headerlink" title="2.4 Early-Z"></a><strong>2.4 Early-Z</strong></h4><p>传统的渲染管线中，Z-Test是在Blending阶段，这时的深度测试，所有对象都计算过了片元着色器。大量的计算是无用的。</p>
<p>现代GPU运用了Early-Z技术，在Vs和Fs之间，进行一次深度测试。如果深度测试失败，就不必进行片元着色器的计算。但是最终的Z-Test仍需进行，保证最终遮挡结果正确。前面一次主要是Z-Cull为了裁剪达到优化目的。后一次是Z-Check，为了检查。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816221825445.png" alt="image-20220816221825445"></p>
<h4 id="2-5-深度值"><a href="#2-5-深度值" class="headerlink" title="2.5 深度值"></a><strong>2.5 深度值</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816222256273.png" alt="image-20220816222256273"></p>
<p>这个非线性深度也能够回答GAMES101中闫老师在投影矩阵那部分，讲frustum中间的点在投影矩阵之后是变远了还是变近了的问题。</p>
<blockquote>
<p>  要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1&#x2F;z  成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度。花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。</p>
<p>  由于非线性方程与 1&#x2F;z  成正比，在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值，这就是一个float提供给我们的一半精度了，这在z值很小的情况下提供了非常大的精度。在50.0和100.0之间的z值将会只占2%的float精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：<br>  $$<br>  F_{depth}&#x3D;\frac{1&#x2F;z-1&#x2F;near}{1&#x2F;far-1&#x2F;near}<br>  $$
  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/depth_non_linear_graph.png" alt="img"></p>
<h5 id="2-5-1-深度冲突Z-fighting"><a href="#2-5-1-深度冲突Z-fighting" class="headerlink" title="2.5.1 深度冲突Z-fighting"></a><strong>2.5.1 深度冲突Z-fighting</strong></h5><blockquote>
<p>  一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</p>
</blockquote>
<p>所以实际上z-fighting的问题还是精度的问题。</p>
<p>一般解决方法就是稍微移动一点，不要重合。Learnopengl里还基于深度储存的精度剔除，可以把近平面设置远一点。或者是用更大的精度来储存。（实际上永远不会有足够的精度来保证完全重合）</p>
<h4 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a><strong>2.6 总结</strong></h4><ul>
<li>是用深度缓冲区最重要的两个值：当前深度缓冲currentDepthValue和深度缓冲值zbufferValue，并通过比较操作获取理想渲染结果</li>
<li>Unity中的渲染顺序：先渲染不透明物体（从前往后），再渲染透明物体（从后往前）</li>
<li>通过深度写入和深度测试组合控制半透明物体的渲染</li>
<li>引入Early-z技术后的深度测试渲染流程</li>
<li>深度缓冲区储存0-1的浮点值（非线性深度）</li>
<li>应用<ul>
<li>基于深度的着色（湖水）<ul>
<li>（摄像机到地面距离和湖水深度作比较，以差值比例控制着色）</li>
</ul>
</li>
<li>ShadowMap</li>
<li>透明物体、粒子渲染</li>
<li>透视X-ray效果</li>
<li>切边效果</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><p><strong>根据课程内容，使用深度测试与模板测试做一些有意思的效果</strong></p>
<h4 id="模板测试-描边"><a href="#模板测试-描边" class="headerlink" title="模板测试-描边"></a><strong>模板测试-描边</strong></h4><p>正好撞见Unity的描边，我们就来试试模板测试的描边</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819163419228.png" alt="image-20220819163419228"></p>
<p>我们来拆解一下这个效果</p>
<ul>
<li>2pass<ul>
<li>一个pass绘制物体<ul>
<li>写入一个模板值</li>
</ul>
</li>
<li>一个pass绘制物体法线外扩<ul>
<li>模板比较</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>现在问题就在于，如何进行法线外扩。</p>
<p><a target="_blank" rel="noopener" href="https://www.laowangomg.com/?p=712">https://www.laowangomg.com/?p=712</a></p>
<p>这篇文章总结的非常详细。</p>
<p>其实最重要的问题是，我们在什么时候进行法线外扩？从模型空间到齐次裁剪空间过程中，在哪一步？</p>
<p>问题在于，我们应该让法线如何外扩？对于模型上的所有顶点，沿法线方向移动距离s，这是模型空间、世界空间、相机空间的做法。这样做的问题在于，我们可以把这个距离看作都是世界空间的距离，在经过投影变换后，不同位置的尺度会发生变化，也就是说，导致描边不均匀。</p>
<p>上面的博客给出的办法是——在齐次裁剪空间进行法线外扩，并且我们可以忽略z轴上的变化。只考虑屏幕的xy方向。</p>
<p>但是在我的实践中发现了一个问题，就是其实描边的宽度还是会出现不一致。并且这和渲染窗口分辨率有关。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819220901399.png" alt="image-20220819220901399"></p>
<p>于是我们就知道是怎么回事了：</p>
<p><strong>齐次裁剪空间时宽度一致的外扩尺度，经过视口变换后不再一致</strong>，但是我们肯定没有办法在视口变换的阶段处理顶点的位置，因此我们仍然需要进行改变。</p>
<p>我们要解决的核心问题是，让它在屏幕上能保持尺度的一致，其实，就是&#x3D;&#x3D;观察空间&#x3D;&#x3D;保持一致。</p>
<p>之前说在MVP空间的外扩都会导致投影后尺度变化。事实的确如此，在观察空间也会出现这个问题。</p>
<p>那么，在观察空间如何解决这一问题呢？我们可以借用裁剪空间的方法，只考虑屏幕上xy的变化，而忽略z的尺度变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.pos.xy += <span class="built_in">normalize</span>(vNormal.xy) * _OutLine;</span><br><span class="line"><span class="comment">//o.pos.xyz += normalize(vNormal.xyz) * _OutLine;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看出使用XYZ和xy的细微差别，这也很好理解。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1660921557672.gif" alt="1660921557672"></p>
<p>这里我还做了一项处理就是让描边的粗细不受距离的影响，或者说，距离增加，描边的粗细也应该增加。不然就会像这样</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819222542483.png" alt="image-20220819222542483"></p>
<p>这应该如何处理呢？</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819232155564.png" alt="image-20220819232155564"></p>
<p>我们的h1&#x2F;z1是由参数控制的，不妨令z1为1，则h1就等于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">normalize</span>(o.pos.xy)*_OutLine</span><br></pre></td></tr></table></figure>

<p>那么要令距离z2的点在投影上和h1具有相同的高度，h2就很好求了。</p>
<p>这里还要注意，将z值取绝对值，我们只需要正值的计算。这样再调一调粗细的参数，效果和unity的描边效果就是基本一致的。</p>
<p>但是这种做法的局限性在于顶点法线，如果比较尖锐的顶点不是插值的法线的话，就会出现面片的分离。这就需要对模型法线进行处理，涉及到相应的工具制作。这也就是之后下一步工作的伏笔了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1660923128047.gif" alt="1660923128047"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line"></span><br><span class="line">    Stencil&#123;</span><br><span class="line">        Ref <span class="number">0</span></span><br><span class="line">            Comp Equal</span><br><span class="line">    &#125;</span><br><span class="line">	Cull front</span><br><span class="line">    CGPROGRAM</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> _OutLine;</span><br><span class="line">    <span class="type">float</span> _Attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="function">v2f <span class="title">vert</span><span class="params">(a2v v)</span> </span>&#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos = <span class="built_in">mul</span>(UNITY_MATRIX_MV,v.vertex);</span><br><span class="line">        float3 vNormal = <span class="built_in">mul</span>((float3x3) UNITY_MATRIX_V, <span class="built_in">UnityObjectToWorldNormal</span>(v.normal));</span><br><span class="line">        o.pos.xy += <span class="built_in">normalize</span>(vNormal.xy) * _OutLine * <span class="built_in">abs</span>(o.pos.z);</span><br><span class="line">        o.pos = <span class="built_in">mul</span>(UNITY_MATRIX_P,o.pos);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span></span><br><span class="line">        fixed4 color =<span class="built_in">fixed4</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fixed4</span>(color);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们为了放止描边被遮挡，也可做如下处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stencil&#123;</span><br><span class="line">    Ref <span class="number">1</span></span><br><span class="line">        Comp Always</span><br><span class="line">        Pass replace</span><br><span class="line">        ZFail replace</span><br><span class="line">&#125;<span class="comment">//物体pass</span></span><br><span class="line"></span><br><span class="line">Stencil&#123;</span><br><span class="line">    Ref <span class="number">0</span></span><br><span class="line">        Comp Equal</span><br><span class="line">&#125;</span><br><span class="line">Cull front</span><br><span class="line">ZTest always<span class="comment">//描边pass</span></span><br></pre></td></tr></table></figure>



<h4 id="深度测试-遮挡透视"><a href="#深度测试-遮挡透视" class="headerlink" title="深度测试-遮挡透视"></a><strong>深度测试-遮挡透视</strong></h4><p>首先当然是做一个遮挡扫描效果。</p>
<p>我们来拆解下这个效果的组成</p>
<ul>
<li>遮挡物<ul>
<li>正常的</li>
</ul>
</li>
<li>被遮挡物<ul>
<li>多pass<ul>
<li>以正常部分的队列为物体渲染队列从前往后</li>
</ul>
</li>
<li>正常部分<ul>
<li>Geometry</li>
<li>开启深度测试LESS，开启深度写入</li>
</ul>
</li>
<li>遮挡部分<ul>
<li>Transparent</li>
<li>开启深度测试Greater，不写入深度</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们首先来写一下遮挡部分</p>
<p>在透明的处理上，顺便看了下3.2部分的混合，用正常的透明混合方法Blend SrcAlpha OneMinusSrcAlpha</p>
<p>当然也可以选择其他的（感觉差不太多）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817153223447.png" alt="image-20220817153223447" style="zoom:50%;" />

<h5 id="大问题"><a href="#大问题" class="headerlink" title="大问题"></a><strong>大问题</strong></h5><p>出现了一个大问题。为遮挡物赋予一些材质时，会导致渲染顺序出错。</p>
<p>正常来说，遮挡物和被遮挡物都会处于Geometry的渲染队列，并且遮挡物先渲染，再渲透明Pass，最后是非透明Pass这是非常合理的.</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211331779.png" alt="image-20220817211331779"></p>
<p>赋予某些材质后。</p>
<p>有些时候是正常的，有些时候，透明pass会在遮挡物之前渲染，导致透明物体被遮挡。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211349707.png" alt="image-20220817211349707"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211648337.png" alt="image-20220817211648337"></p>
<p>这还不是最麻烦的。在这个状态下，如果后退摄像机一点，这里两个透明物体中的其中一个被渲染出来了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211717544.png" alt="image-20220817211717544"></p>
<p>如果再后退一点——透明物体都正常绘制了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211752817.png" alt="image-20220817211752817"></p>
<p>**但是，这依然不是最麻烦的。**如果这个时候，再把摄像机后退一些会发生什么呢？</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211856345.png" alt="image-20220817211856345"></p>
<p>这就是我所感觉到的绝望。</p>
<p>解决方法我想到了很多。</p>
<ol>
<li>被遮挡物体物体两个Pass都放在了Geometry渲染。如果把两个Pass放在Geometry之后的其他Pass渲染，就没问题了。但要注意修改Tags的pass时，最好是subshader的pass，这样会比较稳定，如果只改两个Pass的tags，是不稳定的。</li>
<li>和上面的方法基本思想一样，做法刚好相反。就是一定要保证遮挡物在被遮挡物两个pass之前渲染，把遮挡物的队列设成Geometry-1（或者更前面）就好了。</li>
<li>换一个遮挡物的shader和材质。这个是比较麻烦的。因为，即便是一个原本能正常绘制的shader，在我完全复制所有代码以后，重新生成的材质，依然出现了上述问题。这就比较玄学了，这也是最头疼的部分。。。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/468122471%E7%94%A8%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8A%8A%E4%B8%A4%E4%B8%AApass%E5%88%86%E5%BC%80%E5%88%B0%E4%B8%A4%E4%B8%AAshader%EF%BC%8C%E7%94%A8UsePass%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%90%84%E8%87%AA%E7%9A%84subshader%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E5%90%84%E8%87%AA%E7%9A%84Tag%E3%80%82%E7%BB%93%E6%9E%9C%E4%B9%9F%E6%98%AF%E6%AD%A3%E5%B8%B8%E7%9A%84%E3%80%82">https://zhuanlan.zhihu.com/p/468122471用这篇文章的处理方法，把两个pass分开到两个shader，用UsePass的方法，这样各自的subshader可以设置各自的Tag。结果也是正常的。</a></li>
</ol>
<p>但是，虽然这些方法能解决问题，我还是不知道为什么会出现这样的问题，以及，其实没有解决问题的根本——为什么在这些shader中渲染顺序会出错，不应该都是按深度排序的吗？</p>
<p>首先会考虑是否是z精度的问题？但是又怎么会随距离周期变化呢？</p>
<p>发现其实DepthPass顺序就错了，也就是说直接原因还是深度。但是为什么某些材质就没有这个问题了呢？并且SubShader和Pass的Tag也有影响。。。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817213753109.png" alt="image-20220817213753109"></p>
<p><strong>又找到了一个绝妙的解决方法</strong></p>
<p>我直接重新做一个shader，然后用两次UsePass。。。当然，缺少原来CGINCLUDE的参数和属性，这一部分直接原样复制过去就行了。</p>
<p>果然能解决问题。</p>
<p>。。。但是令人崩溃的又来了。。。我继续把两个UsePass分别替换回原来的两个Pass的代码。。。竟然也是对的。。。问题是这样和原来的代码有啥区别。。。shader的名字的区别。。。为什么。。。已经麻了，就当是bug吧。</p>
<p>感觉跟unity的资源读取和shader编译的过程有一定关系。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhlabcd/p/11767018.html%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%87%BA%E7%8E%B0%E4%BA%86%E4%B8%80%E6%A0%B7%E7%9A%84%E7%8E%B0%E8%B1%A1%EF%BC%8C%E4%BD%86%E6%98%AF%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%8E%9F%E5%9B%A0%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%B8%8D%E8%BF%87%E5%8F%AF%E8%83%BD%E6%9C%89%E4%B8%80%E5%AE%9A%E5%85%B1%E6%80%A7%E3%80%82">https://www.cnblogs.com/zhlabcd/p/11767018.html这篇文章出现了一样的现象，但是看起来原因不太一样，不过可能有一定共性。</a></p>
<p>背后的真正原因，只能有缘再解决了</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Tb4y1C7Qa">https://www.bilibili.com/video/BV1Tb4y1C7Qa</a></p>
<p>【技术美术百人计划】图形 3.1 深度与模板测试  传送门效果示例</p>
<p>[2] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/">https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/427742656">https://zhuanlan.zhihu.com/p/427742656</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://www.laowangomg.com/?p=712">https://www.laowangomg.com/?p=712</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/468122471">https://zhuanlan.zhihu.com/p/468122471</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.1%20%E6%B7%B1%E5%BA%A6%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95/" data-id="cmfe1kyaz002bykuhgy5f4lnc" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.5 BUMP图改进" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.5%20BUMP%E5%9B%BE%E6%94%B9%E8%BF%9B/" class="article-date">
  <time datetime="2025-09-10T13:18:14.024Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形2-5-BUMP图改进"><a href="#图形2-5-BUMP图改进" class="headerlink" title="图形2.5 BUMP图改进"></a>图形2.5 BUMP图改进</h1><h3 id="一、凹凸贴图Bump-Mapping"><a href="#一、凹凸贴图Bump-Mapping" class="headerlink" title="一、凹凸贴图Bump Mapping"></a><strong>一、凹凸贴图Bump Mapping</strong></h3><ul>
<li>把物体的细节分为三种尺度<ul>
<li>宏观尺度（覆盖很多像素）<ul>
<li>由几何图元来表示</li>
</ul>
</li>
<li>中观尺度（覆盖少量像素）<ul>
<li>细节复杂，无法使用单个三角形渲染，并且足够大</li>
</ul>
</li>
<li>微观尺度（可能覆盖小于一个像素）<ul>
<li>在着色模型当中表现，模拟物体表面微观几何形状的相互作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>凹凸映射是模拟中观尺度的常用方法之一，能够让观察者感知到比几何模型尺度更小的细节</p>
<p>基本思想：在纹理中把尺度细节相关的信息编码进去，在着色过程中用受到干扰的表面代替真实表面，就让表面看起来具有小尺度的细节。</p>
<p>总之，凹凸贴图是对物体表面贴图进行变化再进行光照计算的一种技术。（增加物体真实感，但不需要额外的几何复杂度）</p>
<ul>
<li>分类<ul>
<li>法线贴图</li>
<li>视差贴图</li>
<li>浮雕贴图</li>
</ul>
</li>
</ul>
<p>在这三种技术中都会用到法线(贴图)</p>
<h3 id="二、法线贴图Normal-Mapping"><a href="#二、法线贴图Normal-Mapping" class="headerlink" title="二、法线贴图Normal Mapping"></a><strong>二、法线贴图Normal Mapping</strong></h3><p>法线贴图是一张存有物体局部表面法线信息的贴图。</p>
<p>计算光照时，程序读取法线图，并获取当前着色点的法线信息，结合光照信息进行光照计算。</p>
<p>法线贴图一般由高模映射到对应的底模上来生成，但像金属、木头等细节丰富的物体，可借助程序化软件如：Photoshop,Substance Designer等生成对应法线贴图</p>
<h4 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a><strong>切线空间</strong></h4><p>法线的储存一般放在模型的切线空间中</p>
<ul>
<li>切线空间<ul>
<li>物体表面切线、副切线、法线方向为基，组成的几何空间</li>
</ul>
</li>
<li>读取切线空间法线，需要将法线从切线空间转换到世界空间</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731003919885.png" alt="image-20220731003919885" style="zoom:67%;" />



<h4 id="世界和切线空间转换"><a href="#世界和切线空间转换" class="headerlink" title="世界和切线空间转换"></a><strong>世界和切线空间转换</strong></h4><p>切线空间坐标系的正交基是世界空间下的顶点法线（N）、切线（T）、副切线（B），法线为z轴，切线为x轴，副切线为y轴</p>
<p>构建一个3x3的矩阵做空间向量的坐标系转换。<br>$$<br>TBN &#x3D; \begin{bmatrix}T_x&amp;B_x&amp;N_x\<br>T_y&amp;B_y&amp;N_y\<br>T_z&amp;B_z&amp;N_z\<br>\end{bmatrix}\<br>\ \<br>TBN^{-1}&#x3D;TBN^T&#x3D;\begin{bmatrix}T_x&amp;T_y&amp;T_z\<br>B_x&amp;B_y&amp;B_z\<br>N_x&amp;N_y&amp;N_z\<br>\end{bmatrix}\<br>$$<br>想不清哪个是世界-切线，哪个是切线-世界，考虑一个单位阵，左乘矩阵，看看会变成什么就知道了。</p>
<ul>
<li>切线空间的好处<ul>
<li>切线空间记录的是相对的法线信息，对于一个物体表面记录的法线扰动，可以同样应用到球形物体上（植物的光照处理），但是模型空间记录法线就是绝对的，只能在该物体上用。</li>
<li>方便制作UV动画，贴图采样变化一致</li>
<li>法线纹理可重用</li>
<li>便于计算储存，0-1的储存映射范围，知道两个可以计算另一个</li>
</ul>
</li>
<li>Unity中法线贴图的压缩格式<ul>
<li>非移动平台，unity会把法线贴图转换成DXRT5nm格式，这种格式只有两个有效通道AG通道，可以节省空间<ul>
<li>在DXRT5nm格式中，AG通道分别储存对应法线的x，y分量，z分量需要通过一个简单的计算求得。</li>
</ul>
</li>
<li>移动平台，unity使用传统RGB通道</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/7416ead6-fc7e-4e52-9dba-b56d68996a2a.png" alt="7416ead6-fc7e-4e52-9dba-b56d68996a2a" style="zoom: 33%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/8b45fbb7-0987-4b01-9c95-c47166d160b4.png" alt="8b45fbb7-0987-4b01-9c95-c47166d160b4" style="zoom: 67%;" />



<h3 id="三、视差贴图Parallax-Mapping"><a href="#三、视差贴图Parallax-Mapping" class="headerlink" title="三、视差贴图Parallax Mapping"></a><strong>三、视差贴图Parallax Mapping</strong></h3><p>法线贴图只能改变法线而改变光照，无法使模型表面产生遮挡效果</p>
<p>视差贴图Parallax Mapping是一种类似法线贴图的技术。它用于提高模型表面细节并赋予其遮挡关系，可以和法线贴图一起使用。</p>
<p>视差贴图需要引进一张新的贴图——高度图。高度图一般是用于顶点位移使用的（位移&#x2F;置换贴图 Displacement mapping），但性能消耗高，需要大量三角形。视差贴图的核心是改变纹理坐标来改变遮挡关系，视差贴图就利用储存模型信息的高度图，<strong>利用模型表面高度信息来对纹理进行偏移</strong>。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731010656743.png" alt="image-20220731010656743" style="zoom: 67%;" />

<p>在着色时，模型在切线空间下所有点都在切平面内（0.0），核心就是对于要计算的片元A时，真正应该计算的点是视线与物体的“实际”交点B点。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731011441775.png" alt="image-20220731011441775"></p>
<p>要计算B点，就需要AB两点在平面上的UV偏差，为了简便，采取近似计算的方法，根据高（深）度图及切线空间下视角方向，近似求解偏移量，视角方向（v）与切平面的正切值与A点的高度值相乘来近似求解，并通过一个缩放值来控制。（有比较大的误差，必须要用这个scale来调整）<br>$$<br>d &#x3D; \frac{v.xy}{v.z}\cdot ha\cdot scale<br>$$</p>
<h4 id="陡峭视察映射Steep-Parallax-Mapping"><a href="#陡峭视察映射Steep-Parallax-Mapping" class="headerlink" title="陡峭视察映射Steep Parallax Mapping"></a>陡峭视察映射Steep Parallax Mapping</h4><p>陡峭视察映射也是近似，但更准确一些</p>
<p>陡峭视察映射将深度分为等距的若干层，从顶端开始采样，并且每次沿视角方向偏移一定值，若当前层深度大于采样出的深度，则停止检查并返回结果</p>
<p>（有点ray marching的感觉，那其实在优化上也可以借鉴一下分级采样？<a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/CbZTf-uM4/#real-time-global-illuminationscreen-space%EF%BC%89">https://xzyw7.github.io/post/CbZTf-uM4/#real-time-global-illuminationscreen-space）</a></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731012950141.png" alt="image-20220731012950141"></p>
<p>也可以根据v和n的角度来对采样层数进行控制</p>
<h3 id="四、浮雕贴图Relief-Mapping"><a href="#四、浮雕贴图Relief-Mapping" class="headerlink" title="四、浮雕贴图Relief Mapping"></a><strong>四、浮雕贴图Relief Mapping</strong></h3><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731014135800.png" alt="image-20220731014135800" style="zoom:50%;" />

<p>视差贴图在使用较大的uv偏移时存在失真。</p>
<p>浮雕贴图更容易提供更多的深度，还可以做自阴影、AO效果</p>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>浮雕映射一般采用射线步进、二分查找来决定uv偏移量</p>
<p>第一种使用射线步进来查找可能的交点（直接用二分查找可能漏掉较薄的区域导致结果不准确），确定交点位于哪一个步进内。之后在该步进内使用二分查找快速确定交点位置，最后返回结果，偏移贴图。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731014352296.png" alt="image-20220731014352296"></p>
<ul>
<li>解决最后一步二分查找性能开销问题<ul>
<li>视差闭塞贴图（Parallax Occlusion Mapping）</li>
<li>在步进后，分别对步进两端uv值采样，对结果插值，作为p点的结果（插值导致表面平滑效果更好）</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><p>结合先行版基础渲染光照介绍（一）将本次课所讲的案例结合进先前的光照效果</p>
<p>这里就4个案例嘛</p>
<h4 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h4><p>左一：standard shader</p>
<p>左二：custom shader，使用法线贴图</p>
<p>右一：custom shader，无法线贴图</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220801232026790.png" alt="image-20220801232026790"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct v2f &#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    float3 normal : TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    float2 uv : TEXCOORD2;</span><br><span class="line">    float3 tangent : TEXCOORD3;</span><br><span class="line">    float3 bitangent : TEXCOORD4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fixed3 normal = <span class="built_in">normalize</span>(i.normal);</span><br><span class="line">fixed3x3 TBN = fixed3x3(<span class="built_in">normalize</span>(i.tangent),<span class="built_in">normalize</span>(i.bitangent),normal);</span><br><span class="line">TBN = <span class="built_in">transpose</span>(TBN);<span class="comment">//Unity shader的矩阵是行优先的，所以我们要取个转置；</span></span><br><span class="line">fixed3 bump = <span class="built_in">normalize</span>(UnpackNormal(tex2D(_Normal, i.uv)));</span><br><span class="line">normal = <span class="built_in">normalize</span>(mul(TBN,bump));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不想像入门精要那样传一整个矩阵，我们可以传递的变量也是有限的，甚至可以只传tangent，副切线用叉乘计算。甚至也可以用之前的ddx和ddy的trick来计算。</p>
<p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/zezxM-QCJ/#ddxddy%E4%B8%8E%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE">https://xzyw7.github.io/post/zezxM-QCJ/#ddxddy%E4%B8%8E%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE</a></p>
<p>（Tips：有注意到在learnopengl中有描述，在一些网格较大的时候，出现TBN不互相垂直的情况，可以用施密特正交化来解决。）</p>
<h4 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h4><p>这个时候发现……狮子模型这个素材没有高度图……还得换个素材……</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fixed3 LightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<span class="comment">//normalize(_WorldSpaceLightPos0.xyz);//</span></span><br><span class="line">fixed3 ViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));<span class="comment">//normalize(_WorldSpaceCameraPos.xyz - i.worldPos);</span></span><br><span class="line">float3 h = <span class="built_in">normalize</span>(LightDir + ViewDir);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fixed3 normal = <span class="built_in">normalize</span>(i.normal);</span><br><span class="line">fixed3 bitangent = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(normal,i.tangent.xyz) * i.tangent.w);</span><br><span class="line">fixed3x3 TBN = fixed3x3(<span class="built_in">normalize</span>(i.tangent.xyz),bitangent,normal);</span><br><span class="line">TBN = <span class="built_in">transpose</span>(TBN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//视差贴图</span></span><br><span class="line"><span class="type">float</span> height = tex2D(_heightMap,i.uv).r;</span><br><span class="line">float3 ViewDirTS = <span class="built_in">normalize</span>(mul(<span class="built_in">transpose</span>(TBN),ViewDir));</span><br><span class="line">float2 offUV = ViewDirTS.xy/ViewDirTS.z * height * _heightScale;</span><br><span class="line">i.uv -= offUV;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法线贴图</span></span><br><span class="line">fixed3 bump = <span class="built_in">normalize</span>(UnpackNormal(tex2D(_Normal, i.uv)));</span><br><span class="line">normal = <span class="built_in">normalize</span>(mul(TBN,bump));</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802000836213.png" alt="image-20220802000836213"></p>
<p>视差贴图在视线接近垂直的时候效果还是很好的，但是正如learnopengl中所说，当从一个角度看过去的时候，会有一些问题产生（和法线贴图相似），陡峭的地方会产生不正确的结果。并且它的效果非常依赖于_heightScale这一参数</p>
<h4 id="陡峭视差贴图"><a href="#陡峭视差贴图" class="headerlink" title="陡峭视差贴图"></a>陡峭视差贴图</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">float2 steepParallaxMapping (float2 uv, float3 viewDir) &#123;</span><br><span class="line">    <span class="type">float</span> numLayers = <span class="number">20</span>;</span><br><span class="line">    <span class="type">float</span> layerHeight = <span class="number">1.0</span>/numLayers;</span><br><span class="line">    float2 deltaUV = <span class="number">1.0</span>/numLayers * viewDir.xy / viewDir.z * _heightScale;</span><br><span class="line">    float2 currentUV = uv;</span><br><span class="line">    <span class="type">float</span> currentHeight = tex2D(_heightMap,uv).r;</span><br><span class="line">    <span class="type">float</span> currentLayerHeight = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(currentLayerHeight &lt; currentHeight)</span><br><span class="line">    &#123;</span><br><span class="line">        currentUV -= deltaUV;</span><br><span class="line">        currentHeight = tex2Dlod(_heightMap, float4(currentUV,<span class="number">0.0</span>,<span class="number">0.0</span>)).r;</span><br><span class="line">        <span class="comment">//currentHeight = tex2Dgrad(_heightMap, currentUV,0.0,0.0).r;  </span></span><br><span class="line">        currentLayerHeight += layerHeight;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentUV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间一直出现的报错“unable to unroll loop”，给tex2D改成tex2Dlod或tex2Dgrad就好了</p>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/391443312">https://zhuanlan.zhihu.com/p/391443312</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144434084">https://zhuanlan.zhihu.com/p/144434084</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57994423/why-i-cant-use-tex2d-inside-a-loop-in-unity-shaderlab">https://stackoverflow.com/questions/57994423/why-i-cant-use-tex2d-inside-a-loop-in-unity-shaderlab</a></p>
<p><em>tex2D只能从“均匀控制流”调用，因为它必须通过计算“导数”来计算LOD。tex2Dlod没有，因为您提供了LOD。</em></p>
<p>tex2Dlod和tex2Dgrad都能指定纹理层，所以能够在循环中调用。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802161513119.png" alt="image-20220802161513119"></p>
<h4 id="浮雕贴图"><a href="#浮雕贴图" class="headerlink" title="浮雕贴图"></a>浮雕贴图</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">float2 steepParallaxMapping (float2 uv, float3 viewDir) &#123;</span><br><span class="line">    <span class="type">float</span> numLayers = <span class="number">20</span>;</span><br><span class="line">    <span class="type">float</span> layerHeight = <span class="number">1.0</span>/numLayers;</span><br><span class="line">    float2 deltaUV = <span class="number">1.0</span>/numLayers * viewDir.xy / viewDir.z * _heightScale;</span><br><span class="line">    float2 currentUV = uv;</span><br><span class="line">    <span class="type">float</span> currentHeight = tex2D(_heightMap,uv).r;</span><br><span class="line">    <span class="type">float</span> currentLayerHeight = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(currentLayerHeight &lt; currentHeight)</span><br><span class="line">    &#123;</span><br><span class="line">        currentUV -= deltaUV;</span><br><span class="line">        currentHeight = tex2Dlod(_heightMap, float4(currentUV,<span class="number">0.0</span>,<span class="number">0.0</span>)).r;  </span><br><span class="line">        currentLayerHeight += layerHeight;  </span><br><span class="line">    &#125;</span><br><span class="line">    float2 left = currentUV;</span><br><span class="line">    float2 right = currentUV+deltaUV;</span><br><span class="line">    <span class="type">float</span> dist = <span class="number">1</span>;</span><br><span class="line">    float2 midpoint = (left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">        midpoint = (left+right)/<span class="number">2</span>;</span><br><span class="line">        currentHeight = tex2Dlod(_heightMap, float4(midpoint,<span class="number">0.0</span>,<span class="number">0.0</span>)).r;</span><br><span class="line">        currentLayerHeight = <span class="built_in">length</span>(midpoint)/<span class="built_in">length</span>(viewDir.xy) * viewDir.z;</span><br><span class="line">        <span class="keyword">if</span> (currentLayerHeight &lt; currentHeight) &#123;</span><br><span class="line">            right = midpoint;</span><br><span class="line">            dist = currentHeight - currentLayerHeight;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentLayerHeight &gt; currentHeight) &#123;</span><br><span class="line">            left = midpoint;</span><br><span class="line">            dist = -currentHeight + currentLayerHeight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> midpoint;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="视察闭塞贴图"><a href="#视察闭塞贴图" class="headerlink" title="视察闭塞贴图"></a>视察闭塞贴图</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float2 left = currentUV;</span><br><span class="line">float2 right = currentUV+deltaUV;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> afterDepth  = currentHeight-currentLayerHeight;</span><br><span class="line"><span class="type">float</span> beforeDepth = tex2D(_heightMap, right).r -currentLayerHeight + layerHeight;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> weight = afterDepth / (afterDepth - beforeDepth);</span><br><span class="line">float2 finalTexCoords = right * weight + left * (<span class="number">1.0</span> - weight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> finalTexCoords;</span><br></pre></td></tr></table></figure>

<p>POM是肉眼可见的效果不错（上：SPM，中：RPM，下：POM），RPM就不太能看得出变化了，但其实还是有的</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802175923830.png" alt="image-20220802175923830" style="width:80%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802180825768.png" alt="image-20220802180825768" style="width:80%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802175853495.png" alt="image-20220802175853495" style="width:80%;" />

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ub4y1Z765">https://www.bilibili.com/video/BV1Ub4y1Z765</a> 【技术美术百人计划】图形 2.5 BUMP图改进</p>
<p>[2] Unity Shader入门精要 p146-155</p>
<p>[3] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.5%20BUMP%E5%9B%BE%E6%94%B9%E8%BF%9B/" data-id="cmfe1kyax001vykuh9h0t2s6i" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.6 伽马校正" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.6%20%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3/" class="article-date">
  <time datetime="2025-09-10T13:18:14.024Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-2-6-伽马校正"><a href="#图形-2-6-伽马校正" class="headerlink" title="图形 2.6  伽马校正"></a>图形 2.6  伽马校正</h1><h3 id="Gamma矫正"><a href="#Gamma矫正" class="headerlink" title="Gamma矫正"></a><strong>Gamma矫正</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730122434969.png" alt="image-20220730122434969"></p>
<h4 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a><strong>传递函数</strong></h4><ul>
<li>OETF<ul>
<li>光转电传递函数 ，负责把场景线性光转到非线性视频信号值</li>
</ul>
</li>
<li>EOTF<ul>
<li>电转光传递函数，负责把非线性视频信号值转换成显示光亮度</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730122710864.png" alt="image-20220730122710864" style="zoom:50%;" />

<h4 id="Gamma矫正-1"><a href="#Gamma矫正-1" class="headerlink" title="Gamma矫正"></a>Gamma矫正</h4><ul>
<li>Gamma是指对线性三色值和非线性视频信号之间进行编码和解码的操作</li>
<li>图像经过gamma编码储存在硬盘中，将获取到的物理数据做一次gamma值约为0.45(1&#x2F;2.2)的映射，这样的过程叫做gamma编码（此时的图像像素比实际物理像素要更亮——线性空间）</li>
<li>在显示图像时，需要将每个像素做一次gamma值约为2.2的矫正，使最终的结果为正确的物理数据（经过显示的gamma矫正后，之前偏亮的图像亮度降低——gamma空间）</li>
</ul>
<p>$$<br>V_{out}&#x3D;V_{in}^{gamma}<br>$$</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730144948798.png" alt="image-20220730144948798" style="zoom:80%;" />

<h4 id="为什么需要gamma矫正"><a href="#为什么需要gamma矫正" class="headerlink" title="为什么需要gamma矫正"></a><strong>为什么需要gamma矫正</strong></h4><ul>
<li>非线性转换的目的主要是为了优化储存空间和带宽，传递函数能够更好地利用编码空间</li>
<li>显示图像的数据都是8bit，但是人眼对暗部变化更敏感，为了充分利用带宽，那么需要使用更多空间去存储暗部值，也就是说暗部使用更高精度保存，亮部使用更低精度保存。</li>
</ul>
<p>以这张图来说明，对于人眼来说，上面的图像变化更均匀，但实际下面的图像才是物理上亮度均匀变化的。</p>
<p>（上面这张的中间灰度叫做美术中灰，下面的中间灰度叫做物理中灰）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730145336723.png" alt="image-20220730145336723" style="zoom:50%;" />

<p>将这两种变化进行一个映射，就是gamma曲线 </p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730145547142.png" alt="image-20220730145547142" style="zoom:50%;" />



<h4 id="韦伯定律"><a href="#韦伯定律" class="headerlink" title="韦伯定律"></a><strong>韦伯定律</strong></h4><ul>
<li>感觉的差别阈限随原来刺激量的变化而变化，而且表现为一定的规律性，用公式表达就是$\Delta\Phi&#x2F;\Phi &#x3D; C$ ，其中$\Phi$ 为原刺激量，$\Delta\Phi$ 为此时的差别阈限，C为常数，又称为韦伯率。（所受刺激越大，需要增加的刺激也要足够大才会让人感觉到明显变化，但是只适用于中等强度的刺激）</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul>
<li>人眼对暗部变化更敏感</li>
<li>我们目前使用的真彩格式RGBA32，每个通道只有8位用于记录信息，为了合理使用带宽和存储空间，需要进行非线性转换</li>
<li>目前我们所普遍使用的sRGB颜色空间标准，他的传递函数gamma值位2.2（2.4）</li>
</ul>
<h3 id="CRT与gamma矫正"><a href="#CRT与gamma矫正" class="headerlink" title="CRT与gamma矫正"></a><strong>CRT与gamma矫正</strong></h3><ul>
<li>CRT<ul>
<li>早期使用的CRT显示器（阴极射线显像管），设备的亮度与电压并不成线性关系，而是gamma值约为2.2类似幂律的关系</li>
<li>这种硬件特性与gamma矫正的需求正好是一种巧合</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730150841828.png" alt="image-20220730150841828" style="zoom: 67%;" />

<p>人眼对于中灰的感受取决于环境</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730151319961.png" alt="image-20220730151319961" style="zoom:50%;" />

<ul>
<li>线性工作流<ul>
<li>在生产各个环境，需要正确使用gamma编码与解码，使最终得到的颜色数据与最初输入的物理数据一致</li>
<li>如果是使用gamma空间的贴图，在传给着色器前需要从gamma空间转到线性空间</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730154948879.png" alt="image-20220730154948879" style="zoom:67%;" />

<p> <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730155223847.png" alt="image-20220730155223847"></p>
<h3 id="Unity中的颜色空间"><a href="#Unity中的颜色空间" class="headerlink" title="Unity中的颜色空间"></a><strong>Unity中的颜色空间</strong></h3><p>Edit-Project Settings-Player-Other Settings下的Rendering部分，修改Color Space</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730155540487.png" alt="image-20220730155540487"></p>
<ul>
<li>选择Gamma Space，Unity不会做任何处理</li>
<li>选择Linear Space，引擎的渲染流程在线性空间计算，理想情况下项目使用线性空间的贴图，不需要勾选sRGB，勾选sRGB的贴图会通过硬件特性采样时进行线性转换。</li>
</ul>
<h4 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a><strong>硬件支持</strong></h4><p>线性空间需要图形API的硬件支持，目前支持的平台</p>
<ol>
<li>Windows，Mac OS x和Linux（Standalone）</li>
<li>Xbox One</li>
<li>PS 4</li>
<li>Android（Opengl ES 3.0）</li>
<li>iOS（Metal）</li>
<li>WebGL</li>
</ol>
<h4 id="硬件特性支持"><a href="#硬件特性支持" class="headerlink" title="硬件特性支持"></a><strong>硬件特性支持</strong></h4><p>主要由两个硬件特性来支持</p>
<ul>
<li><p>sRGB Frame Buffer</p>
<ul>
<li>将Shader的计算结果输出到显示器前做Gamma矫正</li>
<li>作为纹理被读取时会自动把储存的颜色从sRGB空间转换到线性空间</li>
<li>调用ReadPixels()、ReadBackImage()时，会直接返回sRGB空间下的颜色</li>
<li>sRGB Frame Buffer只支持每通道8bit的格式，不支持浮点格式</li>
<li>HDR开启后会先把渲染结果绘制到浮点格式的FB中，最后绘制到sRGB FB上</li>
</ul>
</li>
<li><p>sRGB Sampler</p>
<ul>
<li>将sRGB的贴图进行线性采样的转换</li>
</ul>
</li>
</ul>
<p>使用硬件完成sRGB贴图的线性采样和shader计算结果的gamma矫正，比起在shader里对贴图采样和计算结果的矫正要快</p>
<h3 id="贴图制作导出的处理"><a href="#贴图制作导出的处理" class="headerlink" title="贴图制作导出的处理"></a><strong>贴图制作导出的处理</strong></h3><h4 id="Substance-Painter"><a href="#Substance-Painter" class="headerlink" title="Substance Painter"></a><strong>Substance Painter</strong></h4><p>sp贴图导出时，线性的颜色经过gamma变换，颜色被提亮了，所以需要在Unity中勾选sRGB选项，让它在采样时能还原回线性值。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730160341610.png" alt="image-20220730160341610"></p>
<h4 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a><strong>Photoshop</strong></h4><p>如果使用线性空间，一般来说Photoshop可以什么都不改，导出的贴图只要在Unity中勾上sRGB就可以了。</p>
<p>如果调整Photoshop的gamma值为1，导出的贴图在Unity中也不需要勾选sRGB</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730160653259.png" alt="image-20220730160653259"></p>
<ul>
<li><p>ps对颜色管理特别精确，Unity里看到的颜色要经过显示器的Gamma变换，而ps不会，ps会读取显示器的Color Profile，反向补偿回去。</p>
</li>
<li><p>ps中有第二个Color Profile，叫做Document Color Profile。通常默认为sRGB Color Profile，和显示器的Color Profile一致，颜色被压暗了，所以ps中看到的结果才和Unity一样。</p>
</li>
</ul>
<h5 id="混合"><a href="#混合" class="headerlink" title="混合"></a><strong>混合</strong></h5><p>Unity中的混合是线性的（线性空间模式下），ps图层与图层之间混合时，每个上层图层都经过了gamma变换，才做了混合。需要在设置中更改选择“用灰度系数混合rgb颜色”，参数设置为1，这样图层才是直接混合的结果。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730161152441.png" alt="image-20220730161152441"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><h4 id="手动尝试伽马校正的几种方法"><a href="#手动尝试伽马校正的几种方法" class="headerlink" title="手动尝试伽马校正的几种方法"></a><strong>手动尝试伽马校正的几种方法</strong></h4><h5 id="1-Unity线性空间"><a href="#1-Unity线性空间" class="headerlink" title="1.Unity线性空间"></a><strong>1.Unity线性空间</strong></h5><p>项目设置使用Linear空间，并且albedo贴图勾选sRGB</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730165247570.png" alt="image-20220730165247570"></p>
<h5 id="2-Unity-Gamma空间"><a href="#2-Unity-Gamma空间" class="headerlink" title="2.Unity Gamma空间"></a><strong>2.Unity Gamma空间</strong></h5><p>在项目设置里选择gamma空间</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730170411814.png" alt="image-20220730170411814"></p>
<p>可以观察到输出的颜色中，高光更亮、范围更大，因为光照是线性计算的，而且直接按照gamma空间输出了；但是直接输出的颜色更暗了。</p>
<h6 id="手动Gamma矫正"><a href="#手动Gamma矫正" class="headerlink" title="手动Gamma矫正"></a><strong>手动Gamma矫正</strong></h6><p>对于输出的radiance，我们进行gamma矫正</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> fixed4(LinearToGammaSpace(color),<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>以及采样贴图时，变换到线性空间计算</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed3 albedo = GammaToLinearSpace(tex2D(_Albedo, i.uv).rgb) * _Diffuse.rgb;</span><br></pre></td></tr></table></figure>

<p>（理论上来说，albedo这种属性是线性空间的，但是这也关乎到贴图导出的设置，一般制作的都是sRGB的图片，所以还是需要转换一下。）</p>
<p>这两个封装好的函数，也可以手动地去使用2.2次方去计算。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730171629559.png" alt="image-20220730171629559"></p>
<p>可以看到法线颜色球正常了，中间的我写的shader高光也压下来一些，但是这个Standard的着色器就改不了了。</p>
<p>所以引擎还是很方便的，我们在线性空间工作模式下，很多事情都帮我们做好了。但是需要在贴图的设置上多加注意。</p>
<ul>
<li>麻烦的地方<ul>
<li>在需要手动gamma矫正的平台上，在混合这一步会出现问题（因为在混合之前就进行gamma矫正了）</li>
<li>所以一个解决方法是：在fs颜色输出时不进行gamma矫正，但是需要一步后处理来完成gamma矫正，也造成了一些性能损耗。</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cU4y1b7UF">https://www.bilibili.com/video/BV1cU4y1b7UF</a> 【技术美术百人计划】图形 2.6  伽马校正</p>
<p>[2] Unity Shader 入门精要 p356-363.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.6%20%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3/" data-id="cmfe1kyax001zykuh6mvvfima" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形1.4PC手机图形API介绍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.4PC%E6%89%8B%E6%9C%BA%E5%9B%BE%E5%BD%A2API%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形1-4PC手机图形API介绍"><a href="#图形1-4PC手机图形API介绍" class="headerlink" title="图形1.4PC手机图形API介绍"></a>图形1.4PC手机图形API介绍</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h3><ul>
<li><p>图形API</p>
<ul>
<li>是一个图形库，用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序接口（API），针对GPU。</li>
</ul>
</li>
<li><p>应用端</p>
<ul>
<li>我们自己的程序端</li>
</ul>
</li>
<li><p>图元</p>
<ul>
<li>要渲染的几何物体、形状</li>
</ul>
</li>
<li><p>纹理</p>
<ul>
<li>可以理解为贴图，opengl es中纹理就是图片的另一种叫法</li>
</ul>
</li>
<li><p>纹素</p>
<ul>
<li>纹理的基础单元（纹理的像素）</li>
</ul>
</li>
<li><p>顶点数组</p>
<ul>
<li>顶点是组成图元的各个顶点的坐标数据（vertex），这些坐标数据可以一起存到要给内存数组中，这就是顶点数组</li>
</ul>
</li>
<li><p>顶点缓冲区</p>
<ul>
<li>显存中专门分配一块显存来存储这个顶点数组，这个显存就是顶点缓冲区</li>
</ul>
</li>
<li><p>顶点着色器</p>
</li>
<li><p>片元着色器</p>
</li>
</ul>
<h3 id="主流图形API"><a href="#主流图形API" class="headerlink" title="主流图形API"></a><strong>主流图形API</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722211701281.png" alt="image-20220722211701281"></p>
<ul>
<li><p>DirectX（windows）</p>
</li>
<li><p>Opengl(windows,linux,mac)</p>
</li>
<li><p>Opengl ES(移动设备——手机、oculus)</p>
<ul>
<li>Opengl ES2.0&#x2F;3.0是可编程图形管线（vs、fs），1.x是固定管线</li>
</ul>
</li>
</ul>
<h3 id="Opengl-ES3-0新功能"><a href="#Opengl-ES3-0新功能" class="headerlink" title="Opengl ES3.0新功能"></a><strong>Opengl ES3.0新功能</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722211827363.png" alt="image-20220722211827363"></p>
<ul>
<li><p>兼容性</p>
<ul>
<li>gles 3.0是向后兼容的（2.0的程序可以在3.0中使用）</li>
</ul>
</li>
<li><p>新特性</p>
<ul>
<li>阴影贴图、体渲染、gpu粒子动画、几何形状实例化、纹理压缩、gamma矫正</li>
<li>适应嵌入系统的局限性</li>
</ul>
</li>
<li><p>渲染管线</p>
<ul>
<li>移除alpha测试<ul>
<li>片段着色器可抛弃片段，因此alpha测试可以在fs中进行</li>
</ul>
</li>
<li>移除逻辑操作（LogicOp）<ul>
<li>很少使用</li>
</ul>
</li>
</ul>
</li>
<li><p>Shader编写</p>
<ul>
<li><p>版本声明</p>
</li>
<li><pre><code class="language-glsl">#version 300 es//声明为指定使用Opengl ES3.0版本
//不添加版本声明或使用#version 100 es 指定使用ES2.0
//(2.0是es中最先出的可编程管线，所以是100，为了匹配版本号，3.0跳到了300 es)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -   输入输出</span><br><span class="line"></span><br><span class="line">        -   in,out,inout关键字取代attribute，varing</span><br><span class="line">        -   gl_FragColor和gl_FragData删除了</span><br><span class="line">        -   片段着色器可以使用out声明字段输出</span><br><span class="line"></span><br><span class="line">    -   变量赋值</span><br><span class="line"></span><br><span class="line">        -   可以直接使用layout对指定位置变量赋值</span><br><span class="line"></span><br><span class="line">        -   ```glsl</span><br><span class="line">            //shader中</span><br><span class="line">            layout (location = 1) uniform float a;</span><br><span class="line">//应用端代码中</span><br><span class="line">            GLES30.glUniform1f(1,1f);</span><br><span class="line">            //2.0中必须使用如下形式</span><br><span class="line">            GLES20.glUniform1f(GLES20.glGetAttribLocation(program,&quot;a&quot;),1f)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="骁龙Adreno对应ES版本型号"><a href="#骁龙Adreno对应ES版本型号" class="headerlink" title="骁龙Adreno对应ES版本型号"></a><strong>骁龙Adreno对应ES版本型号</strong></h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Adreno">https://zh.wikipedia.org/wiki/Adreno</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9A%E9%A9%8D%E9%BE%8D%E5%85%83%E4%BB%B6%E5%88%97%E8%A1%A8#Snapdragon_888">高通骁龙组件列表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>Adreno320开始支持OpenglES3.0</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><ul>
<li>支持Opengl es3.2的骁龙GPU型号有哪些<ul>
<li>Adreno420&#x2F;430&#x2F;5xx&#x2F;6xx&#x2F;7xx</li>
</ul>
</li>
<li>如何看待Vulkan、<ul>
<li>对Vulkan了解不多，最大的特点就是：更复杂，也更高性能，并且支持跨平台。这增加了它的学习成本和上手难度的同时，能更深入地控制硬件，达到对性能更极致的追求。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.4PC%E6%89%8B%E6%9C%BA%E5%9B%BE%E5%BD%A2API%E4%BB%8B%E7%BB%8D/" data-id="cmfe1kyau001pykuh3lf6ajlg" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.1色彩空间" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.1%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形2-1色彩空间"><a href="#图形2-1色彩空间" class="headerlink" title="图形2.1色彩空间"></a>图形2.1色彩空间</h2><p>发送器-接收者-色彩空间-常用色彩空间、色彩模型-色彩空间转换-总结</p>
<h3 id="一、发送器"><a href="#一、发送器" class="headerlink" title="一、发送器"></a>一、发送器</h3><p>光源是出生点，光源发射出光线，光线通过直射反射折射等路径最终进入人眼。</p>
<p>人眼接收到光线后，人眼细胞产生一系列化学反应，把产生的信号传入大脑，大脑对颜色产生认知。</p>
<ul>
<li><p>光源</p>
<ul>
<li>产生光的物体</li>
</ul>
</li>
<li><p>波长</p>
<ul>
<li>光的波长分布理论上是无限大的，人眼可见光是局限的</li>
</ul>
</li>
<li><p>能量分布</p>
<ul>
<li>分光光度计<ul>
<li>描述光线的具体能量强度</li>
<li>拆分光线，形成单一波长光</li>
<li>测量单一波长光的实际所含能量</li>
</ul>
</li>
</ul>
</li>
<li><p>光的传播</p>
<ul>
<li>光每次经过反射、投射都会对光的能量分布产生影响</li>
</ul>
</li>
</ul>
<h3 id="二、接收者"><a href="#二、接收者" class="headerlink" title="二、接收者"></a>二、接收者</h3><p>人眼接受色彩的特性</p>
<ul>
<li>相对亮度感知<ul>
<li>在暗的环境下看亮的东西会更亮</li>
</ul>
</li>
<li>人眼HDR<ul>
<li>人眼可以自动调整曝光</li>
<li>能够分辨高亮度当中的层次区别、阴影中物体的异同</li>
</ul>
</li>
<li>人眼感光细胞分布<ul>
<li>杆状细胞<ul>
<li>感知亮度，对亮度敏感</li>
</ul>
</li>
<li>锥状细胞<ul>
<li>感知色彩</li>
<li>L细胞（红色）、M细胞（绿色）、S细胞（蓝色）</li>
<li>根据这三种细胞分布可以得出，人眼对红色感知度最高，对蓝色感知度最低</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723141425478.png" alt="image-20220723141425478" style="zoom:50%;" />

<ul>
<li>接收公式<ul>
<li>$C&#x3D;\int S(\lambda)\cdot I(\lambda) \cdot R(\lambda)d\lambda$</li>
<li>C是人眼输出到大脑的神经电信号</li>
<li>S表示LMS三个感光细胞的感知分布</li>
<li>I表示光源的功率谱分布</li>
<li>R表示反射物体的吸收功率分布</li>
</ul>
</li>
</ul>
<h3 id="三、色彩空间"><a href="#三、色彩空间" class="headerlink" title="三、色彩空间"></a>三、色彩空间</h3><p>历史上人们对人眼感知色彩的猜测</p>
<ul>
<li>人们有100多种感受色彩的细胞</li>
<li>人眼有RGB三种感知细胞</li>
<li>人眼有黑白、红绿、黄蓝三种感知细胞</li>
</ul>
<h4 id="1905-Munsell色彩系统（美术角度）"><a href="#1905-Munsell色彩系统（美术角度）" class="headerlink" title="1905 Munsell色彩系统（美术角度）"></a><strong>1905 Munsell色彩系统</strong>（美术角度）</h4><p>（HSL色相饱和亮度）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723142131075.png" alt="image-20220723142131075" style="zoom:67%;" />



<h4 id="1931-CIE色彩系统（科学角度）"><a href="#1931-CIE色彩系统（科学角度）" class="headerlink" title="1931 CIE色彩系统（科学角度）"></a>1931 CIE色彩系统（科学角度）</h4><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723143907732.png" alt="image-20220723143907732" style="zoom:67%;" />



<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723144232530.png" alt="image-20220723144232530" style="zoom:67%;" />

<p>曲线覆盖的面积相等<br>$$<br>\int_0^\infin \bar r(\lambda)d\lambda&#x3D;\int_0^\infin \bar g(\lambda)d\lambda &#x3D; \int_0^\infin \bar b(\lambda)d\lambda<br>$$</p>
<p>红色基色强度有负数部分，虽然物理正确，但很不直观，不便使用，因此进行归一化，保证色彩在-1~1之间</p>
<p>归一化后，r’g’b’都在-1~1之间，r’+g’+b’&#x3D;1，可以通过其中两个计算另一个</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723144809678.png" alt="image-20220723144809678" style="zoom:34%;" />

<h4 id="1931-XYZ-色彩系统"><a href="#1931-XYZ-色彩系统" class="headerlink" title="1931 XYZ 色彩系统"></a>1931 XYZ 色彩系统</h4><ul>
<li>Color matching function</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723144427061.png" alt="image-20220723144427061" style="zoom:50%;" /></li>
</ul>
<p>XYZ与CIE 1931RGB的转换</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723145521683.png" alt="image-20220723145521683" style="zoom:50%;" />



<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723145726749.png" alt="image-20220723145726749" style="zoom:50%;" />

<p>在该图像上无法体现出亮度，于是在归一化的基础上把XYZ的Y拿出来与xy组成Yxy色彩空可能感觉，Y表示亮度，xy表示色彩</p>
<ul>
<li>问题<ul>
<li>色彩分布不均匀</li>
</ul>
</li>
</ul>
<h4 id="定义色彩空间"><a href="#定义色彩空间" class="headerlink" title="定义色彩空间"></a>定义色彩空间</h4><p>色彩空间满足的指标</p>
<ul>
<li>色域（三个基色的坐标，由此形成三角形）</li>
<li>Gamma（如何对三角形内进行切分）</li>
<li>白点（色域三角形中心）<ul>
<li>又称为E点或者D55点。白点用于定义色域的白色。相关关键词，白平衡。组成白点的各色能量频谱一致，因此白点的频谱是最平坦的。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723150148332.png" alt="image-20220723150148332" style="zoom:34%;" />

<p>sRGB的构成：在sRGB的色域与色域中心下，gamma&#x3D;2.2</p>
<h3 id="四、常用的色彩模型与色彩空间"><a href="#四、常用的色彩模型与色彩空间" class="headerlink" title="四、常用的色彩模型与色彩空间"></a>四、常用的色彩模型与色彩空间</h3><ul>
<li>色彩模型<ul>
<li>使用一定规则描述、排列颜色的方法</li>
<li>RGB、CMYK、LAB</li>
</ul>
</li>
<li>色彩空间<ul>
<li>需要至少满足三个指标<ul>
<li>色域、白点、Gamma</li>
</ul>
</li>
<li>CIE XYZ，Adobe RGB，sRGB，Japan Color 2001 Uncoated，US web Coated（后两个基于CMYK）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723150723307.png" alt="image-20220723150723307"></p>
<h3 id="五、色彩空间转换"><a href="#五、色彩空间转换" class="headerlink" title="五、色彩空间转换"></a>五、色彩空间转换</h3><p>这里直接复制一段几年前写的色彩模型转换的笔记</p>
<h5 id="HSV-RGB"><a href="#HSV-RGB" class="headerlink" title="HSV-RGB"></a>HSV-RGB</h5><p>在实际使用中，以$photoshop$为例，其色彩模型数值取值为：</p>
<p>​	$H取0-360，S，V取0-100%（实际用户输入调整数值范围为0-100）,此处计算取0-1较方便$</p>
<p>​	$RGB均取0-255$</p>
<p>$$<br>C&#x3D;V\times S<br>\X&#x3D;C\times(1-|(H&#x2F;60^\circ)mod\ 2-1|)<br>\m&#x3D;V-C\<br>(R’,G’,B’)&#x3D;\left{\begin{array}{}<br>(C,X,0)&amp;,0^\circ\leq H&lt;60^\circ\<br>(X,C,0)&amp;,60^\circ\leq H&lt;120^\circ\<br>(0,C,x)&amp;,120^\circ\leq H&lt;180^\circ\<br>(0,X,C)&amp;,180^\circ\leq H&lt;240^\circ\<br>(X,0,C)&amp;,240^\circ\leq H&lt;300^\circ\<br>(C,0,X)&amp;,300^\circ\leq H&lt;360^\circ\<br>\end{array}{}\right.<br>\(R,G,B)&#x3D;\frac{(R’+m,G’+m,B’+m)}{255}<br>$$<br>该式子理解如下：</p>
<p>将红(R),黄(Y),绿(G),青(M),蓝(B),品红(C),红(R)</p>
<p>均匀放在一条轴上，采用<strong>线性插值</strong>的方式画出色相,如图</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/%E8%89%B2%E5%BD%A9%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC2.png" alt="色彩线性插值2"></p>
<p>如图，横坐标分布$H$，纵坐标的最低值$V(1-S)$即是$m$，因为是线性插值计算，所以RGB呈折线式分布，根据图理解，可以如下改进原公式<br>$$<br>C&#x3D;V(最高阈值)\<br>m&#x3D;V(1-S)(最低阈值)\<br>在图像处理应用中提取图像亮部或暗部，若想要改变容差，则只需要改变阈值<br>\<br>X&#x3D;V\times S\times (1-|H&#x2F;60| mod 2-1)+m\(该式可以直接表达线性插值混合部分的折线（锯齿状线条）)<br>\(R,G,B)&#x3D;255\times \left{\begin{array}{}<br>(C,X,m)&amp;,0^\circ\leq H&lt;60^\circ\<br>(X,C,m)&amp;,60^\circ\leq H&lt;120^\circ\<br>(m,C,x)&amp;,120^\circ\leq H&lt;180^\circ\<br>(m,X,C)&amp;,180^\circ\leq H&lt;240^\circ\<br>(X,m,C)&amp;,240^\circ\leq H&lt;300^\circ\<br>(C,m,X)&amp;,300^\circ\leq H&lt;360^\circ\<br>\end{array}{}\right.<br>$$</p>
<h5 id="RGB-HSV"><a href="#RGB-HSV" class="headerlink" title="RGB-HSV"></a>RGB-HSV</h5><p>$$<br>R’,G’,B’&#x3D;\frac{R,G,B}{255}\<br>Cmax&#x3D;max(R,G,B)<br>\Cmin&#x3D;min(R,G,B)<br>\\Delta&#x3D;Cmax-Cmin<br>$$</p>
<p>$H(hue)$<br>$$<br>H&#x3D;\left{\begin{array}{}0^\circ&amp; \Delta &#x3D;0\60^\circ \times(\frac{G’-B’}{\Delta}mod\ 6)&amp;,Cmax&#x3D;R’\60^\circ \times(\frac{B’-R’}{\Delta}+2)&amp;,Cmax&#x3D;G’\60^\circ \times(\frac{R’-G’}{\Delta}+4)&amp;,Cmax&#x3D;B’\end{array}{}\right.<br>$$<br>$S(saturation)$<br>$$<br>S&#x3D;\left{\begin{array}{}0&amp;,Cmax&#x3D;0\\frac{\Delta}{Cmax}&amp;,Cmax\neq0\end{array}{}\right.<br>$$<br>$V(value)$<br>$$<br>V&#x3D;Cmax<br>$$</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul>
<li><p>色彩空间的定义</p>
<ul>
<li>基于CIE XYZ色彩空间，确定一定的色域、白点，以及特定的gamma采样方式，所决定出的色彩区域。</li>
</ul>
</li>
<li><p>人眼可见光范围</p>
<ul>
<li>390nm~760nm</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Qb4y1S7CC">https://www.bilibili.com/video/BV1Qb4y1S7CC</a> 【技术美术百人计划】图形 2.1 色彩空间介绍</p>
<p>[2] <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43280713/article/details/84133949">https://blog.csdn.net/weixin_43280713/article/details/84133949</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/freshair_cnblog/p/11493706.html">https://www.cnblogs.com/freshair_cnblog/p/11493706.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.1%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/" data-id="cmfe1kyau001rykuhe52e8mhb" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.2模型与材质基础" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.2%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9D%90%E8%B4%A8%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形2-2模型与材质基础"><a href="#图形2-2模型与材质基础" class="headerlink" title="图形2.2模型与材质基础"></a>图形2.2模型与材质基础</h2><h3 id="一、渲染管线与模型基础"><a href="#一、渲染管线与模型基础" class="headerlink" title="一、渲染管线与模型基础"></a>一、渲染管线与模型基础</h3><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723154809728.png" alt="image-20220723154809728" style="zoom:80%;" />

<h4 id="uv"><a href="#uv" class="headerlink" title="uv"></a>uv</h4><p>在建模软件中完成UV展开，UV放置在一个横向u，纵向v，（0-1）的二维坐标系中</p>
<p>展开后的uv在sp等软件中绘制贴图</p>
<h4 id="模型信息"><a href="#模型信息" class="headerlink" title="模型信息"></a>模型信息</h4><p>模型的表达（以obj为例）</p>
<ul>
<li>v顶点坐标</li>
<li>vt对应纹理坐标 texcoord</li>
<li>vn顶点法线</li>
<li>f面</li>
<li>顶点色（fbx）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>#</strong></th>
<th><strong>obj格式</strong></th>
<th><strong>fbx格式</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>多个object</td>
<td>支持</td>
<td>支持</td>
<td>在文件中存放多个三维模型</td>
</tr>
<tr>
<td>单object拥有多个材质</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>Polygons面</td>
<td>支持</td>
<td>支持</td>
<td>易于被3ds max等软件编辑加工  注：导入到ue4时，必须为三角形面</td>
</tr>
<tr>
<td>Normal</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>Material</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>光滑组（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Smoothing_group">Smoothing Group</a>）</td>
<td>支持</td>
<td>支持</td>
<td>光滑组中的点或面使用平均法线来计算光照，使得整个mesh区域看起来更平滑</td>
</tr>
<tr>
<td>uv套数</td>
<td>1</td>
<td>多套</td>
<td></td>
</tr>
<tr>
<td>顶点Color</td>
<td>不支持</td>
<td>支持</td>
<td>导入ue4时，Vertex Color Import Option设置为Replace</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/zh-CN/Engine/Content/Importing/FBX/StaticMeshes/#%E9%9D%99%E6%80%81%E7%BD%91%E6%A0%BC%E4%BD%93lod">ue4 lod</a></td>
<td>不支持</td>
<td>支持</td>
<td>导入ue4时，勾选Import Mesh LODs</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/zh-CN/Engine/Content/Importing/FBX/StaticMeshes/#%E7%A2%B0%E6%92%9E">ue4 simple collision</a></td>
<td>支持</td>
<td>支持</td>
<td>任意凸体碰撞命名规则：UCX_[RenderMeshName]、UCX_[RenderMeshName]_00</td>
</tr>
<tr>
<td>socket插槽</td>
<td>不支持</td>
<td>支持</td>
<td>命名规则：SOCKET_[RenderMeshName]、SOCKET_[RenderMeshName]_01</td>
</tr>
<tr>
<td>skeleton骨骼</td>
<td>不支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>skeletal mesh网格</td>
<td>不支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>animation sequence</td>
<td>不支持</td>
<td>支持</td>
<td>fbx可在文件中存放多个动作序列</td>
</tr>
</tbody></table>
<h3 id="二、材质基础"><a href="#二、材质基础" class="headerlink" title="二、材质基础"></a>二、材质基础</h3><ul>
<li><p>材质</p>
<ul>
<li><p>描述物体对光的接收与散射</p>
</li>
<li><p>漫反射</p>
</li>
<li><p>镜面反射</p>
</li>
<li><p>折射</p>
<ul>
<li>菲涅尔定律可以描述反射与折射的比例</li>
</ul>
</li>
<li><p>粗糙镜面反射glossy（磨砂金属）</p>
</li>
<li><p>粗糙镜面折射（毛玻璃）</p>
</li>
<li><p>多层材质</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723160309345.png" alt="image-20220723160309345" style="zoom:50%;" />
</li>
<li><p>次表面散射（Subsurface scattering）</p>
<ul>
<li><p>光线传入物体内部后，经过多次弹射再离开物体表面</p>
</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723160453573.png" alt="image-20220723160453573" style="zoom:80%;" />
</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723160606384.png" alt="image-20220723160606384" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>改变材质表面</p>
<ul>
<li>使用法线贴图对法线做出调整，影响光照计算的结果</li>
</ul>
</li>
</ul>
<h3 id="三、模型数据解析"><a href="#三、模型数据解析" class="headerlink" title="三、模型数据解析"></a>三、模型数据解析</h3><ul>
<li><p>顶点动画</p>
<ul>
<li>在vs中改变模型的顶点位置，达到模型运动的效果</li>
<li>（需要一定数量的顶点，效果才比较明显）</li>
</ul>
</li>
<li><p>纹理动画</p>
<ul>
<li>在fs中修改模型uv信息，使采样贴图时发生位移而产生运动效果</li>
</ul>
</li>
<li><p>顶点色</p>
<ul>
<li>在渲染时影响输出结果，控制颜色范围</li>
<li>例：当前顶点色达到一定值，就认定为阴影中</li>
<li>片元当中使用重心坐标插值</li>
</ul>
</li>
<li><p>顶点法线与面法线</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723162706622.png" alt="image-20220723162706622" style="zoom: 67%;" />

<h3 id="四、扩展"><a href="#四、扩展" class="headerlink" title="四、扩展"></a>四、扩展</h3><p>NPR中，通常在vs中将顶点往法线方向偏移（模型背面），然后在fs中直接输出一个颜色，达到描边效果。</p>
<p>BackFacing描边时，线条断开就是因为没有平滑顶点之间的法线（面法线外扩），法线不连续导致的。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723162821829.png" alt="image-20220723162821829" style="zoom:80%;" />



<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="顶点色还可以做什么"><a href="#顶点色还可以做什么" class="headerlink" title="顶点色还可以做什么"></a>顶点色还可以做什么</h4><ul>
<li>在渲染上<ul>
<li>直接作为物体颜色</li>
<li>与贴图颜色混合。</li>
<li>取代一些光照：如教程中罪恶装备案例对阴影的处理</li>
</ul>
</li>
<li>其他应用<ul>
<li>不直接用于渲染，正如贴图，顶点色还可以储存其他信息、属性</li>
</ul>
</li>
</ul>
<h4 id="模型光滑组对法线有什么影响"><a href="#模型光滑组对法线有什么影响" class="headerlink" title="模型光滑组对法线有什么影响"></a>模型光滑组对法线有什么影响</h4><p>首先要知道什么是光滑组，这其实也是我第一次见这个名词。</p>
<p>光滑组：（smoothing group）是用来设置边缘线的光滑显示的。</p>
<p>光滑组定义了模型边缘渲染的方式（flat shading和Gouraud&#x2F;Phong shading），也就是101中所说的着色频率（Shading frequencies）</p>
<p>这也就控制了所说的边缘“软硬”</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/20210720084550788.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p>那这样回答这个问题就很简单了</p>
<p>Flat shading使用的是面法线；gouraud shading使用的是顶点法线；在vs中计算顶点着色，片元对颜色插值；phong shading使用顶点法线，片元上对法线插值后，在fs中计算光照。</p>
<p>光滑组所做的也就是决定模型哪些部分采用法线插值</p>
<p>因此光滑组的作用也很有趣，让一个模型的着色方式不同，来表现同一模型的不同细节。</p>
<h5 id="过渡部分"><a href="#过渡部分" class="headerlink" title="过渡部分"></a>过渡部分</h5><p>尝试了Maya中对应的“软硬边”功能，因为非常值得思考的是，在光滑组与非光滑组的过渡部分如何处理？</p>
<center>
<figure>
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723175542376.png" alt="image-20220723175542376" style="width: 30%;display:inline;margin:0" />
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723175557394.png" alt="image-20220723175557394" style="width: 34%;display:inline;margin:0" />
</figure>
</center>









<p>我们来研究这里的细节。首先对于完整的硬边三角形和软边三角形不必说。</p>
<p>对于硬边三角形的顶点法线，就是面法线，因此，4个硬边相接的顶点上，出现了4个顶点法线，分别是用1256这四个面法线代替的。关注2354这里的顶点法线，只有完整的硬边面5，还保持着面法线，</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723180155081.png" alt="image-20220723180155081" style="zoom:50%;" />

<p>我尝试对这个顶点剩余的硬边进行软化，观察这个顶点法线是否变化</p>
<center>
    <figure>
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723180950650.png" alt="image-20220723180950650" style="width:40%;display:inline;margin:0" />
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723181006044.png" alt="image-20220723181006044" style="width:40%;display:inline;margin:0" />
    </figure>
</center>

<p>出现明显的偏移，因此可以得出结论</p>
<p>软边会使相邻两个面的面法线进行插值得到一个顶点法线。</p>
<p>像这里4条边，只需要3条软边，就完成了周围四个面法线（其实是面法线所代替的4个顶点法线）的插值得到的顶点法线，这和4条软边是一样的。</p>
<center>
    <figure>
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723182303248.png" alt="image-20220723182303248" style="width:34%;display:inline;margin:0" />
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723182545394.png" alt="image-20220723182545394" style="width:40%;display:inline;margin:0" />
    </figure>
</center>

<p>研究了半天，放了个最简单的例子，其实就理解为软边会使相邻两个面法线插值好了</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723185549252.png" alt="image-20220723185549252"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kh411U7F7">https://www.bilibili.com/video/BV1kh411U7F7</a> 【技术美术百人计划】图形 2.2 模型与材质基础</p>
<p>[2]<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a> GAMES101-现代计算机图形学入门-闫令琪</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.2%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9D%90%E8%B4%A8%E5%9F%BA%E7%A1%80/" data-id="cmfe1kyaw001tykuh2u1f6ldr" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.3常用函数介绍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.3%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形2-3-常用函数介绍（HLSL）"><a href="#图形2-3-常用函数介绍（HLSL）" class="headerlink" title="图形2.3 常用函数介绍（HLSL）"></a>图形2.3 常用函数介绍（HLSL）</h1><p>微软文档HLSL内部函数：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions</a></p>
<h3 id="一、基本数学运算"><a href="#一、基本数学运算" class="headerlink" title="一、基本数学运算"></a>一、基本数学运算</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(a,b)<span class="comment">//最大值</span></span><br><span class="line"><span class="built_in">min</span>(a,b)<span class="comment">//最小值</span></span><br><span class="line">mul(a,b)<span class="comment">//变量相乘，矩阵、向量运算（a是向量则看作行向量，b是向量则看作列向量）</span></span><br><span class="line"><span class="built_in">abs</span>(a)<span class="comment">//绝对值</span></span><br><span class="line"><span class="built_in">round</span>(x)<span class="comment">//最接近的整数</span></span><br><span class="line"><span class="built_in">sqrt</span>(x)<span class="comment">//平方根</span></span><br><span class="line">rsqrt(x)<span class="comment">//平方根倒数</span></span><br><span class="line"><span class="built_in">degrees</span>(x)<span class="comment">//弧度转角度</span></span><br><span class="line">redians(x)<span class="comment">//角度转弧度</span></span><br><span class="line">noise(x)<span class="comment">//噪声函数</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/XirtyqUXBhtPF1TVBTHfSA" alt="img" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/PoFwPqTWyla31R3yk3012w" alt="img" style="zoom:50%;" />

<h3 id="二、幂指对函数"><a href="#二、幂指对函数" class="headerlink" title="二、幂指对函数"></a>二、幂指对函数</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pow</span>(x,y);<span class="comment">//x^y</span></span><br><span class="line"><span class="built_in">exp</span>(x);<span class="comment">//e^x</span></span><br><span class="line"><span class="built_in">exp2</span>(x);<span class="comment">//2^x</span></span><br><span class="line"><span class="built_in">ldexp</span>(x, <span class="built_in">exp</span>);<span class="comment">//x*2^exp</span></span><br><span class="line"><span class="built_in">log</span>(x);<span class="comment">//lnx</span></span><br><span class="line">log10(x);<span class="comment">//log_10 x</span></span><br><span class="line"><span class="built_in">log2</span>(x);<span class="comment">//log_2 x</span></span><br><span class="line"><span class="built_in">frexp</span>(x, <span class="keyword">out</span> <span class="built_in">exp</span>);<span class="comment">//把浮点数x分解为尾数mantissa和指数 x = ret * 2^exp，返回值是位数，exp参数返回的值是指数（如果x参数为0，则尾数和指数均返回0）</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/_yUmM743gYLSz4W_MD43_A" alt="img" style="zoom:50%;" />

<h3 id="三、三角函数与双曲函数"><a href="#三、三角函数与双曲函数" class="headerlink" title="三、三角函数与双曲函数"></a>三、三角函数与双曲函数</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sin</span>(x);<span class="built_in">cos</span>(x);<span class="built_in">tan</span>(x);<span class="comment">//x均为弧度</span></span><br><span class="line">sincos(x, <span class="keyword">out</span> s, <span class="keyword">out</span> c);<span class="comment">//返回x的正弦值和余弦值</span></span><br><span class="line"><span class="built_in">tan</span>(y,x);<span class="comment">//返回y/x的正切值</span></span><br><span class="line"><span class="built_in">asin</span>(x);<span class="comment">//反正弦</span></span><br><span class="line"><span class="built_in">acos</span>(x);<span class="comment">//反余弦</span></span><br><span class="line"><span class="built_in">atan</span>(x);<span class="comment">//反正切</span></span><br><span class="line">atan2(y,x);<span class="comment">//输出y/x的反正切</span></span><br><span class="line"><span class="built_in">sinh</span>(x);<span class="comment">//双曲正弦,(e^x-e^(-x))/2</span></span><br><span class="line"><span class="built_in">cosh</span>(x);<span class="comment">//双曲余弦,(e^x+e^(-x))/2</span></span><br><span class="line"><span class="built_in">tanh</span>(x);<span class="comment">//双曲正切,(e^x-e^(-x))/(e^x+e^(-x))</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/-LFsB20otdFaLNoYINhjAw" alt="img" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/Vg17wEEh7tRZ3NIyopuNxA" alt="img" style="zoom:50%;" />

<h3 id="四、数据范围类"><a href="#四、数据范围类" class="headerlink" title="四、数据范围类"></a>四、数据范围类</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ceil</span>(x);<span class="comment">//向上取整</span></span><br><span class="line"><span class="built_in">floor</span>(x);<span class="comment">//向下取整</span></span><br><span class="line"><span class="built_in">step</span>(x,y);<span class="comment">//x&lt;=y为1，否则为0</span></span><br><span class="line">saturate(x);<span class="comment">//返回将x钳制到0和1之间的值</span></span><br><span class="line"><span class="built_in">clamp</span>(x,<span class="built_in">min</span>,<span class="built_in">max</span>);<span class="comment">//把x限制在[min,max]范围内，</span></span><br><span class="line">fmord(x,y);<span class="comment">//返回x对y取余的余数</span></span><br><span class="line">frac(x);<span class="comment">//返回x的小数部分</span></span><br><span class="line"><span class="built_in">modf</span>(x, <span class="keyword">out</span> ip);<span class="comment">//将x分为小数和整数部分（符号与x相同），ip返回整数部分，整体返回小数部分</span></span><br><span class="line">lerp(x,y,s);<span class="comment">//按照s在x到y之间插值（x*(1-s)+y*s）</span></span><br><span class="line"><span class="built_in">smoothstep</span>(<span class="built_in">min</span>,<span class="built_in">max</span>,x);<span class="comment">//如果x在min和max范围内，则返回01之间的平滑Hermite插值，使用smoothstep在两个值之间创建平滑过渡。例如平滑混合两种颜色</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/cSnp8bVk3apu9oljyC2FfA" alt="img" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/SYF5uMwuuk_PaEZ6aR3G_Q" alt="img" style="zoom:50%;" />

<h3 id="五、类型判断类"><a href="#五、类型判断类" class="headerlink" title="五、类型判断类"></a>五、类型判断类</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">all</span>(x);<span class="comment">//确定x所有分量是否均为非零，均非零则返回true，否则false（处理浮点型、整形、布尔型数据定义的标量、向量或矩阵）</span></span><br><span class="line">clip(x);<span class="comment">//如果x小于零，则丢弃当前像素，常用于判定范围（不仅针对0，返回值为void）。常用于测试alpha，如果每个分量代表到平面距离，还可用来模拟剪切平面</span></span><br><span class="line"><span class="built_in">sign</span>(x);<span class="comment">//返回x正负性，小于0为-1，大于0为1，0则返回0</span></span><br><span class="line"><span class="built_in">isinf</span>(x);<span class="comment">//x为+INF或-INF则为true，否则false</span></span><br><span class="line">isfinite(x);<span class="comment">//判断x是有限的，与isinf相反</span></span><br><span class="line"><span class="built_in">isnan</span>(x);<span class="comment">//如果x为NAN(非数字),返回true，否则false</span></span><br></pre></td></tr></table></figure>

<h3 id="六、向量与矩阵类"><a href="#六、向量与矩阵类" class="headerlink" title="六、向量与矩阵类"></a>六、向量与矩阵类</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">length</span>(v);<span class="comment">//向量模长</span></span><br><span class="line"><span class="built_in">normalize</span>(v);<span class="comment">//x/length(x)归一化</span></span><br><span class="line"><span class="built_in">distance</span>(a,b);<span class="comment">//向量之间的距离（表示的点的距离）</span></span><br><span class="line"><span class="built_in">dot</span>(a,b);<span class="comment">//点乘</span></span><br><span class="line"><span class="built_in">cross</span>(a,b);<span class="comment">//叉乘</span></span><br><span class="line"><span class="built_in">determinant</span>(m);<span class="comment">//矩阵m的行列式</span></span><br><span class="line"><span class="built_in">transpose</span>(m);<span class="comment">//m的转置矩阵</span></span><br></pre></td></tr></table></figure>

<h3 id="七、光线运算"><a href="#七、光线运算" class="headerlink" title="七、光线运算"></a>七、光线运算</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意所有的入射方向都表示入射方向的相反方向</span></span><br><span class="line"><span class="built_in">reflect</span>(i,n);<span class="comment">//计算入射方向i对于法线n的反射方向</span></span><br><span class="line">fefract(i,n,ri);<span class="comment">//入射方向i，法线n，ri折射率，计算折射方向</span></span><br><span class="line">lit(n_dot_l,n_dot_h,m);<span class="comment">//返回照明系数向量(ambient,diffuse,specular,1)</span></span><br><span class="line"><span class="comment">//ambient=1</span></span><br><span class="line"><span class="comment">//diffuse = ndotl&lt;0 ? 0 : ndotl</span></span><br><span class="line"><span class="comment">//specular = ndotl&lt;0 || ndoth &lt; 0 ? 0: ndoth^m</span></span><br><span class="line"><span class="built_in">faceforward</span>(n,i,ng);<span class="comment">//输出法线n，输入视线方向i，表面法线方向ng，反转表面法线（如有必要）以面向和i相反的方向，在n中返回结果</span></span><br><span class="line"><span class="comment">//返回-n*sign(dot(i,ng))</span></span><br></pre></td></tr></table></figure>

<h3 id="八、1D纹理查找（几乎不用）"><a href="#八、1D纹理查找（几乎不用）" class="headerlink" title="八、1D纹理查找（几乎不用）"></a>八、1D纹理查找（几乎不用）</h3><p>函数ddx，ddy用于求取相邻像素间某属性的差值；输入参数通常是纹理坐标，返回相邻像素间的属性差值；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tex1D(s,t);<span class="comment">//一维纹理查找，返回纹理采样器s在标量t位置的color4</span></span><br><span class="line">tex1D(s,t,ddx,ddy);<span class="comment">//微分查询一维纹理ddx,ddy均为向量</span></span><br><span class="line">tex1Dlod(s,t);<span class="comment">//使用LOD查找纹理s在t.w位置的color4</span></span><br><span class="line">tex1Dbias(s,t);<span class="comment">//t.w决定的某个mip层偏置后的一维纹理查找</span></span><br><span class="line">tex1Dgrad(s,t,ddx,ddy);<span class="comment">//使用微分并指定mip层的一维纹理查找</span></span><br><span class="line">tex1Dproj(s,t);<span class="comment">//把纹理当作一张幻灯片投影到场景中，计算出投影纹理坐标t(t.w除以透视值),然后使用投影纹理坐标查询</span></span><br></pre></td></tr></table></figure>

<h3 id="九、2D纹理查找"><a href="#九、2D纹理查找" class="headerlink" title="九、2D纹理查找"></a>九、2D纹理查找</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tex2D(s,t);<span class="comment">//二维纹理查找，返回纹理采样器s在t(x,y)位置的color4</span></span><br><span class="line">tex2D(s,t,ddx,ddy);<span class="comment">//微分查询二维纹理t,ddx,ddy均为向量</span></span><br><span class="line">tex2Dlod(s,t);<span class="comment">//使用LOD查找纹理s在t.w位置的color4</span></span><br><span class="line">tex2Dbias(s,t);<span class="comment">//t.w决定的某个mip层偏置后的二维纹理查找</span></span><br><span class="line">tex2Dgrad(s,t,ddx,ddy);<span class="comment">//使用微分并指定mip层的二维纹理查找</span></span><br><span class="line">tex2Dproj(s,t);<span class="comment">//把纹理当作一张幻灯片投影到场景中，计算出投影纹理坐标t(t.w除以透视值),然后使用投影纹理坐标查询</span></span><br></pre></td></tr></table></figure>

<h3 id="十、3D纹理查找"><a href="#十、3D纹理查找" class="headerlink" title="十、3D纹理查找"></a>十、3D纹理查找</h3><p>3D纹理资源（体积纹理），包含3D体积的纹理像素</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tex3D(s,t);<span class="comment">//三维纹理查找，返回纹理采样器s在vec t位置的color4</span></span><br><span class="line">tex3D(s,t,ddx,ddy);<span class="comment">//微分查询三维纹理t,ddx,ddy均为向量</span></span><br><span class="line">tex3Dlod(s,t);<span class="comment">//使用LOD查找纹理s在t.w位置的color4</span></span><br><span class="line">tex3Dbias(s,t);<span class="comment">//t.w决定的某个mip层偏置后的立方体纹理查找</span></span><br><span class="line">tex3Dgrad(s,t,ddx,ddy);<span class="comment">//使用微分并指定mip层的立方体纹理查找</span></span><br><span class="line">tex3Dproj(s,t);<span class="comment">//使用投影方式的立方体文里查找</span></span><br></pre></td></tr></table></figure>

<h3 id="十一、立体纹理查找"><a href="#十一、立体纹理查找" class="headerlink" title="十一、立体纹理查找"></a>十一、立体纹理查找</h3><p>指CubeMap</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">texCUBE(s,t);<span class="comment">//返回纹理采样器s在vec t位置的color4</span></span><br><span class="line">texCUBE(s,t,ddx,ddy);<span class="comment">//微分查询立方体纹理t,ddx,ddy均为向量</span></span><br><span class="line">texCUBElod(s,t);<span class="comment">//使用LOD查找纹理s在t.w位置的color4</span></span><br><span class="line">texCUBEbias(s,t);<span class="comment">//t.w决定的某个mip层偏置后的三维纹理查找</span></span><br><span class="line">texCUBEgrad(s,t,ddx,ddy);<span class="comment">//使用微分并指定mip层的三维纹理查找</span></span><br><span class="line">texCUBEproj(s,t);<span class="comment">//把纹理当作一张幻灯片投影到场景中，计算出投影纹理坐标t(t.w除以透视值),然后使用投影纹理坐标查询</span></span><br></pre></td></tr></table></figure>

<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><ul>
<li>写出最常用的5个函数<ul>
<li>dot，mul，normalize，tex2d，pow</li>
</ul>
</li>
<li>这是我当前感觉最常用的，dot和mul不必说，向量矩阵运算必备；而由于光照计算中使用方向，常常需要对向量归一化；有贴图就有纹理采样；最后这个pow方法，看看各种光照模型的公式里，就有很多地方出现幂运算了。</li>
<li>ddx ddy的实际使用测试</li>
</ul>
<h4 id="ddx-ddy与法线贴图"><a href="#ddx-ddy与法线贴图" class="headerlink" title="ddx&#x2F;ddy与法线贴图"></a><strong>ddx&#x2F;ddy与法线贴图</strong></h4><h5 id="ddx-ddy计算法线"><a href="#ddx-ddy计算法线" class="headerlink" title="ddx&#x2F;ddy计算法线"></a><strong>ddx&#x2F;ddy计算法线</strong></h5><p>首先ddx与ddy是两个函数，完整的表达是ddx(m),ddy(m)。</p>
<p>在glsl中，它相当于dFdx(m),dFdy(m)。</p>
<p>这两个函数只能作用于片元着色器中，根据他们的作用也很好理解这一点。</p>
<p>我们需要提供一个属性，然后这个函数会计算当前片元在屏幕空间中，沿x或y方向关于这个属性的偏导，因为片元是离散的，当然是以差分形式。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/6271001-7e5f13306d7c9131.png" alt="img" style="zoom: 33%;" />

<p>如果是考虑<strong>世界空间位置</strong>这一属性，我的理解是，对于当前着色点，计算的是这两个方向的切线方向。</p>
<p>于是有一个通常的法线计算方法</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normal = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(ddx(pos),ddy(pos)));</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220728230748527.png" alt="image-20220728230748527"></p>
<p>左边是ddx，ddy计算出的法线，右边是顶点法线在fs中插值的法线。</p>
<p>很明显，这两者就好像flat shading和phong shading的关系。仔细想想确实如此。不考虑着色，只考虑几何信息，这个球体本来就是三角网格</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220728230953252.png" alt="image-20220728230953252"></p>
<p>对于三角形上的一个点的法线，使用切线叉乘计算的法线当然是原原本本的网格法线。而右边的法线是顶点法线插值。</p>
<p>在unity中还原flat shading或是low poly风格的渲染，确实会采用ddx和ddy的方法。</p>
<h5 id="ddx-ddy与法线贴图-1"><a href="#ddx-ddy与法线贴图-1" class="headerlink" title="ddx&#x2F;ddy与法线贴图"></a><strong>ddx&#x2F;ddy与法线贴图</strong></h5><p>learnopengl中这一段代码给我留下了深刻印象。当时用的时候完全不知道dFdx是做什么的，只能硬着头皮用了。现在我们已经了解了ddx函数，再回过头来看一下它对发现贴图的处理。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Easy trick to get tangent-normals to world-space to keep PBR code simplified.</span></span><br><span class="line"><span class="comment">// Don&#x27;t worry if you don&#x27;t get what&#x27;s going on; you generally want to do normal </span></span><br><span class="line"><span class="comment">// mapping the usual way for performance anways; I do plan make a note of this </span></span><br><span class="line"><span class="comment">// technique somewhere later in the normal mapping tutorial.</span></span><br><span class="line"><span class="type">vec3</span> getNormalFromMap()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> tangentNormal = <span class="built_in">texture</span>(normalMap, TexCoords).xyz * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> Q1  = <span class="built_in">dFdx</span>(WorldPos);</span><br><span class="line">    <span class="type">vec3</span> Q2  = <span class="built_in">dFdy</span>(WorldPos);</span><br><span class="line">    <span class="type">vec2</span> st1 = <span class="built_in">dFdx</span>(TexCoords);</span><br><span class="line">    <span class="type">vec2</span> st2 = <span class="built_in">dFdy</span>(TexCoords);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> N   = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> T  = <span class="built_in">normalize</span>(Q1*st2.t - Q2*st1.t);</span><br><span class="line">    <span class="type">vec3</span> B  = -<span class="built_in">normalize</span>(<span class="built_in">cross</span>(N, T));</span><br><span class="line">    <span class="type">mat3</span> TBN = <span class="type">mat3</span>(T, B, N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>(TBN * tangentNormal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心就是求TBN矩阵嘛。N向量和B向量都很好理解，一个直接就是模型法线，一个就是由叉乘计算的副切线。</p>
<p>问题就在于切线的计算。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> T  = <span class="built_in">normalize</span>(Q1*st2.t - Q2*st1.t);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/normal_mapping_surface_edges.png" alt="img"></p>
<p>（这里把E1看作Q1，E2看作Q2）</p>
<p>$E_1&#x3D;ΔU_1T+ΔV_1B$</p>
<p>$E_2&#x3D;ΔU_2T+ΔV_2B$</p>
<p>这样再结合cpu计算TBN的方法，就很好理解了。</p>
<p>似乎后面的课程马上就会到法线贴图的部分，到时候再详述好了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1q64y1m7Ev">https://www.bilibili.com/video/BV1q64y1m7Ev</a> 【技术美术百人计划】图形 2.3 常用函数介绍</p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7fc6a2fef29d">https://www.jianshu.com/p/7fc6a2fef29d</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/1.2.lighting_textured/1.2.pbr.fs">https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/1.2.lighting_textured/1.2.pbr.fs</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484182779">https://zhuanlan.zhihu.com/p/484182779</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.3%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/" data-id="cmfe1kyax001xykuh6cjd6qlp" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.4 传统经验光照模型" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.4%20%E4%BC%A0%E7%BB%9F%E7%BB%8F%E9%AA%8C%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形2-4-传统经验光照模型"><a href="#图形2-4-传统经验光照模型" class="headerlink" title="图形2.4 传统经验光照模型"></a>图形2.4 传统经验光照模型</h2><ul>
<li>经验模型</li>
</ul>
<p>对真实光照的模拟，简化了真实光照的计算，并且有不错的效果</p>
<ul>
<li>基于物理理论的光照模型</li>
</ul>
<p>使用物理的度量和统计方法，效果非常真实，但是计算困难，实现也较困难</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220727115123646.png" alt="image-20220727120611504"></p>
<h3 id="一、局部光照模型"><a href="#一、局部光照模型" class="headerlink" title="一、局部光照模型"></a><strong>一、局部光照模型</strong></h3><p>只关心直接光照部分</p>
<h4 id="1-1-Lambert余弦定律"><a href="#1-1-Lambert余弦定律" class="headerlink" title="1.1 Lambert余弦定律"></a><strong>1.1 Lambert余弦定律</strong></h4><p>光源每秒发出的能量为辐射通量$P$</p>
<p>单位面积接受的光照为辐射通量密度（辐照度）$P&#x2F;A$</p>
<p>当光源垂直照射的单位面积的辐照度为$E_1 &#x3D; P&#x2F;A_1$</p>
<p>当光束以某个角度照射到面积更大的平面上的辐射度为$E_2&#x3D;P&#x2F;A_2&#x3D;P\cos\theta&#x2F;A_1&#x3D;E_1\cos\theta$</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220727120541155.png" alt="image-20220727120541155"></p>
<h4 id="1-2-漫反射"><a href="#1-2-漫反射" class="headerlink" title="1.2 漫反射"></a><strong>1.2 漫反射</strong></h4><p>光线照射到模型表面时被均匀反射到各个方向<br>$$<br>C_{diffuse} &#x3D; C_{light}<em>albedo</em>ndotL<br>$$</p>
<h4 id="1-3-镜面反射-高光反射"><a href="#1-3-镜面反射-高光反射" class="headerlink" title="1.3 镜面反射(高光反射)"></a><strong>1.3 镜面反射(高光反射)</strong></h4><p>光线到达物体表面发生镜面反射，观察视线在反射光线的附近便能够观察到镜面反射。</p>
<p>镜面反射的反射率是根据菲涅尔效应决定的。</p>
<p>通常使用对应的反射贴图描述物体表面的反射率，并使用光泽度（粗糙度，反光度）描述高光范围的大小<br>$$<br>C_{specular}&#x3D;C_{lgiht}*m_{specular}<em>dot(v,r)^m<br>\r&#x3D;1-2ndotL</em>n<br>$$</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220727120611504.png" alt="image-20220727120611504"></p>
<h4 id="1-4-环境光"><a href="#1-4-环境光" class="headerlink" title="1.4 环境光"></a><strong>1.4 环境光</strong></h4><p>在局部光照模型中，没有考虑间接光照的影响，为了处理间接光照，引入Ambient环境光<br>$$<br>C_{ambient}&#x3D;Albedo*Ambient<br>$$<br>通常使用漫反射的反照率来指示环境光照的反射光量。（只计算了环境光照的漫反射）</p>
<h4 id="1-5-自发光"><a href="#1-5-自发光" class="headerlink" title="1.5 自发光"></a><strong>1.5 自发光</strong></h4><p>通常作为单独的一项加入光照模型，一般使用一张发光贴图描述物体自发光</p>
<h3 id="二、经典光照模型"><a href="#二、经典光照模型" class="headerlink" title="二、经典光照模型"></a>二、经典光照模型</h3><h4 id="2-1-Lambert光照模型"><a href="#2-1-Lambert光照模型" class="headerlink" title="2.1 Lambert光照模型"></a><strong>2.1 Lambert光照模型</strong></h4><p>理想漫反射<br>$$<br>L_o &#x3D; C_{diffuse}&#x3D;  C_{light}<em>albedo</em>ndotL<br>$$</p>
<h4 id="2-2-Phong光照模型"><a href="#2-2-Phong光照模型" class="headerlink" title="2.2  Phong光照模型"></a><strong>2.2  Phong光照模型</strong></h4><p>ambient环境光+lambert漫反射+高光<br>$$<br>L_o&#x3D;C_{ambient}+C_{diffuse}+C_{specular}\&#x3D;albedo<em>Ambient + C_{light}</em>(albedo*ndotL+m_{specular}*dot(v,r)^m )<br>$$</p>
<h4 id="2-3-Blinn-Phong光照模型"><a href="#2-3-Blinn-Phong光照模型" class="headerlink" title="2.3 Blinn-Phong光照模型"></a><strong>2.3 Blinn-Phong光照模型</strong></h4><p>在phong光照模型的基础上，使用ndotH代替vdotR<br>$$<br>h&#x3D;normalize(l+r)\<br>L_o&#x3D;C_{ambient}+C_{diffuse}+C_{specular}\&#x3D;albedo<em>Ambient + C_{light}</em>(albedo*ndotL+m_{specular}*dot(n,h)^m )<br>$$</p>
<h3 id="三、着色方法"><a href="#三、着色方法" class="headerlink" title="三、着色方法"></a><strong>三、着色方法</strong></h3><p>着色方法，或者说着色模型，跟光照模型没有任何关系</p>
<h4 id="3-1-Flat着色方法"><a href="#3-1-Flat着色方法" class="headerlink" title="3.1 Flat着色方法"></a><strong>3.1 Flat着色方法</strong></h4><p>面着色，顾名思义以每一个面作为一个着色单位。模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/Flat%20Shading.png" alt="Flat Shading"></p>
<p>改进方法：改进方法就是对三角形面的每个顶点进行着色，再对三角形面内的颜色插值，即Gouraud Shading。</p>
<h4 id="3-2-Gouraud着色方法-几乎不用"><a href="#3-2-Gouraud着色方法-几乎不用" class="headerlink" title="3.2 Gouraud着色方法(几乎不用  )"></a><strong>3.2 Gouraud着色方法(几乎不用  )</strong></h4><p>顶点着色，片元着色通过顶点颜色插值</p>
<h4 id="3-3-Phong着色方法"><a href="#3-3-Phong着色方法" class="headerlink" title="3.3 Phong着色方法"></a><strong>3.3 Phong着色方法</strong></h4><p>求出三角形顶点法向，法向插值得到三角形内部每个片元的法向，精确计算着色。</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><h4 id="1-学习先行版-基础渲染光照介绍（一），并说出能量守恒的理念在基础光照模型中的作用。"><a href="#1-学习先行版-基础渲染光照介绍（一），并说出能量守恒的理念在基础光照模型中的作用。" class="headerlink" title="1.学习先行版 基础渲染光照介绍（一），并说出能量守恒的理念在基础光照模型中的作用。"></a>1.学习先行版 基础渲染光照介绍（一），并说出能量守恒的理念在基础光照模型中的作用。</h4><p>在光照模型当中，我们考虑不同的光源类型：环境光照（间接光照）与直接光照，将它们分开看待。实际上它们都是全局光照的一部分，我愿称之为“全局能量守恒 ”。</p>
<p>而对于某种光源，也有对于其本身的能量守恒，我愿称之为“局部能量守恒”。</p>
<p>那么局部能量守恒在光照模型中的表现其实就是<br>$$<br>入射光能量&#x3D;反射光能量 + 表面吸收能量<br>$$</p>
<h4 id="2-基于能量守恒的理念，自己写一套完整的光照模型，需要包含环境光照。"><a href="#2-基于能量守恒的理念，自己写一套完整的光照模型，需要包含环境光照。" class="headerlink" title="2.基于能量守恒的理念，自己写一套完整的光照模型，需要包含环境光照。"></a>2.基于能量守恒的理念，自己写一套完整的光照模型，需要包含环境光照。</h4><p>对于这个作业我的理解是，使用能量守恒的思想去改进传统光照模型 ，而不是直接实现一个cook-torrance模型。</p>
<h5 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a><strong>环境光照</strong></h5><p>那么首先来做一下环境光照，不妨来试一下cubeMap做的环境光。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texCUBElod(_CubeMap, float4(normal,<span class="number">0.0</span>));</span><br></pre></td></tr></table></figure>

<p> 严格上的IBL，也是要分成漫反射和镜面反射两部分</p>
<p>但是为了简化，就只取漫反射好了，</p>
<p>因为是第一次使用这个功能，在cubemap这里卡了一会儿。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729233520909.png" alt="image-20220729233520909" style="zoom:50%;" />

<p>这里对于卷积方式很自然地选择漫反射，并且按理来说，漫反射也不需要mip，于是我就关掉了生成Mip贴图选项，但是这样得到的贴图是错误的。只能把这个选项开启才是正常的。下面同样是第一级的mipmap，可以观察到漫反射和镜面反射的卷积结果还是有所区别的。</p>
<center>
    <figure>
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729233752792.png" alt="image-20220729233752792" style="width:40%;display:inline" />
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729233806108.png" alt="image-20220729233806108" style="width:40%;display:inline" />
    </figure>
</center>







<p>但是漫反射的卷积为什么要做mipmap呢？（不做的话结果是错的，不管什么卷积类型，除非是None）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729234005976.png" alt="image-20220729234005976" style="zoom:50%;" />

<p>以及这个mipmap的生成方式是什么呢？</p>
<p>查了下文档</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729235546954.png" alt="image-20220729235546954"></p>
<p>也就是说，Convolution的结果是 储存在mipmap里的，所以不开mipmap就会出错。</p>
<p>但是依然没有解决的问题是，&#x3D;&#x3D;对于diffuse来说，mipmap是怎么生成的？&#x3D;&#x3D;</p>
<p>这个问题，只能暂时先放一放了，当前的猜想是，这个diffuse并非理想漫反射，而是按照采样的区域去控制mipmap，0层级当然就只有法线方向，最高层级就是理想漫反射。</p>
<p>对于作业来说，就取一个层级的漫反射卷积环境光照好了</p>
<p>但是值得注意的是，在漫反射部分有一个小细节，无论是环境光还是直接光照。<br>$$<br>L_o(v) &#x3D; f_d\int_{l\in\Omega}L_i(l)\cos\theta dl<br>\ &#x3D; f_dL_i\int_{i\in\Omega}\cos\theta dl<br>\ &#x3D; \pi f_dL_i ,\pi f_d\in[0,1]<br>\f_d &#x3D; \frac{albedo}{\pi},albedo \in[0,1]<br>$$<br>这需要区别开albedo和漫反射的brdf，有这个pi的区别，因此我们才能直接用albedo*L_i</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 indirect_irradiance = texCUBElod(_CubeMap, float4(normal,<span class="number">1.0</span>));</span><br><span class="line">float3 indirect_diffuse = indirect_irradiance * albedo;</span><br></pre></td></tr></table></figure>

<h5 id="直接光照"><a href="#直接光照" class="headerlink" title="直接光照"></a><strong>直接光照</strong></h5><p>这部分就要考虑blinn-phong模型的改进了。</p>
<p>我们还是直接看渲染方程<br>$$<br>\int_{\Omega^+}f_rL_i\cos\theta d\theta\<br>&#x3D;\int_{\Omega^+}(f_d+f_s)L_i\cos\theta d\theta\<br>&#x3D;\int_{\Omega^+}f_dL_i\cos\theta d\theta+\int_{\Omega^+}f_sL_i\cos\theta d\theta<br>$$<br>这样将brdf拆开了两部分。</p>
<p>在这个过程中，看起来好像没有什么问题，但是这需要关系到如何定义这个f_d，f_s。问题的本质还是漫反射光和镜面反射光的关系，更深入的数学推导也许应该回归到BRDF的函数本质，或者说散射函数，暂时就不去研究了。总之，在这里的表达中，就是反射的光一部分进行了漫反射，一部分进行了高光反射。但是它们的总能量，等于反射光的能量。</p>
<p>在learnopengl中的表达，就是</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> kS = calculateSpecularComponent(...); <span class="comment">// 反射/镜面 部分</span></span><br><span class="line"><span class="type">float</span> kD = <span class="number">1.0</span> - ks;                        <span class="comment">// 折射/漫反射 部分</span></span><br></pre></td></tr></table></figure>

<p>我们可以理解为把这两个比例分配给了光的能量，也可以直接认为 这是属于BRDF的一部分。</p>
<p>就不说cook-torrance了，总之我们先人为提供一个因子。glossy好像是个不错的选择。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 kd = (<span class="number">255.0</span> - _Gloss)/<span class="number">255.0</span>;</span><br><span class="line">fixed3 color = indirect_diffuse * _EnvScale + diffuse * kd  + specular * (<span class="number">1</span>-kd);</span><br></pre></td></tr></table></figure>

<p>漫反射的部分依然和上面一样</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>((<span class="built_in">dot</span>(normal, LightDir)),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>而对于高光部分。要说它能量守不守恒，也不太好衡量，毕竟能量小于入射能量就行了。无论小多少，它都是一种材质。所以就放在这里不管了。<br>$$<br>C_{light}*m_{specular}*ndotH^m<br>$$</p>
<center>
<figure>
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730013111824.png" alt="image-20220730013111824" style="width:28.9%;display:inline" />
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730013248302.png" alt="image-20220730013248302" style="width:30%;display:inline" />
    </figure>
</center>







<p>但是这个模型的缺陷在于可以调整的参数太少了，不能表达足够多的材质，最直接的改进部分是对于kd的选择，</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> kd = (<span class="number">255.0</span> - _Gloss)/<span class="number">255.0</span>;</span><br><span class="line">kd = <span class="built_in">pow</span>(kd,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>我们对kd做一些映射，就能够使得在同样的光滑度下，高光的能量占比更大（降低增加gloss减少高光范围的趋势），或者其实就干脆换一个参数来控制kd</p>
<center>
    <figure>
    	<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730014709778.png" alt="image-20220730014709778" style="width:40%;display:inline" />
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730014811460.png" alt="image-20220730014811460" style="width:38.2%;display:inline" />
    </figure>
</center>





<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>调参差不多就玩到这里了，整个光照模型就大概如此。</p>
<p>至于能量守恒的部分，首先是环境光照和直接光照的区分。</p>
<p>剩下的最主要的就是漫反射和镜面反射的能量分配，最后就是考虑光照计算的正确性。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"></span><br><span class="line">	fixed3 normal = <span class="built_in">normalize</span>(i.normal);</span><br><span class="line">    fixed3 LightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">    fixed3 ViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">    float3 h = <span class="built_in">normalize</span>(LightDir + ViewDir);</span><br><span class="line">    <span class="type">float</span> ndotL = <span class="built_in">dot</span>(normal, LightDir);</span><br><span class="line">    <span class="type">float</span> ndotH = <span class="built_in">dot</span>(normal,h);</span><br><span class="line">    fixed3 albedo = tex2D(_Albedo, i.uv).rgb * _Diffuse.rgb;</span><br><span class="line">    <span class="comment">//ambient</span></span><br><span class="line">    <span class="comment">//fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span></span><br><span class="line"></span><br><span class="line">    float4 indirect_irradiance = texCUBElod(_CubeMap, float4(normal,_CubeMapLod));</span><br><span class="line">    float3 indirect_diffuse = indirect_irradiance * albedo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//diffuse</span></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(ndotL,<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">    <span class="comment">//specular         </span></span><br><span class="line">    fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(ndotH,<span class="number">0</span>), _Gloss) ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> kd = (<span class="number">255.0</span> - _Spec)/<span class="number">255.0</span>;<span class="comment">//float kd = (255.0 - _Gloss)/255.0;</span></span><br><span class="line">    fixed3 color = indirect_diffuse * _EnvScale + diffuse * kd  + specular * (<span class="number">1.0</span>-kd);<span class="comment">//ambient + diffuse + specular;</span></span><br><span class="line">    <span class="keyword">return</span> fixed4(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1B54y1j7zE">https://www.bilibili.com/video/BV1B54y1j7zE</a> 【技术美术百人计划】图形 2.4 传统经验光照模型详解</p>
<p>[2] Unity Shader入门精要</p>
<p>[3]<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2021.3/Manual/class-TextureImporter.html#GenerateMipMaps">https://docs.unity3d.com/cn/2021.3/Manual/class-TextureImporter.html#GenerateMipMaps</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.4%20%E4%BC%A0%E7%BB%9F%E7%BB%8F%E9%AA%8C%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/" data-id="cmfe1kyay0021ykuh0hlheowl" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形1.1渲染流水线" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" class="article-date">
  <time datetime="2025-09-10T13:18:14.021Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形1-1-渲染流水线"><a href="#图形1-1-渲染流水线" class="headerlink" title="图形1.1 渲染流水线"></a>图形1.1 渲染流水线</h2><h3 id="一、概念流程"><a href="#一、概念流程" class="headerlink" title="一、概念流程"></a><strong>一、概念流程</strong></h3><ul>
<li><p>应用程序阶段</p>
<ul>
<li>粗粒度剔除</li>
<li>渲染设置</li>
<li>准备基本数据</li>
<li>输出到几何阶段（<strong>渲染图元</strong>）</li>
</ul>
</li>
<li><p>几何阶段</p>
<ul>
<li>顶点着色器</li>
<li>曲面细分</li>
<li>几何着色器</li>
<li>顶点裁剪（屏幕空间裁剪）</li>
<li>屏幕映射（<strong>屏幕空间顶点信息</strong>）</li>
</ul>
</li>
<li><p>光栅化阶段</p>
<ul>
<li>三角形（图元：点&#x2F;线）设置，三角形（图元）遍历，片元着色器</li>
</ul>
</li>
<li><p>逐片元操作（合并）</p>
<ul>
<li>裁剪测试</li>
<li>透明度测试</li>
<li>模板测试</li>
<li>混合</li>
</ul>
</li>
<li><p>后处理（图像空间的处理）</p>
</li>
</ul>
<h3 id="二、细节"><a href="#二、细节" class="headerlink" title="二、细节"></a><strong>二、细节</strong></h3><h4 id="1-应用阶段（CPU）"><a href="#1-应用阶段（CPU）" class="headerlink" title="1.应用阶段（CPU）"></a><strong>1.应用阶段（CPU）</strong></h4><ul>
<li>准备基本场景数据（硬盘-&gt;内存）<ul>
<li>场景物体数据<ul>
<li>物体Transform：位置、旋转、缩放等</li>
<li>物体网格数据：顶点位置，UV贴图</li>
<li>这里的分类是不是有点像Maya的两种Dag类型Transform和Shape</li>
</ul>
</li>
<li>摄像机数据<ul>
<li>位置、方向、远近裁剪平面</li>
<li>正交&#x2F;透视（fov）</li>
<li>视口比例&#x2F;尺寸等</li>
</ul>
</li>
<li>光源及阴影<ul>
<li>光源类型：方向光、点光、聚光</li>
<li>颜色、位置、方向、范围、角度等</li>
<li>阴影设置<ul>
<li>是否需要阴影，判断该光源可见范围内是否有可投射阴影的物体</li>
<li>阴影参数：对应光源序号、阴影强度、级联参数、深度偏移、近平面偏移</li>
</ul>
</li>
<li>逐光源绘制阴影贴图<ul>
<li>近平面偏移</li>
<li>逐级联<ul>
<li>计算当前光源+级联对应的观察矩阵、投影矩阵、对应到阴影贴图里的视口区域</li>
</ul>
</li>
<li>绘制到阴影贴图</li>
</ul>
</li>
</ul>
</li>
<li>其他全局数据</li>
</ul>
</li>
<li>加速算法&#x2F;粗粒度剔除<ul>
<li>碰撞检测</li>
<li>加速算法</li>
<li>剔除<ul>
<li>可见光裁剪</li>
<li>视锥剔除</li>
<li>如CPU阶段的可见性（遮挡）剔除<ul>
<li>Octree</li>
<li>BSP tree</li>
<li>K-D tree</li>
<li>BVH tree</li>
</ul>
</li>
</ul>
</li>
<li>其他</li>
</ul>
</li>
<li>设置渲染状态，准备渲染参数（以unity为例）<ul>
<li>渲染设置<ul>
<li>使用着色器</li>
<li>合批方式</li>
</ul>
</li>
<li>渲染顺序<ul>
<li>相对摄像机的距离</li>
<li>材质Render Queue</li>
<li>UI Canvas</li>
<li>其他</li>
</ul>
</li>
<li>渲染目标<ul>
<li>Render Texture</li>
<li>Frame Buffer</li>
<li>多个目标</li>
</ul>
</li>
<li>渲染模式<ul>
<li>Forward</li>
<li>Deferred</li>
</ul>
</li>
</ul>
</li>
<li>调用Draw Call，输出渲染图元到显存<ul>
<li>顶点数据<ul>
<li>位置</li>
<li>颜色</li>
<li>法线</li>
<li>UV texcoord</li>
<li>其他</li>
</ul>
</li>
<li>其他数据<ul>
<li>MVP</li>
<li>纹理贴图</li>
<li>其他</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-几何阶段"><a href="#2-几何阶段" class="headerlink" title="2.几何阶段"></a><strong>2.几何阶段</strong></h4><h5 id="2-1顶点着色器"><a href="#2-1顶点着色器" class="headerlink" title="2.1顶点着色器"></a><strong>2.1顶点着色器</strong></h5><p>视图变换、顶点着色等<br>输出到Clip Space</p>
<h5 id="2-2曲面细分着色器（可选）"><a href="#2-2曲面细分着色器（可选）" class="headerlink" title="2.2曲面细分着色器（可选）"></a><strong>2.2曲面细分着色器（可选）</strong></h5><p>网格、图元细分</p>
<h5 id="2-3几何着色器（可选）"><a href="#2-3几何着色器（可选）" class="headerlink" title="2.3几何着色器（可选）"></a><strong>2.3几何着色器（可选）</strong></h5><p>逐图元着色或者产生更多图元</p>
<h5 id="2-4裁剪（不可编程）"><a href="#2-4裁剪（不可编程）" class="headerlink" title="2.4裁剪（不可编程）"></a><strong>2.4裁剪（不可编程）</strong></h5><p>正面或背面剔除（可配置）</p>
<h6 id="裁剪的顺序"><a href="#裁剪的顺序" class="headerlink" title="裁剪的顺序"></a>裁剪的顺序</h6><p>关于裁剪和透视除法的顺序，看到很多争议，包括参考图也有画在2D空间和3D空间的</p>
<p>在虎书4th的描述里，裁剪可能完成的地方有2种</p>
<ol>
<li>使用6个平面围成的观察金字塔（view pyramid）的世界坐标系中</li>
<li>齐次坐标除法之前的4D变换空间</li>
</ol>
<p>无论哪种都可以实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> each of six planes <span class="keyword">do</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(triangle entirely outside of plane)</span> then</span></span><br><span class="line"><span class="function">        <span class="title">break</span> <span class="params">(triangle is <span class="keyword">not</span> visible)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">else</span> <span class="keyword">if</span> triangle spans plane then</span></span><br><span class="line"><span class="function">		clip triangle</span></span><br><span class="line"><span class="function">		<span class="title">if</span> <span class="params">(quadrilateral is left)</span> then</span></span><br><span class="line"><span class="function">			<span class="keyword">break</span> into two triangles</span></span><br></pre></td></tr></table></figure>

<p>而如果先做透视除法再做裁剪，透视变换保持了深度顺序，但是在0处不连续</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220720181336331.png" alt="image-20220720181336331"></p>
<p>这样会把裁剪变得复杂，可能出现错误结果。</p>
<p>这部分的数学推导在后面整理到模型空间变换再研究好了。</p>
<p>总得来说，现代图形渲染管线，就是在齐次裁剪坐标下进行裁剪，然后由硬件完成透视除法。</p>
<p>至于书中提到的第一种裁剪位置在什么地方会用到就不知道了。实际上很多管线中的顺序也取决于硬件设计。</p>
<h5 id="2-5透视除法"><a href="#2-5透视除法" class="headerlink" title="2.5透视除法"></a><strong>2.5透视除法</strong></h5><p>齐次裁剪坐标Clip Space下，硬件完成透视除法xyz&#x2F;w，得到归一化的设备坐标NDC</p>
<p>Opengl和Unity的NDC的z分量范围在[-1,1]</p>
<p>DirectX中NDC的z分量范围是[0,1]</p>
<h5 id="2-6屏幕映射（不可编程）"><a href="#2-6屏幕映射（不可编程）" class="headerlink" title="2.6屏幕映射（不可编程）"></a><strong>2.6屏幕映射（不可编程）</strong></h5><p>从连续到离散</p>
<p>坐标系差异（Opengl&#x2F;D3D）</p>
<p>Opengl左下角为最小窗口坐标</p>
<p>Dx定义左上角为最小窗口坐标</p>
<h4 id="3-光栅化阶段"><a href="#3-光栅化阶段" class="headerlink" title="3.光栅化阶段"></a><strong>3.光栅化阶段</strong></h4><h5 id="3-1三角形设置Triangle-Setup-图元装配Primitive-Assembly"><a href="#3-1三角形设置Triangle-Setup-图元装配Primitive-Assembly" class="headerlink" title="3.1三角形设置Triangle Setup&#x2F;图元装配Primitive Assembly"></a><strong>3.1三角形设置Triangle Setup&#x2F;图元装配Primitive Assembly</strong></h5><p>根据输入的网格顶点来计算三角形边界</p>
<h5 id="3-2三角形遍历"><a href="#3-2三角形遍历" class="headerlink" title="3.2三角形遍历"></a><strong>3.2三角形遍历</strong></h5><p>（直线绘制算法与扫描线填充算法）扫描变换，检查像素是否被三角形覆盖，覆盖则生成一个片元</p>
<p>每个片元计算根据三角形顶点插值后的数据</p>
<p><em>因此片元和像素区别的意义不仅在于SSAA，还有合并操作当中，对同一像素对应片元进行合并才输出像素。</em></p>
<h6 id="MSAA"><a href="#MSAA" class="headerlink" title="MSAA"></a><strong>MSAA</strong></h6><p>对每个像素设置多个采样点，对每个子采样点进行覆盖测试和遮挡测试，每个子采样点都需要维护深度</p>
<h5 id="3-3片元着色器"><a href="#3-3片元着色器" class="headerlink" title="3.3片元着色器"></a><strong>3.3片元着色器</strong></h5><p>对于插值得到的片元执行片元着色器程序，输出一个或多个颜色值</p>
<h4 id="4-逐片元操作（输出合并阶段）"><a href="#4-逐片元操作（输出合并阶段）" class="headerlink" title="4.逐片元操作（输出合并阶段）"></a><strong>4.逐片元操作（输出合并阶段）</strong></h4><p>决定每个片元的可见性</p>
<ul>
<li><p>Stencil Test</p>
</li>
<li><p>Alpha Test</p>
<ul>
<li>透明度小于阈值的片元就被舍弃</li>
</ul>
</li>
<li><p>Depth Buffer Test</p>
</li>
</ul>
<p>如果通过测试，则把该片元颜色值和颜色缓冲区中的颜色进行合并&#x2F;混合</p>
<ul>
<li>Color Buffer Blending<ul>
<li>Alpha Blend</li>
</ul>
</li>
</ul>
<p>输出到目标缓冲区（RT&#x2F;FB）</p>
<h4 id="5-后处理"><a href="#5-后处理" class="headerlink" title="5.后处理"></a><strong>5.后处理</strong></h4><ul>
<li><p>HDR</p>
</li>
<li><p>Bloom</p>
</li>
<li><p>FXAA</p>
</li>
<li><p>Depth of View景深</p>
</li>
<li><p>边缘检测</p>
</li>
<li><p>径向模糊</p>
</li>
<li><p>。。。</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1L54y1s7xw?p=2&vd_source=7ec8021691d266bb655a835d37f89e13%E3%80%90%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92%E3%80%91%E5%9B%BE%E5%BD%A2">https://www.bilibili.com/video/BV1L54y1s7xw?p=2&amp;vd_source=7ec8021691d266bb655a835d37f89e13【技术美术百人计划】图形</a> 1.1 渲染流水线</p>
<p>[2] <a target="_blank" rel="noopener" href="https://jishuin.proginn.com/p/763bfbd6e54f">https://jishuin.proginn.com/p/763bfbd6e54f</a></p>
<p>[3] Unity Shader入门精要</p>
<p>[4] Fundamentals of Computer Graphics,4th</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" data-id="cmfe1kyat001hykuh01ee2t5p" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>