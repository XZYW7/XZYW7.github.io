<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">XZYW7&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="XZYW7&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-TA/OpenGL/Opengl learning_02" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/09/10/TA/OpenGL/Opengl%20learning_02/">【笔记】Cherno Opengl Tutorial note 02</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/09/10/TA/OpenGL/Opengl%20learning_02/" class="article-date">
  <time datetime="2022-09-10T15:04:12.000Z" itemprop="datePublished">2022-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="08-How-I-Deal-with-Shaders"><a href="#08-How-I-Deal-with-Shaders" class="headerlink" title="08 How I Deal with Shaders"></a><strong>08 How I Deal with Shaders</strong></h2><p>在之前的着色器编写中，对于每个字符串都要加引号和换行符，这是非常不方便的。</p>
<p>因此我们需要从文件读取shader。</p>
<p>一般来说会把vs和fs分成两个文件。但作者认为两个文件也很不方便，而是把vs和fs合并在一起（shaderlab就是这样做的）。并且在文件中对两部分进行区别。</p>
<p>在项目文件夹中新建resource文件夹，包含shaders文件夹，（以后也可能添加纹理、模型等资源），创建一个后缀为shader的文件</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824221249780.png" alt="image-20220824221249780"></p>
<p>将着色器的代码粘贴到文件中，并分别加上指定vs和fs编译的宏（可以用替换的功能去掉引号和换行符）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec4 position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color = <span class="built_in">vec4</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们要做的是把这个文件转换成std字符串。读文件采用fstream设置文件流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span>&#123;</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FrgmentSource;</span><br><span class="line">&#125;;<span class="comment">// 为了返回多重数据而制作一个结构体</span></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span> &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">	std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line)) &#123;<span class="comment">//string头文件中的getline方法</span></span><br><span class="line">    	<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>)!=std::string::npos)&#123;</span><br><span class="line">            <span class="comment">//std::string::npos,表示字符串末尾（无效字符串）</span></span><br><span class="line">            <span class="keyword">if</span>(line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>)!=std::string::npos)&#123;</span><br><span class="line">                <span class="comment">// set mode to vertex</span></span><br><span class="line">            	type = ShaderType::VERTEX;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>)!=std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把代码添加到vs或fs的字符串流中</span></span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt;line&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  &#123;ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ShaderProgramSource source= <span class="built_in">ParseShader</span>(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line"><span class="comment">//我们这里使用相对路径，可执行文件的默认工作目录是可执行文件的目录，而visual studio调试器运行，工作目录是可设置的</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824224240477.png" alt="image-20220824224240477" style="zoom:50%;" />

<p>将解析的着色器代码输出出来，一切正常</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824224450410.png" alt="image-20220824224450410"></p>
<p>那么我们实现了从一个文件里读取vs和fs，这部分修改就完成了</p>
<h2 id="09-Index-Buffers"><a href="#09-Index-Buffers" class="headerlink" title="09 Index Buffers"></a><strong>09 Index Buffers</strong></h2><ul>
<li>Index Buffer是什么</li>
</ul>
<p>我们已经画好了一个三角形。我们如果想画一个正方形呢？实际上，也是由三角形组成的。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824230232057.png" alt="image-20220824230232057" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="comment">// 第二个三角形</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相应地，顶点缓冲区大小也增大了，绘制方法也需要改成6个顶点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>我们成功地 绘制出了想要的正方形&#x2F;长方形</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824230651997.png" alt="image-20220824230651997" style="zoom:50%;" />

<p>但是实际上顶点数组发生了大量重复，这也浪费了内存，尤其是顶点储存属性很多时。</p>
<p>因此我们使用索引缓冲Index Buffer，使顶点能够重复使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">&#125;;<span class="comment">//01230</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">	<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line">&#125;;<span class="comment">//必须使用无符号类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点缓冲</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;<span class="comment">//index buffer object</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//drawcall的变化</span></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);<span class="comment">//GL_INT就出现了问题，无法渲染出画面，而index  buffer是无符号的</span></span><br></pre></td></tr></table></figure>

<p>也非常顺利</p>
<h2 id="10-Dealing-with-Errors"><a href="#10-Dealing-with-Errors" class="headerlink" title="10 Dealing with Errors"></a><strong>10 Dealing with Errors</strong></h2><p>这里讨论的是Opengl提供的检查错误的方法，不会用到外部工具</p>
<p>主要有两种方法</p>
<p>glGetError</p>
<p>使用glGetError的工作流程是首先在opengl的每个函数调用前，&#x3D;&#x3D;在循环中调用&#x3D;&#x3D;，直到清除所有错误。</p>
<p>glMessageCallBack是opengl4.3添加的功能，允许我们指定一个指向Opengl函数的指针，比glGetError更方便。这一集教程中只关注glGetError。</p>
<ul>
<li>返回值flag</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825000148080.png" alt="image-20220825000148080"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">glGetError</span>()!=GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLCheckError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;[OpenGL Error] (&quot;</span>&lt;&lt; error &lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="built_in">GLClearError</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>);<span class="comment">//前面的符号类型错误</span></span><br><span class="line"><span class="built_in">GLCheckError</span>();</span><br></pre></td></tr></table></figure>

<p>控制台打印出1280的错误</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825000933480.png" alt="image-20220825000933480"></p>
<p>在glew.h中 ，会发现各种宏的定义都是16进制的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825001114710.png" alt="image-20220825001114710"></p>
<p>因此我们把1280转换成16进制，如果懒得搜的话，在断点 中定位到变量，右键可以选择16进制显示，这里结果是0x00000500，</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825001334790.png" alt="image-20220825001334790" style="zoom:50%;" />

<p>在glew.h中搜索，我们可以找到是GL_INVALID_ENUM的错误，也就是说，在我们检查的glDrawElements函数中，传递了一个无效的枚举类型参数。也就是GL_INT</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825001532054.png" alt="image-20220825001532054"></p>
<p>那么，最终的问题是，对于每个函数都做这样的处理太过麻烦，也会污染代码。所以我们最好知道错误发生在哪里 。</p>
<p>在这里我们已经设置了断点，当然我们在堆栈中可以找到具体的出现问题的函数。我们也可以用ASSERT来做这件事，如果条件不成立，通常发送一个消息到控制台，或是停止程序的执行 。这相当于用代码来设置断点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">glGetError</span>()!=GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;[OpenGL Error] (&quot;</span>&lt;&lt; error &lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">GLClearError</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(<span class="built_in">GLLogCall</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后自动触发了断点</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825003024764.png" alt="image-20220825003024764"></p>
<p>我们还可以再设置一宏命令来简化这个过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">		x;\</span></span><br><span class="line"><span class="meta">		ASSERT(GLLogCall())</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">GLCALL</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>

<p>非常好用。</p>
<p>还要解决的问题是，我们的错误消息并不能指定实际错误发生在哪个文件或行上，甚至函数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt; </span><br><span class="line">            <span class="string">&quot; &quot;</span>&lt;&lt; file&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;line&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更好用了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825004247444.png" alt="image-20220825004247444"></p>
<p>接下来我们要做的就是把每个opengl方法用GLCall包装起来。</p>
<p>有一些情况会为GLCall添加if、while等作用域，但是这样就无法使用于赋值的构造函数语句等，因为这会让创建的变量无法被调用，因为超出了作用域（相当于封装在了一个{}scope中）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreaateProgram</span>());</span><br><span class="line"><span class="comment">//这是可以使用的，但是添加作用域后不能使用，相当于把它放进了大括号</span></span><br></pre></td></tr></table></figure>



<h2 id="11-Uniforms"><a href="#11-Uniforms" class="headerlink" title="11 Uniforms"></a><strong>11 Uniforms</strong></h2><p>Uniform是一种从CPU获取数据的方式。</p>
<p>在交互时着色器变量有可能需要更新， 因此C++的变量通过Uniform传递到着色器。</p>
<p>我们在每次绘制前设置uniform</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Basic.shader</span></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"></span><br><span class="line">uniform vec4 u_Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color = u_Color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建着色器后，每个uniform都会被分配一个ID，并通过ID检索该变量的位置</span></span><br><span class="line"><span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>);</span><br><span class="line"><span class="comment">//如果在着色器中声明了但没有使用uniform变量，那么opengl编译时会舍弃该变量</span></span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">glUniform4f</span>(location, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<p>通过Uniform来对变量进行变化控制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">glUniform4f</span>(location, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">if</span> (r&gt;<span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span> (r&lt;<span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line">    r += increment;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(有可能会出现变化太快的问题，可以把双缓冲交换间隔设置为1。虽然我好像没有这个问题)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="12-Vertex-Arrays"><a href="#12-Vertex-Arrays" class="headerlink" title="12 Vertex Arrays"></a><strong>12 Vertex Arrays</strong></h2><ul>
<li>绑定vertex buffer</li>
<li>指定vertex layout</li>
<li>绑定index buffer</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解除绑定</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在每一帧重新绑定，结果是一样的。事实上由于每一帧绘制数据可能发生变化，正需要在这里进行绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));<span class="comment">//前面的符号类型错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们需要正确使用顶点数组，为每个几何体设置不同的顶点数组对象，然后只需要在drawcall前进行绑定。这就是VAO。</p>
<p>绘制过程</p>
<ul>
<li>绑定着色器</li>
<li>绑定顶点缓冲区</li>
<li>设置顶点布局</li>
<li>绑定index缓冲区</li>
<li>drawcall</li>
</ul>
<p>-》使用VAO</p>
<ul>
<li>绑定着色器</li>
<li>绑定顶点数组</li>
<li>绑定index缓冲</li>
<li>drawcall</li>
</ul>
<p>使用core profile</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//使用opengl最高版本或最低版本为3（3.3）</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//使用Core Profile</span></span><br><span class="line"><span class="comment">//可兼容性的opengl profile（compatbility Opengl profile）有VAO默认对象是0.但core profile没有默认对象，必须绑定VAO</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int vao;</span><br><span class="line">glGenVertexArrays(1, &amp;vao);</span><br><span class="line">glBindVertexArray(vao);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这些都绑定好后，由于Opengl的状态机属性，我们可以解除绑定。然后在drawcall前再绑定vao（把vertex buffer链接到VAO），就可以正常绘制。</p>
<ul>
<li>绑定VAO</li>
<li>绑定顶点缓冲</li>
<li>指定顶点属性指针，这时将会把顶点缓冲和VAO绑定在一起</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定VAO</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点缓冲</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;<span class="comment">//index buffer object</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定</span></span><br><span class="line"><span class="comment">//glUseProgram(0);</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);<span class="comment">//反正不要在VAO激活时解绑EBO/IBO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);</span></span><br><span class="line">	<span class="comment">//同样重要的是要注意，索引缓冲区/ELEMENT_ARRAY_BUFFER也包含在VAO状态中。它不需要按帧重新定义...因此，您也可以删除该行。  GL_ELEMENT_ARRAY_BUFFER必须在绑定顶点数组对象（glBindVertex 数组）之后绑定。GL_ELEMENT_ARRAY_BUFFER对象存储在顶点数组对象状态向量中。 如果顶点数组对象已解绑并再次绑定，则GL_ELEMENT_ARRAY_BUFFER也已知并再次绑定。但是，如果在绑定顶点数组对象时元素数组缓冲区显式解除绑定，则会从状态向量中删除该缓冲区。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));<span class="comment">//前面的符号类型错误</span></span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来的做法：</p>
<p>每次需要绘制时，绑定顶点缓冲区，指定顶点属性指针，绑定顶点索引缓冲，然后渲染。</p>
<p>VAO的方法：</p>
<p>为每个几何对象创建VAO，绑定顶点缓冲区，指定顶点属性指针，绑定顶点索引缓冲，解绑</p>
<p>在渲染该对象前绑定对应的VAO</p>
<p>LearnOpengl对此操作的描述</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#x27;s bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.</span></span><br><span class="line"><span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can unbind the VAO afterwards so other VAO calls won&#x27;t accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line"><span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在之后我们可以用class来做这件事，会方便很多。</p>
<p>每次绑定vertex buffer和VAO的方式哪种更快呢？</p>
<ul>
<li>实际上在过去使用一个VAO，每次绑定其他东西更快。</li>
<li>NVIDIA提出不建议使用VAO</li>
<li>但其实在不同环境下也可能出现不同的结果</li>
<li>如果一定特别需要压榨性能，可以看情况使用</li>
</ul>
<h2 id="13-Abstracting-Opengl-into-Class"><a href="#13-Abstracting-Opengl-into-Class" class="headerlink" title="13 Abstracting Opengl into Class"></a><strong>13 Abstracting Opengl into Class</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span> &#123;</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FrgmentSource;</span><br><span class="line">&#125;;<span class="comment">// 为了返回多重数据而制作一个结构体</span></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span> &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line)) &#123;<span class="comment">//string头文件中的getline方法</span></span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">            <span class="comment">//std::string::npos,表示字符串末尾（无效字符串）</span></span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to vertex</span></span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把代码添加到vs或fs的字符串流中</span></span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  &#123; ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">ComplieShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fail to complie &quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex &quot;</span> : <span class="string">&quot;fragment &quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">ComplieShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">ComplieShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;GlewInit fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">12</span>] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">    &#125;;<span class="comment">//01230</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">        <span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line">    &#125;;<span class="comment">//必须使用无符号类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定VAO</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点缓冲</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ibo;<span class="comment">//index buffer object</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::string vertexShader =</span></span><br><span class="line"><span class="comment">        &quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;layout(location = 0) in vec4 position;\n&quot;</span></span><br><span class="line"><span class="comment">        //和顶点属性的laout一致。</span></span><br><span class="line"><span class="comment">        //注意这里是vec4，而我们实际只有vec2，剩余的部分Opengl会默认转换z0w1</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;void main()&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#123;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;	gl_Position = position;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#125;\n&quot;;</span></span><br><span class="line"><span class="comment">    std::string fragmentShader =</span></span><br><span class="line"><span class="comment">        &quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;layout(location = 0) out vec4 color;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;void main()&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#123;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;	color = vec4(1.0,0.0,0.0,1.0);\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#125;\n&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FrgmentSource);</span><br><span class="line">    <span class="comment">//glUseProgram(shader);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建着色器后，每个uniform都会被分配一个ID</span></span><br><span class="line">    <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>);</span><br><span class="line">    <span class="comment">//如果在着色器中声明了但没有使用uniform变量，那么opengl编译时会舍弃该变量</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解除绑定</span></span><br><span class="line">    <span class="comment">//glUseProgram(0);</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line">        <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));<span class="comment">//前面的符号类型错误</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">            increment = <span class="number">-0.05f</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">            increment = <span class="number">0.05f</span>;</span><br><span class="line">        r += increment;</span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//glDeleteProgram(shader);</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里先放一放整体的代码，然后我们将要进行大的修改。</p>
<h3 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a><strong>Renderer</strong></h3><p>首先创建Renderer.h 和cpp文件。并且把错误处理的部分挪到头文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Renderer.h#################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Renderer.cpp###############</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VertexBuffer"><a href="#VertexBuffer" class="headerlink" title="VertexBuffer"></a><strong>VertexBuffer</strong></h3><p>我们再创建VertexBuffer的头文件和cpp文件,用来定义顶点缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexBuffer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBuffer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	<span class="comment">// 在其他API中，也表示是一个ID，因此用这种命名来通用地表达</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> <span class="type">int</span> size);</span><br><span class="line">	~<span class="built_in">VertexBuffer</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以右键类名后选择“快速操作和重构”，然后创建函数定义，这样IDE自动在cpp中为我们创建了各个方法的定义框架（但实际上我操作失败了，提示说所选的文本不包含任何函数签名，我只能全选下面的方法，然后再右键快速操作）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220910170329326.png" alt="image-20220910170329326"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexBuffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line">VertexBuffer::<span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VertexBuffer::~<span class="built_in">VertexBuffer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="IndexBuffer"><a href="#IndexBuffer" class="headerlink" title="IndexBuffer"></a><strong>IndexBuffer</strong></h3><p>对indexBuffer也可以用同样的做法.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#########IndexBuffer.h##############</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexBuffer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count);</span><br><span class="line">	~<span class="built_in">IndexBuffer</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//##########IndexBuffer.cpp#############</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IndexBuffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line">IndexBuffer::<span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    : <span class="built_in">m_Count</span>(count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="built_in">sizeof</span>(GLuint));</span><br><span class="line">    <span class="comment">//count*sizeof(GLuint)即使可能不会，但仍可能出现平台差异</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, count * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), data, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IndexBuffer::~<span class="built_in">IndexBuffer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a><strong>Application</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span>*<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 顶点缓冲</span></span><br><span class="line"><span class="comment">    unsigned int buffer;</span></span><br><span class="line"><span class="comment">    glGenBuffers(1, &amp;buffer);</span></span><br><span class="line"><span class="comment">    glBindBuffer(GL_ARRAY_BUFFER, buffer);</span></span><br><span class="line"><span class="comment">    glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0);</span></span><br><span class="line"><span class="comment">    glEnableVertexAttribArray(0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line"><span class="comment">    unsigned int ibo;//index buffer object</span></span><br><span class="line"><span class="comment">    glGenBuffers(1, &amp;ibo);</span></span><br><span class="line"><span class="comment">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);</span></span><br><span class="line"><span class="comment">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="14-Buffer-Layout-Abstraction"><a href="#14-Buffer-Layout-Abstraction" class="headerlink" title="14 Buffer Layout Abstraction"></a><strong>14 Buffer Layout Abstraction</strong></h2><p>我们希望用如下的结构来组织vao</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VertexArray va;</span><br><span class="line"><span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span>*<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line">va.<span class="built_in">AddBuffer</span>(vb);</span><br><span class="line"></span><br><span class="line">BufferLayout layout;</span><br><span class="line">layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>);</span><br><span class="line">va.<span class="built_in">AddLayout</span>(layout);</span><br><span class="line">....</span><br><span class="line">va.<span class="built_in">Bind</span>();</span><br></pre></td></tr></table></figure>



<h3 id="VertexArray"><a href="#VertexArray" class="headerlink" title="VertexArray"></a><strong>VertexArray</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexArray.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBufferLayout.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VertexArray</span>();</span><br><span class="line">	~<span class="built_in">VertexArray</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//VertexArray.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexArray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line">VertexArray::<span class="built_in">VertexArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VertexArray::~<span class="built_in">VertexArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    <span class="built_in">Bind</span>();</span><br><span class="line">    <span class="comment">// 绑定VBO</span></span><br><span class="line">	vb.<span class="built_in">Bind</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 顶点属性Layout</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; elements = layout.<span class="built_in">GetElements</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; elements.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; element = elements[i];</span><br><span class="line">        <span class="built_in">glVertexAttribPointer</span>(i, element.count,element.type,</span><br><span class="line">            element.normalized, layout.<span class="built_in">GetStride</span>(), (<span class="type">const</span> <span class="type">void</span>*) offset);</span><br><span class="line">        <span class="built_in">glEnableVertexAttribArray</span>(i);</span><br><span class="line">        offset += element.count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(element.type);</span><br><span class="line">        <span class="comment">//glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="VertexArrayLayout"><a href="#VertexArrayLayout" class="headerlink" title="VertexArrayLayout"></a><strong>VertexArrayLayout</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexArrayLayout.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexBufferElement</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> normalized;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetSizeOfType</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">			<span class="keyword">case</span> GL_FLOAT:			<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">			<span class="keyword">case</span> GL_UNSIGNED_INT:	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">			<span class="keyword">case</span> GL_UNSIGNED_BYTE:	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ASSERT</span>(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBufferLayout</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;VertexBufferElement&gt; m_Elements;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Stride;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VertexBufferLayout</span>()</span><br><span class="line">		: <span class="built_in">m_Stride</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">static_assert</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count) &#123;</span><br><span class="line">		m_Elements.<span class="built_in">push_back</span>(&#123; GL_FLOAT, count, GL_FALSE&#125;);</span><br><span class="line">		m_Stride += VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_FLOAT) * count;<span class="comment">//4 * 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用模板来完成不同类型顶点属性的添加，也方便进行其他类型的扩展</span></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count) &#123;</span><br><span class="line">		m_Elements.<span class="built_in">push_back</span>(&#123; GL_UNSIGNED_INT, count, GL_FALSE &#125;);</span><br><span class="line">		m_Stride += VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_INT) * count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count) &#123;</span><br><span class="line">		m_Elements.<span class="built_in">push_back</span>(&#123; GL_UNSIGNED_BYTE, count, GL_TRUE &#125;);</span><br><span class="line">		m_Stride += VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_BYTE) * count;<span class="comment">//GLbyte </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">const</span> std::vector&lt;VertexBufferElement&gt; <span class="title">GetElements</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Elements; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetStride</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Stride; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>作者在Bind和Unbind的地方其实处理得不是很舒服，受之前学长的影响，个人喜欢在添加完顶点属性后直接解绑，也就是AddBuffer函数之后，把va和vb解绑直接做掉。并且elementarray也就是IBO（EBO）Learnopengl中说过是绑定在VAO中的，可以不管。</p>
<h2 id="15-Shader-Abstraction"><a href="#15-Shader-Abstraction" class="headerlink" title="15 Shader Abstraction"></a><strong>15 Shader Abstraction</strong></h2><p>游戏和引擎中，通常有一种自定义着色语言，然后编译成每种api或平台适合的语言。并且是可控和可扩展的（着色器动态创建）。</p>
<p>我们在这里shader abstraction要完成的：</p>
<ol>
<li>能够使用文件和字符串编译shader</li>
<li>绑定和取消绑定</li>
<li>设置uniform</li>
</ol>
<h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a><strong>Shader</strong></h3><p>shader.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shader.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span><span class="comment">//hash table</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span> &#123;</span><br><span class="line">	std::string VertexSource;</span><br><span class="line">	std::string FrgmentSource;</span><br><span class="line">&#125;;<span class="comment">// 为了返回多重数据而制作一个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_FilePath;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m_UniformLocationCache;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath);</span><br><span class="line">	~<span class="built_in">Shader</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//set uniforms</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span>;</span><br><span class="line">	<span class="function">ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Shader.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shader.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line">Shader::<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath)</span><br><span class="line">    : <span class="built_in">m_FilePath</span>(filepath), <span class="built_in">m_RendererID</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ShaderProgramSource source = <span class="built_in">ParseShader</span>(filepath);</span><br><span class="line">    m_RendererID = <span class="built_in">CreateShader</span>(source.VertexSource, source.FrgmentSource);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shader::~<span class="built_in">Shader</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fail to complie &quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex &quot;</span> : <span class="string">&quot;fragment &quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ShaderProgramSource <span class="title">Shader::ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span> &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line)) &#123;<span class="comment">//string头文件中的getline方法</span></span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">            <span class="comment">//std::string::npos,表示字符串末尾（无效字符串）</span></span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to vertex</span></span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把代码添加到vs或fs的字符串流中</span></span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  &#123; ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUseProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUniform4f</span>(<span class="built_in">GetUniformLocation</span>(name), v0, v1, v2, v3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Shader::GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//优化：我们每次setUniform的时候，都需要重新GetUniformLocation，找到属性在Layout中的位置</span></span><br><span class="line">    <span class="comment">//这是多余的消耗，我们可以用hash table 把它储存起来。</span></span><br><span class="line">    <span class="keyword">if</span> (m_UniformLocationCache.<span class="built_in">find</span>(name) != m_UniformLocationCache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> m_UniformLocationCache[name];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(m_RendererID, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Warning: uniform &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#x27; dosen&#x27;t exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_UniformLocationCache[name] = location;</span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/10/TA/OpenGL/Opengl%20learning_02/" data-id="cmfe9guiu002bewuhalgv8g54" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Opengl/" rel="tag">Opengl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Diary/2022-09-04" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/09/04/Diary/2022-09-04/">2022年9月4日 周日</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/09/04/Diary/2022-09-04/" class="article-date">
  <time datetime="2022-09-04T07:30:41.000Z" itemprop="datePublished">2022-09-04</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>多吓人啊，暑假已经要结束了。<br>就在明天，就要开启人生的新阶段——去实习了。</p>
<p>本该在大四秋招的时候，参加了实习。怎么说呢，只能说是暑期实习无望的无奈之举。一边继续参加秋招，一边实习工作，这段经历就起不到任何作用。但其实，就我自己来说，还是挺适合的。一方面参与国产自研引擎的工作，也算是比较期待的。一方面，没有实习的工作经验，这也能做一些铺垫和学习。再者就是，如果有机会转正，也算是为秋招&#x2F;春招留下一条后路。因此，也算是只赚不亏的吧。</p>
<p>翻了翻上次的日记，运动和练琴的计划，运动倒是好好地落实了。练琴确是到现在没碰过一次。。。。<br>这也是有原因的。刚做完米哈游笔试休息了几天，推进了不鸣和友塔的进度，也往前学了百人。网易互娱的测试题就开始了。。。8天的时间。这一做又是做到昨天。<br>中间还穿插了各种各样的事情，友塔养🐟，不鸣实习offer，雷火9月1日一天两面，9月2日体检，一天做两家笔试，昨天也是，一天两家笔试，并且搜狐畅游还是引擎岗。。。合着8月底投的引擎岗一周就进笔试了，七月底的TA到现在也是初筛。。。TA这么卷了吗？。。还是需求太少，相对比例更低。。。</p>
<p>忙着忙着，不知不觉地暑假就要结束了，明天也开始要上人生中的第一天班。<br>一个半月的时间，也做了很多事吧，但仍然有更多想做的事来不及去做。想一想今年剩下的四个月和明年的小半年时间，除了毕设，还要学一大堆东西。来不及停下歇息，被生活推着推着，就推到了人生的新阶段了。<br>今天摸鱼的最后一天，也不知道做什么。。。不想学也不想玩，摆烂小半天</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/04/Diary/2022-09-04/" data-id="cmfe9guij000tewuh9ax83kus" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形4.2SSAO算法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/08/26/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.2SSAO%E7%AE%97%E6%B3%95/">【笔记】【百人计划】图形4.2 SSAO算法</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/26/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.2SSAO%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2022-08-26T09:29:00.000Z" itemprop="datePublished">2022-08-26</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形4-2-SSAO算法"><a href="#图形4-2-SSAO算法" class="headerlink" title="图形4.2 SSAO算法"></a>图形4.2 SSAO算法</h2><p>GAMES202 中的SSAO</p>
<p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/CbZTf-uM4/#screen-space-ambient-occlusionssao">https://xzyw7.github.io/post/CbZTf-uM4/#screen-space-ambient-occlusionssao</a></p>
<h3 id="一、SSAO介绍"><a href="#一、SSAO介绍" class="headerlink" title="一、SSAO介绍"></a>一、SSAO介绍</h3><p>SSAO相关术语，简要理解及历史</p>
<ul>
<li>AO<ul>
<li>环境光遮蔽Amibent Occlusion，用于模拟光线到达物体的能力的一种粗略的全局方法，描述光线到达物体表面的能力</li>
</ul>
</li>
<li>SSAO<ul>
<li>屏幕空间环境光遮蔽Screen Space Ambient Occlusion，一种用于实施近似AO的渲染技术。通过获取像素的深度缓冲、法线缓冲来计算实现，近似地表现物体在间接光下产生的阴影。</li>
</ul>
</li>
<li>历史<ul>
<li>AO最早在Siggraph 2002年会上有ILM（工业光魔）的技术主管Hayden Landis所展示，当时就被叫做Ambient Occlusion</li>
<li>2007年，Crytek发布了SSAO的技术，并用在了孤岛危机上。</li>
</ul>
</li>
</ul>
<h3 id="二、SSAO原理"><a href="#二、SSAO原理" class="headerlink" title="二、SSAO原理"></a>二、SSAO原理</h3><p>简要理解SSAO算法原理</p>
<p><img src="/%E5%9B%BE%E5%BD%A24.2%20SSAO%E7%AE%97%E6%B3%95/image-20220912220609664.png" alt="image-20220912220609664"></p>
<ul>
<li>深度缓冲<ul>
<li>depth用于当前视点下场景的每一个像素距离相机的粗略表达，用于重构像素相机空间中的坐标Z，来近似重构该视点下的三维场景。</li>
</ul>
</li>
<li>法线缓冲<ul>
<li>相机空间中的法线信息，用于重构每个像素的TBN坐标轴，用于计算发现半球中的采样随机向量，随机向量用于判断和描述该像素的AO强度。</li>
</ul>
</li>
<li>法向半球<ul>
<li>黑色表示我们需要计算的样本</li>
<li>蓝色项链表示样本的法向量</li>
<li>白色、灰色为采样点。灰色表示被遮挡采样点，据此判断最终AO的强度</li>
<li><img src="%E5%9B%BE%E5%BD%A24.2%20SSAO%E7%AE%97%E6%B3%95/image-20220912221417067.png" alt="image-20220912221417067" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h3 id="三、算法实现"><a href="#三、算法实现" class="headerlink" title="三、算法实现"></a>三、算法实现</h3><p>根据原理结合UnityC#&amp;Shader实现SSAO</p>
<h4 id="实现过程环境"><a href="#实现过程环境" class="headerlink" title="实现过程环境"></a>实现过程环境</h4><ul>
<li>Unity2019.3.5f1</li>
<li>透视模式</li>
<li>前向渲染。如果为延迟渲染，则由对应的G-buffer生成，在shader中作为全局变量访问</li>
<li>使用OnRenderImage()来处理后期，进而实现SSAO</li>
</ul>
<h4 id="获取深度-法线缓冲数据"><a href="#获取深度-法线缓冲数据" class="headerlink" title="获取深度&amp;法线缓冲数据"></a>获取深度&amp;法线缓冲数据</h4><ul>
<li>C#部分</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    cam = <span class="keyword">this</span>.GetComponent&lt;Camera&gt;();</span><br><span class="line">    cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.DepthNormals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Shader部分</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取深度法线图</span></span><br><span class="line">sampler2D _CameraDepthNormalsTexture;</span><br><span class="line"><span class="comment">//固定名称</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//采样获得深度值和法线值</span></span><br><span class="line">float3 viewNormal;</span><br><span class="line"><span class="type">float</span> linear01Depth;</span><br><span class="line">float4 depthnormal = <span class="built_in">tex2D</span>(_CameraDepthNormalsTexture, i.uv);</span><br><span class="line"><span class="built_in">DecodeDepthNormal</span>(depthnormal, linear01Depth, viewNormal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//UnityCG.cginc</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">DecodeDepthNormal</span><span class="params">(<span class="type">float</span> enc, out <span class="type">float</span> depth, out float3 noraml)</span> </span>&#123;</span><br><span class="line">    depth = <span class="built_in">DecodeFloatRG</span>(enc,zw);</span><br><span class="line">    normal = <span class="built_in">DecodeViewNormalStereo</span>(enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="重建相机空间坐标"><a href="#重建相机空间坐标" class="headerlink" title="重建相机空间坐标"></a>重建相机空间坐标</h4><ul>
<li>重建方法<ul>
<li>参考链接</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92315967">https://zhuanlan.zhihu.com/p/92315967</a></li>
<li>本例实现使用其中的“从NDC空间中重建”方法得到样本在相机空间中的向量，乘以深度值得到样本的坐标</li>
</ul>
</li>
<li>从NDC空间中重建</li>
</ul>
<p>1.计算样本屏幕坐标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用Unity内置函数</span></span><br><span class="line"><span class="comment">// 屏幕纹理坐标</span></span><br><span class="line">float4 screenPos = <span class="built_in">ComputeScreenPos</span>(o.vertex);</span><br></pre></td></tr></table></figure>

<p> 2.转化至NDC空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float4 ndcPos = (screenPos/screenPos.w)*<span class="number">2</span><span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>3.计算相机空间中至远平屏幕方向（内置变量_ProjectionParams.z存放相机远平面值far）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 clipVec = <span class="built_in">float3</span>(ndcPos.x, ndcPos.y, <span class="number">1.0</span>) * _ProjectionParams.z;</span><br></pre></td></tr></table></figure>

<p>4.矩阵变换至相机空间中的样本相对相机的方向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.viewVec = mul(unity_CameraInvProjection, clipVec.xyzz).xyz;</span><br></pre></td></tr></table></figure>

<p>5.重建相机空间中的样本左边(在像素着色器)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 viewPos = linear01Depth * i.viewVec;</span><br><span class="line"><span class="comment">//在相机空间中通过样本的相对相机方向及深度来拟合重构坐标</span></span><br></pre></td></tr></table></figure>



<h4 id="构建法向量正交基"><a href="#构建法向量正交基" class="headerlink" title="构建法向量正交基"></a>构建法向量正交基</h4><ol>
<li>设置法向量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取像素相机屏幕法线，法线z方向相对于相机为负（ao需要乘以-1置反），并处理成单位向量</span></span><br><span class="line">viewNormal = <span class="built_in">normalize</span>(viewNormal) * <span class="built_in">float3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>生成随机向量（用于构建的正交基随机，而非所有样本计算得到的正交基一致）(先处理成统一)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//randvec法线半球的随机向量</span></span><br><span class="line">float3 randvec = <span class="built_in">normalize</span>(<span class="built_in">float3</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>求出切向量，再用函数叉积求副切线向量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cramm-Schimidt处理创建正交基</span></span><br><span class="line"><span class="comment">//TBN空间</span></span><br><span class="line">float3 tangent = <span class="built_in">normalize</span>(randvec - viewNormal * <span class="built_in">dot</span>(randvec, viewNormal));</span><br><span class="line">float3 bitangent = <span class="built_in">cross</span>(viewNoraml, tangent);</span><br><span class="line">float3x3 TBN = <span class="built_in">float3x3</span>(tangent, bitangent, viewNormal);</span><br></pre></td></tr></table></figure>

<h4 id="AO采样"><a href="#AO采样" class="headerlink" title="AO采样"></a>AO采样</h4><ol>
<li>传入给定的随机采样向量，并通过法向量正交基转化至法线半球中的向量(在Ｃ＃中计算出采样的随机点)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机向量，转化至TBN空间</span></span><br><span class="line">float3 randomVec = <span class="built_in">mul</span>(_SampleKernelArray[i].xyz, TBN);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取随机坐标点</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算随机法线半球后的向量</span></span><br><span class="line">float3 randomPos = viewPos + randomVec * _SampleKeneralRadius;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>转换至屏幕空间坐标</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 rclipPos = <span class="built_in">mul</span>((float3x3)unity_CameraProjection, randomPos);</span><br><span class="line">float2 rscreenPos = (rclipPos.xy / rclipPos.z) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>计算随机向量转化至屏幕空间后对应的深度值，并判断累加AO</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> randomDepth;</span><br><span class="line">float3 randomNormal;</span><br><span class="line">float4 rcdn = <span class="built_in">tex2D</span>(_CameraDepthNormalsTexture, rscreenPos);</span><br><span class="line"><span class="built_in">DecodeDepthNormal</span>(rcdn, randomDepth, randomNormal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断累加ao</span></span><br><span class="line">ao +=(randomDepth　&gt;= linear01Depth)? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>



<h3 id="四、效果改进"><a href="#四、效果改进" class="headerlink" title="四、效果改进"></a>四、效果改进</h3><p>效果后期改进说明</p>
<h4 id="随机正交基（增加随机性）"><a href="#随机正交基（增加随机性）" class="headerlink" title="随机正交基（增加随机性）"></a>随机正交基（增加随机性）</h4><ol>
<li>为了不使求得的法向半球的正交基一致，我们引入随机向量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cramm-Schimidt处理创建正交基</span></span><br><span class="line"><span class="comment">//TBN空间</span></span><br><span class="line">float3 tangent = <span class="built_in">normalize</span>(randvec - viewNormal * <span class="built_in">dot</span>(randvec, viewNormal));</span><br><span class="line">float3 bitangent = <span class="built_in">cross</span>(viewNoraml, tangent);</span><br><span class="line">float3x3 TBN = <span class="built_in">float3x3</span>(tangent, bitangent, viewNormal);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用uv采样一张noise贴图（如4x4像素（可选择其他尺寸）的noise贴图）或者随机向量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//铺平纹理</span></span><br><span class="line">float2 noiseScale = _ScreenParams.xy / <span class="number">4.0</span>;</span><br><span class="line">float2 noiseUV = i.uv * noiseScale;</span><br><span class="line"><span class="comment">//randvec法线半球的随机向量</span></span><br><span class="line">float3 randvec = <span class="built_in">tex2D</span>(_NoiseTex, noiseUV).xyz;</span><br></pre></td></tr></table></figure>

<p>在C#中传入噪声图</p>
<p><img src="/%E5%9B%BE%E5%BD%A24.2%20SSAO%E7%AE%97%E6%B3%95/image-20220912234322536.png" alt="image-20220912234322536"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssaoMaterial.SetTexture(<span class="string">&quot;_NoiseTex&quot;</span>, Noise)</span><br></pre></td></tr></table></figure>

<h4 id="AO累加平滑优化"><a href="#AO累加平滑优化" class="headerlink" title="AO累加平滑优化"></a>AO累加平滑优化</h4><h5 id="范围判定（模型边界）"><a href="#范围判定（模型边界）" class="headerlink" title="范围判定（模型边界）"></a>范围判定（模型边界）</h5><ul>
<li>样本采样可能会采集到深度差非常大的随机点，导致边界出现不该有的AO</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A24.2%20SSAO%E7%AE%97%E6%B3%95/image-20220912234446963.png" alt="image-20220912234446963"></p>
<ul>
<li>加入样本深度和随机点的深度值范围判定</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> range = <span class="built_in">abs</span>(randomDepth - linear01Depth) &gt; _RangeStrength ? <span class="number">0.0</span> : <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<p><img src="/%E5%9B%BE%E5%BD%A24.2%20SSAO%E7%AE%97%E6%B3%95/image-20220912234529623.png" alt="image-20220912234529623"></p>
<h5 id="自身判定（同一深度值情况下）"><a href="#自身判定（同一深度值情况下）" class="headerlink" title="自身判定（同一深度值情况下）"></a>自身判定（同一深度值情况下）</h5><p>如果随机点深度值和自身一样或非常接近，可能导致虽在同一平面，也会出现AO</p>
<ul>
<li>判断深度值大小的时候，增加一个Bias来改善该问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> selfCheck = randomDepth + _DepthBiasValue &lt; linear01Depth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="AO权重"><a href="#AO权重" class="headerlink" title="AO权重"></a>AO权重</h5><p>AO深度判断非0即1，比较生硬，为其增加一权重</p>
<p>本例中权重为：法线半球中随机采样后的点x,y（切平面）距离样本的距离为参考</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> weight = <span class="built_in">smoothstep</span>(<span class="number">0</span>, <span class="number">0.2</span>, <span class="built_in">length</span>(randomVec.xy));</span><br></pre></td></tr></table></figure>

<h5 id="结合"><a href="#结合" class="headerlink" title="结合"></a>结合</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ao += range * selfCheck * weight;</span><br></pre></td></tr></table></figure>

<h5 id="模糊（只展示效果对比）"><a href="#模糊（只展示效果对比）" class="headerlink" title="模糊（只展示效果对比）"></a>模糊（只展示效果对比）</h5><p>采用基于法线的双边滤波（Bilateral Filtering）</p>
<p><img src="/%E5%9B%BE%E5%BD%A24.2%20SSAO%E7%AE%97%E6%B3%95/image-20220912235055005.png" alt="image-20220912235055005"></p>
<h3 id="五、对比模型烘焙AO"><a href="#五、对比模型烘焙AO" class="headerlink" title="五、对比模型烘焙AO"></a>五、对比模型烘焙AO</h3><p>同模型烘焙AO方式对比，了解SSAO优缺点</p>
<h4 id="三维建模软件烘焙AO"><a href="#三维建模软件烘焙AO" class="headerlink" title="三维建模软件烘焙AO"></a>三维建模软件烘焙AO</h4><p>通过DCC设定好渲染参数，对模型烘焙AO到纹理</p>
<ul>
<li>优点<ul>
<li>单一物体可控性强（通过单一物体的材质球上的AO纹理贴图），可以控制单一物体的AO强弱</li>
<li>弥补场景烘焙的细节，整体场景的烘焙（包含AO信息），并不能完全包含单一物体细节上的AO，而通过DCC烘焙到纹理的方式，增加物体的AO细节</li>
<li>不影响其（Unity场景中）静态或者动态</li>
</ul>
</li>
<li>缺点<ul>
<li>操作较其他方式繁琐，需要对模型进行UV处理，再烘焙到纹理</li>
<li>不利于整体场景整合（如3Dmax烘焙到纹理只能选择单一物体，针对整体场景的处理工作量巨大）</li>
<li>增加AO纹理贴图，不利于资源优化（后期可通过其他纹理通道利用整合资源）</li>
<li>只有物体本身具有AO信息，获取物体之间的AO信息工作量巨大（不是不可能）</li>
</ul>
</li>
</ul>
<h4 id="游戏引擎烘焙AO（Unity3D-Lighting）"><a href="#游戏引擎烘焙AO（Unity3D-Lighting）" class="headerlink" title="游戏引擎烘焙AO（Unity3D Lighting）"></a>游戏引擎烘焙AO（Unity3D Lighting）</h4><p>通过Unity的Lighting功能（主菜单&#x2F;Window&#x2F;Rendering&#x2F;Lighting Settings） 进行整体场景的烘焙，AO信息包含于此</p>
<ul>
<li>优点<ul>
<li>操作简易，整体场景的烘焙，包含AO的选择</li>
<li>不受物体本身UV的影响，unity可以通过Generate Lightmap UVs生成模型第二个纹理坐标数据</li>
<li>可生产场景中物体与物体之间的AO信息</li>
</ul>
</li>
<li>缺点<ul>
<li>缺少单一物体的细节（可调整参数提高烘焙细节，但将增加烘焙纹理数量和尺寸以及烘焙时间）</li>
<li>受物体是否静态影响，动态物体无法烘焙，获得AO信息</li>
</ul>
</li>
</ul>
<h4 id="SSAO"><a href="#SSAO" class="headerlink" title="SSAO"></a>SSAO</h4><ul>
<li>优点<ul>
<li>不依赖场景的复杂度，其效果质量依赖于最终图片像素大小</li>
<li>实时计算，可用于动态场景</li>
<li>可控性强，灵活性强，操作简单</li>
</ul>
</li>
<li>缺点<ul>
<li>性能消耗较上述两种方式更多，计算昂贵</li>
<li>AO质量弱于离线烘焙</li>
</ul>
</li>
</ul>
<h3 id="六、性能消耗"><a href="#六、性能消耗" class="headerlink" title="六、性能消耗"></a>六、性能消耗</h3><p>主要性能消耗点</p>
<img src="%E5%9B%BE%E5%BD%A24.2%20SSAO%E7%AE%97%E6%B3%95/image-20220913000029828.png" alt="image-20220913000029828" style="zoom:50%;" />

<ul>
<li>AO法向半球的随机采样</li>
<li>双边滤波的多重采样</li>
</ul>
<h4 id="AO核心采样消耗说明"><a href="#AO核心采样消耗说明" class="headerlink" title="AO核心采样消耗说明"></a>AO核心采样消耗说明</h4><p>本例SSAO中，主要核心为计算AO随机法向半球的采样点</p>
<ol>
<li>使用For结构进行半球随机法向的采样，If，For对GPU计算性能上不友好</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采样核心</span></span><br><span class="line"><span class="type">float</span> ao = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sampleCount = _SampleKernelCount;<span class="comment">//每个像素点上的采样次数</span></span><br><span class="line"><span class="comment">//https://blog.csdn.net/qq_39300235/article/details/102460405</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sampleCount; i++) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">ao = ao/sampleCount;</span><br><span class="line">ao = <span class="built_in">max</span>(<span class="number">0.0</span>, <span class="number">1</span> - ao*_AOStrength);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">float4</span>(ao,ao,ao,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="实现SSAO"><a href="#实现SSAO" class="headerlink" title="实现SSAO"></a>实现SSAO</h4><h4 id="使用其他算法实现进行对比"><a href="#使用其他算法实现进行对比" class="headerlink" title="使用其他算法实现进行对比"></a>使用其他算法实现进行对比</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16q4y1U7S3">https://www.bilibili.com/video/BV16q4y1U7S3</a></p>
<p>【技术美术百人计划】图形 4.2 SSAO算法 屏幕空间环境光遮蔽</p>
<p>[2] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/09%20SSAO/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/09%20SSAO/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/26/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.2SSAO%E7%AE%97%E6%B3%95/" data-id="cmfe9guj6004hewuh43h35ts3" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形4.1Bloom算法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/08/26/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.1Bloom%E7%AE%97%E6%B3%95/">【笔记】【百人计划】图形4.1 Bloom算法</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/26/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.1Bloom%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2022-08-26T09:08:36.000Z" itemprop="datePublished">2022-08-26</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="一、Bloom算法介绍"><a href="#一、Bloom算法介绍" class="headerlink" title="一、Bloom算法介绍"></a><strong>一、Bloom算法介绍</strong></h2><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825105103409.png" alt="image-20220825105103409"></p>
<p>Bloom，也称辉光效果。模拟摄像机的一种图像效果，让物体具有真实的明亮效果。</p>
<h3 id="1-1-实现思路"><a href="#1-1-实现思路" class="headerlink" title="1.1 实现思路"></a><strong>1.1 实现思路</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825105142255.png" alt="image-20220825105142255"></p>
<ol>
<li>提取原图较量区域</li>
<li>模糊该图像</li>
<li>与原图混合</li>
</ol>
<h3 id="1-2-前置知识"><a href="#1-2-前置知识" class="headerlink" title="1.2 前置知识"></a><strong>1.2 前置知识</strong></h3><h4 id="1-2-1-HDR与LDR"><a href="#1-2-1-HDR与LDR" class="headerlink" title="1.2.1 HDR与LDR"></a><strong>1.2.1 HDR与LDR</strong></h4><p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/1_JYIZ9Hm/">https://xzyw7.github.io/post/1_JYIZ9Hm/</a></p>
<p>如果在LDR中 使用Bloom，那么阈值提取的亮度区域不会超过1，并且光源的亮度很可能和环境中的亮度接近，导致不希望出现bloom的地方也被模糊了，因此HDR更适合使用Bloom。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825105613703.png" alt="image-20220825105613703" style="zoom:50%;" />

<h4 id="1-2-2-高斯模糊"><a href="#1-2-2-高斯模糊" class="headerlink" title="1.2.2 高斯模糊"></a><strong>1.2.2 高斯模糊</strong></h4><ul>
<li>高斯模糊（Gaussian  Blur）<ul>
<li>一种图像模糊</li>
<li>减少图像噪声、降低细节层次</li>
<li>通过高斯函数定义一个卷积核，对图像进行卷积。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825105727085.png" alt="image-20220825105727085" style="zoom:50%;" />

<ul>
<li>计算高斯核<ul>
<li>用核的位置坐标带入高斯函数，计算结果进行归一化</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825113401530.png" alt="image-20220825113401530" style="zoom:50%;" />

<ul>
<li>二维高斯核<ul>
<li>计算量大，N*N*W*H次纹理采样</li>
<li>可分离性：可拆成两个一维高斯核，计算次数为（N+N）*W*H</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825113649073.png" alt="image-20220825113649073" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h2 id="二、Bloom算法应用"><a href="#二、Bloom算法应用" class="headerlink" title="二、Bloom算法应用"></a><strong>二、Bloom算法应用</strong></h2><ul>
<li>配合自发光贴图</li>
<li>配合特效</li>
<li>GodRay效果（基于径向模糊的后处理）</li>
<li>配合Tone Mapping</li>
</ul>
<h2 id="三、Bloom算法实现"><a href="#三、Bloom算法实现" class="headerlink" title="三、Bloom算法实现"></a><strong>三、Bloom算法实现</strong></h2><ul>
<li>思路<ul>
<li>C#：调用OnRenderImage函数</li>
<li>Shader：使用4个Pass完成Bloom效果</li>
</ul>
</li>
<li>但是要做后处理的效果，我们首先使用入门精要中的PostEffectsBase作为基类。这个基类就暂且不研究了。</li>
</ul>
<p>MonoBehaviour.OnRenderImage这个生命周期函数，用于获取RT与输出处理后的RT</p>
<p>这里还用到了一个重要的api，Graphics.Blit。用途是用指定的某个材质（的某个pass）来处理一个Texture，并储存到结果的RT。（pass为-1时，将依次调用所有pass）</p>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Graphics.Blit.html">https://docs.unity3d.com/ScriptReference/Graphics.Blit.html</a></p>
<p>其中<strong>src纹理会被传递给Shader中的_MainTex纹理属性</strong>。所以我们在脚本中看不到对_MainTex的处理，因为这是默认的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">PostEffectsBase</span><span class="comment">//提供了检查shder和材质的方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Shader bloomShader;</span><br><span class="line">    <span class="keyword">private</span> Material bloomMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);</span><br><span class="line">            <span class="keyword">return</span> bloomMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0,4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;<span class="comment">//模糊迭代次数</span></span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;<span class="comment">//模糊范围</span></span><br><span class="line">    [<span class="meta">Range(1,8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;<span class="comment">//下采样系数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 4.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> luminanceThreshold = <span class="number">0.6f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);</span><br><span class="line">            <span class="built_in">int</span> rtW = src.width / downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height / downSample;</span><br><span class="line"></span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW,rtH,<span class="number">0</span>);<span class="comment">//创建缓冲区</span></span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;<span class="comment">//双线性滤波</span></span><br><span class="line">            <span class="comment">// 提取亮度区域</span></span><br><span class="line">            Graphics.Blit(src,buffer0, material, <span class="number">0</span>);<span class="comment">//src,dest,mat,pass</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;iterations;i++) &#123;</span><br><span class="line">                <span class="comment">// vertical filter Pass</span></span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span>+i*blurSpread);</span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW,rtH,<span class="number">0</span>);</span><br><span class="line">                Graphics.Blit(buffer0,buffer1,material,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// horizontal filter Pass</span></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;<span class="comment">//每次模糊使用的都是上一次模糊后的结果</span></span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW,rtH,<span class="number">0</span>);</span><br><span class="line">                Graphics.Blit(buffer0,buffer1,material,<span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// Blend Pass</span></span><br><span class="line">            material.SetTexture(<span class="string">&quot;_Bloom&quot;</span>, buffer0);</span><br><span class="line">            Graphics.Blit(src,dest,material,<span class="number">3</span>);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src,dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样地，在shader里我们也要写好这4个pass。并且，这个shader是不需要创建材质然后赋给物体对象的。</p>
<p>材质是在脚本中创建的，并且通过Graphics.Blit这一API来调用pass对RT进行处理。</p>
<p>屏幕后处理实际上是在场景中绘制一个与屏幕同款同高的quad，</p>
<p>我们片段着色器输出pos并对x，y分别除以分辨率，就是这个结果。Z分量始终为1，x，y以左上角为坐标原点。所以Shader中我们仍然对顶点进行正常的变换处理。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825221804632.png" alt="image-20220825221804632" style="zoom:50%;" />



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Bloom&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base(RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Bloom(<span class="string">&quot;Bloom(RGB)&quot;</span>,<span class="number">2</span>D)=<span class="string">&quot;black&quot;</span>&#123;&#125;</span><br><span class="line">        _LuminanceThreshold(<span class="string">&quot;Luminance Threshold&quot;</span>,Float)=<span class="number">0.5</span></span><br><span class="line">        _BlurSize(<span class="string">&quot;Blur Size&quot;</span>, Float) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        sampler2D _Bloom;</span><br><span class="line">        <span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">v2fExtractBright</span> &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">v2fExtractBright <span class="title">vertExtractBright</span><span class="params">(appdata_img v)</span> </span>&#123;</span><br><span class="line">            v2fExtractBright o;</span><br><span class="line">            o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">fixed <span class="title">luminance</span><span class="params">(fixed4 color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">fixed4 <span class="title">fragExtractBright</span> <span class="params">( v2fExtractBright i)</span> : SV_Target &#123;</span></span><br><span class="line">            fixed4 c =<span class="built_in">tex2D</span>(_MainTex, i.uv);</span><br><span class="line">            fixed val = <span class="built_in">clamp</span>(<span class="built_in">luminance</span>(c)-_LuminanceThreshold, <span class="number">0.0</span> ,<span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">return</span> c*val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">v2fBlur</span> &#123;</span><br><span class="line">            float4 pos: SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>] : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">v2fBlur <span class="title">vertexBlurVertical</span><span class="params">(appdata_img v)</span> </span>&#123;</span><br><span class="line">            v2fBlur o;</span><br><span class="line">            o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + <span class="built_in">float2</span>(<span class="number">0.0</span>, _MainTex_TexelSize.y *<span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - <span class="built_in">float2</span>(<span class="number">0.0</span>, _MainTex_TexelSize.y *<span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + <span class="built_in">float2</span>(<span class="number">0.0</span>, _MainTex_TexelSize.y *<span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - <span class="built_in">float2</span>(<span class="number">0.0</span>, _MainTex_TexelSize.y *<span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">v2fBlur <span class="title">vertexBlurHorizontal</span><span class="params">(appdata_img v)</span> </span>&#123;</span><br><span class="line">            v2fBlur o;</span><br><span class="line">            o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + <span class="built_in">float2</span>( _MainTex_TexelSize.x *<span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - <span class="built_in">float2</span>( _MainTex_TexelSize.x *<span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + <span class="built_in">float2</span>( _MainTex_TexelSize.x *<span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - <span class="built_in">float2</span>( _MainTex_TexelSize.x *<span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">fixed4 <span class="title">fragBlur</span><span class="params">(v2fBlur i)</span> :SV_Target &#123;</span></span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">            fixed3 sum = <span class="built_in">tex2D</span>(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>;it++) &#123;</span><br><span class="line">                sum += <span class="built_in">tex2D</span>(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += <span class="built_in">tex2D</span>(_MainTex, i.uv[it*<span class="number">2</span>]).rgb* weight[it];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fixed4</span>(sum, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">v2fBloom</span> &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half4 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">v2fBloom <span class="title">vertBloom</span><span class="params">(appdata_img v)</span> </span>&#123;</span><br><span class="line">            v2fBloom o;</span><br><span class="line">            o.pos = <span class="built_in">UnityObjectToClipPos</span>(v.vertex)/<span class="number">3</span>;</span><br><span class="line">            o.uv.xy = v.texcoord;</span><br><span class="line">            o.uv.zw = v.texcoord;</span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y&lt;<span class="number">0.0</span>) &#123;</span><br><span class="line">                o.uv.w = <span class="number">1.0</span>-o.uv.w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">fixed4 <span class="title">fragBloom</span><span class="params">(v2fBloom i)</span>: SV_Target &#123;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">tex2D</span>(_MainTex, i.uv.xy) + <span class="built_in">tex2D</span>(_Bloom, i.uv.zw);<span class="comment">//fixed4(i.pos.x/1920,i.pos.y/1080,i.pos.z,1);//</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line">        ZTest Always Cull off ZWrite off</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertExtractBright</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragExtractBright</span></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">        &#125;        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertexBlurVertical</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragBlur</span></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertexBlurHorizontal</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragBlur</span></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertBloom</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragBloom</span></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825212340311.png" alt="image-20220825212340311" style="zoom:33%;" />

<p>模糊后</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825212418349.png" alt="image-20220825212418349" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825212653314.png" alt="image-20220825212653314" style="zoom:50%;" />



<p>但是依然存在一个问题。</p>
<p>就是这个downSample和高斯模糊什么关系？很容易想到，用同样的核进行滤波，下采样后滤波再上采样回去，会更模糊。这就相当于用更大的核来进行滤波。</p>
<p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/1_JYIZ9Hm/">【笔记】【百人计划】图形2.7 LDR与HDR | XZYW (xzyw7.github.io)</a></p>
<p>在LDR与HDR的笔记中曾经提到过Unity的Bloom方式。Unity就是多次下采样来完成Bloom效果的，不妨把它叫做coreSize的方法</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730184829163.png" alt="image-20220730184829163" style="zoom:50%;" />

<p>我们也可以做这样的处理，只需要在每次迭代中增加下采样的次数就可以了。</p>
<p>还要做一个小小的修改就是blurSize的处理</p>
<p>material.SetFloat(“_BlurSize”, 1.0f);教程中为了达到这样的效果，采用了每次迭代增加BlurSize的方法，如下图（ <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/471923875%EF%BC%89%E3%80%82">https://zhuanlan.zhihu.com/p/471923875）。</a></p>
<p>我们这里每次迭代都增加下采样，自然不用做这个处理。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/v2-a45a98e33d4695052d709030bdf21a63_720w.jpg" alt="img"></p>
<p>得到的更优的结果就是，在更大的迭代数下能够减少虚影</p>
<p>blurSpread过大会导致严重的虚影</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220826001629757.png" alt="image-20220826001629757" style="zoom:50%;" />

<p>到这里还有一个问题</p>
<p>就是其实我们会发现我们的辉光，一点都不辉，一点都不光，每次下采样后，模糊是模糊了，但是整个“光晕”也变暗了。</p>
<p>按照上面的说法，我们应该把每次下采样的结果叠加起来。于是我们再新建一个RT缓冲区，用来储存下采样模糊的叠加结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer1 = RenderTexture.<span class="built_in">GetTemporary</span>(rtW,rtH,<span class="number">0</span>);</span><br><span class="line">material.<span class="built_in">SetTexture</span>(<span class="string">&quot;_Bloom&quot;</span>, buffer0);</span><br><span class="line">Graphics.<span class="built_in">Blit</span>(bufferResult1,buffer1,material,<span class="number">3</span>);</span><br><span class="line">RenderTexture.<span class="built_in">ReleaseTemporary</span>(bufferResult1);</span><br><span class="line">bufferResult1 = buffer1;</span><br></pre></td></tr></table></figure>

<p>是理想中的辉光没错了。但是这种做法要注意控制迭代次数，因为亮度是叠加的，迭代次数太多会过曝。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220826003752777.png" alt="image-20220826003752777" style="zoom:50%;" />

<p>但是这样做的时候，用blurSize的结果是非常好的，但是用coreSize就出问题了。迭代次数越多，像素化越严重，以下是3次迭代，再增加就没法看了。正如入门精要中提及，尽管downSample值越大，性能越好，但过大的DownSample可能会造成图像像素化。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220826010042787.png" alt="image-20220826010042787" style="zoom:50%;" />

<p>的确，blurSize的方法只在最开始的时候做downSample，而coreSize的方法每一次迭代都进行下采样，是非常节省性能的，但在这种叠加的时候，就出现问题了，因为下采样的区域差别是指数级的，叠加后会形成明显的区分。</p>
<p>而blurSize的方法始终是在同一分辨率上做间隔采样，每次迭代只是增加了间隔数量，不会出现这种问题。</p>
<p>所以，为了好看的效果，还是老老实实用blurSize吧。</p>
<p>（不知道有没有更好的做法，能够用coreSize的方法的同时，得到均匀的Bloom）</p>
<ul>
<li><p>URP中的Bloom与本方法的Bloom</p>
<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220826012921143.png" alt="image-20220826012921143"></li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220826013319692.png" alt="image-20220826013319692"></li>
</ul>
</li>
<li><p>还有些小问题，之前加上bloom后一直出现game界面闪烁。。。就是鼠标移到game里面以后，或者移出来，画面会闪一下，运行时就很稳定。</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">RenderTexture buffer0 = RenderTexture.GetTemporary(rtW,rtH,<span class="number">0</span>);<span class="comment">//创建缓冲区</span></span><br><span class="line">buffer0.filterMode = FilterMode.Bilinear;<span class="comment">//双线性滤波</span></span><br><span class="line"><span class="comment">// 提取亮度区域</span></span><br><span class="line">Graphics.Blit(src,buffer0, material, <span class="number">0</span>);<span class="comment">//src,dest,mat,pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个RT buffer用来储存叠加结果</span></span><br><span class="line">RenderTexture bufferResult1 = RenderTexture.GetTemporary(rtW,rtH,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;iterations;i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vertical filter Pass</span></span><br><span class="line">    <span class="comment">//material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i*blurSpread);</span></span><br><span class="line">    material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1</span> + i * blurSpread);</span><br><span class="line">    RenderTexture buffer1 = RenderTexture.GetTemporary(rtW,rtH,<span class="number">0</span>);</span><br><span class="line">    Graphics.Blit(buffer0,buffer1,material,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// horizontal filter Pass</span></span><br><span class="line">    RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">    buffer0 = buffer1;<span class="comment">//每次模糊使用的都是上一次模糊后的结果</span></span><br><span class="line">    buffer1 = RenderTexture.GetTemporary(rtW,rtH,<span class="number">0</span>);</span><br><span class="line">    Graphics.Blit(buffer0,buffer1,material,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">    buffer0 = buffer1;</span><br><span class="line">    <span class="comment">//这里有个很重要的tips</span></span><br><span class="line">    <span class="comment">//buffer1的声明周期是在for循环内，进入下一次迭代，这里的buffer1就自动销毁了，经过测试，如果我们在这里释放buffer1的内存，后面所有的图像都没了。也就是说，buffer0指向的这块内存在这里被销毁了。而如果让它自然进入下一次迭代的化，buffer1生命周期结束，但是buffer0是指向这块内存的，仍然存在（参考智能指针）。</span></span><br><span class="line">    <span class="comment">//而且还要更复杂一些，似乎是因为GetTemporary的分配机制，他们的rt资源是重用的，gpu并没有分配新的rt。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 换一个新的temporal RT就不会出现这个问题。</span></span><br><span class="line">    <span class="comment">// 储存下采样结果</span></span><br><span class="line">    material.SetTexture(<span class="string">&quot;_Bloom&quot;</span>, buffer0);<span class="comment">// 这一级的下采样结果</span></span><br><span class="line">    RenderTexture bufferResult2 = RenderTexture.GetTemporary(rtW,rtH,<span class="number">0</span>);<span class="comment">// 把闲置的buffer1利用起来</span></span><br><span class="line">    Graphics.Blit(bufferResult1,bufferResult2,material,<span class="number">3</span>);</span><br><span class="line">    RenderTexture.ReleaseTemporary(bufferResult1);</span><br><span class="line">    bufferResult1 = bufferResult2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leonwei/article/details/54972653">https://blog.csdn.net/leonwei/article/details/54972653</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/RenderTexture.html">https://docs.unity3d.com/ScriptReference/RenderTexture.html</a></p>
<ul>
<li>实际上，我们的bloom的范围还应该受到亮度的影响</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91390940%E5%8F%91%E7%8E%B0%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%B9%9F%E5%81%9A%E4%BA%86%E7%9B%B8%E5%90%8C%E7%9A%84Bloom%E7%B4%AF%E5%8A%A0%E6%93%8D%E4%BD%9C">https://zhuanlan.zhihu.com/p/91390940发现这篇文章也做了相同的Bloom累加操作</a></p>
<p>看SSAO的开头的时候发现有同学提到catlike中也有Bloom的教程，去找了下放在这，之后可以看看这个是怎么处理这些细节的。</p>
<p><a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/advanced-rendering/bloom/">https://catlikecoding.com/unity/tutorials/advanced-rendering/bloom/</a></p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h2><ol>
<li>实现Bloom效果</li>
<li>思考如何实现Bloom的mask功能，让区域不产生bloom效果</li>
</ol>
<p>首先是理解这个问题，什么叫做Bloom的Mask。我的理解就是，正常的Bloom是对整张图片做后处理，那么整个画面都会受到一个全局的影响，而施加mask就是让场景中的一部分物体，虽然亮度超过阈值，但是不产生Bloom。</p>
<p>也就是说，在亮度提取的部分，给它一个Mask，不会提取到这部分亮度。</p>
<ul>
<li>FB的Alpha通道<ul>
<li>我们可以在物体渲染的最后在alpha通道加上我们的mask参数，然后在亮度提取的时候乘上alpha通道（mask）</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220826115737712.png" alt="image-20220826115737712" style="zoom:50%;" /></li>
<li>可以看到问题就是，半透明发光物体也会被影响，但控制效果是达到了。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220826115659429.png" alt="image-20220826115659429" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220826115718616.png" alt="image-20220826115718616" style="zoom:50%;" />

<ul>
<li>模板测试<ul>
<li>很自然而然的，这张mask我们可以用模板缓冲来做。</li>
<li>就不实操了，纸上谈兵一下，渲染每个物体的时候把相关的mask写入模板缓冲，</li>
<li>在亮度提取pass，用Equal或者其他什么操作，通过测试再提取亮度</li>
</ul>
</li>
<li>传入一张Mask<ul>
<li>可以直接public指定一个Texture2D，然后作为参数</li>
<li>我这里随便拖了个黑白的贴图，效果还是很好的。但是实用性好像不是很大</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220826120812649.png" alt="image-20220826120812649"></li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><p>[1]  <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1a3411z7LC">https://www.bilibili.com/video/BV1a3411z7LC</a></p>
<p>【技术美术百人计划】图形 4.1 Bloom算法 游戏中的辉光效果实现</p>
<p>[2] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/471923875">https://zhuanlan.zhihu.com/p/471923875</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://kalogirou.net/2006/05/20/how-to-do-good-bloom-for-hdr-rendering/">https://kalogirou.net/2006/05/20/how-to-do-good-bloom-for-hdr-rendering/</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Graphics.Blit.html">https://docs.unity3d.com/ScriptReference/Graphics.Blit.html</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://blog.csdn.net/leonwei/article/details/54972653">https://blog.csdn.net/leonwei/article/details/54972653</a></p>
<p>[6] <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/RenderTexture.html">https://docs.unity3d.com/ScriptReference/RenderTexture.html</a></p>
<p>[7] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91390940">https://zhuanlan.zhihu.com/p/91390940</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/26/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A24.1Bloom%E7%AE%97%E6%B3%95/" data-id="cmfe9guj5004eewuhd1cs4utq" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" rel="tag">过程记录</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/Opengl learning_01" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/08/24/TA/OpenGL/Opengl%20learning_01/">【笔记】Cherno Opengl Tutorial note 01</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/24/TA/OpenGL/Opengl%20learning_01/" class="article-date">
  <time datetime="2022-08-24T13:58:56.000Z" itemprop="datePublished">2022-08-24</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="01-Introduction"><a href="#01-Introduction" class="headerlink" title="01 Introduction"></a><strong>01 Introduction</strong></h2><ul>
<li><p>Opengl不是一个库或者api，Opengl本身是一种规范</p>
</li>
<li><p>实现这种规范的是GPU厂商</p>
</li>
<li><p>这种实现是在显卡驱动程序上的</p>
</li>
<li><p>每个厂商对Opengl的实现都会有不同。</p>
</li>
<li><p>因此Opengl不可能是开源的，这取决于编写的厂商，Nvidia，AMD</p>
</li>
<li><p>Opengl是跨平台的。</p>
</li>
<li><p>着色器是运行在gpu上的一段程序</p>
</li>
</ul>
<h2 id="02-Setting-up-Opengl-and-Creating-a-Window-in-C"><a href="#02-Setting-up-Opengl-and-Creating-a-Window-in-C" class="headerlink" title="02 Setting up Opengl and Creating a Window in C++"></a><strong>02 Setting up Opengl and Creating a Window in C++</strong></h2><p>thecherno.com&#x2F;discord</p>
<ul>
<li>提供窗口的创建与管理——GLFW（多平台）</li>
<li>我们当然可以下载glfw源码作为静态库在项目中编译</li>
<li>为了方便选择预编译的二进制文件，配置环境这一部分在C++里已经做过了</li>
</ul>
<p>这个时候直接允许文档的参考代码，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以编译成功，但是链接出现了问题</p>
<p>无法解析的外部符号__imp__glClear@4</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818120630494.png" alt="image-20220818120630494"></p>
<p>我们知道这是链接的问题，我们需要找到一个glClear函数，在一个我们没有添加的库文件中。</p>
<p>这个库文件就是OpenGL32.lib</p>
<p>（<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41524721/article/details/104330656%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E4%B9%9F%E7%BB%99%E5%87%BA%E4%BA%86%E8%BF%99%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82%EF%BC%89">https://blog.csdn.net/qq_41524721/article/details/104330656这个博客也给出了这个解决方案。）</a></p>
<p>这样我们成功地允许了文档的参考代码，画出了一个窗口</p>
<p>(Cherno教程当中还有一些关于平台注册的函数的连接失败，User32.lib 、Gid32.lib、Shell32.lib，我之所以没有出现这个问题，发现在项目设置的连接器命令行里已经处理过了。。。从项目默认继承也不知道咋继承出来的，但是缺少库文件，就该这样链接)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line"></span><br><span class="line">glVertex2f(-0.5f,-0.5f)</span><br><span class="line">glVertex2f(0.0f,0.5f)</span><br><span class="line">glVertex2f(0.5f,-0.5f)</span><br><span class="line"></span><br><span class="line">glEnd();</span><br></pre></td></tr></table></figure>



<h2 id="03-Using-Modern-Opengl-in-C"><a href="#03-Using-Modern-Opengl-in-C" class="headerlink" title="03 Using Modern  Opengl in C++"></a><strong>03 Using Modern  Opengl in C++</strong></h2><p>如介绍中所说，Opengl的规范是显卡制造商实现的，因此我们需要做的是进入驱动程序，“获取”函数并调用（访问驱动程序dll文件并检索指向库中函数的指针）</p>
<p>理论上这是可以手动操作的，但无法跨平台。</p>
<p>而能够实现这些操作的库：</p>
<ul>
<li>glew(opengl extention wrangler)</li>
<li>glad</li>
</ul>
<p>教程将会使用Glew</p>
<p><a target="_blank" rel="noopener" href="http://glew.sourceforge.net/">http://glew.sourceforge.net/</a></p>
<p>我们同样只要关注include和lib文件夹（下载的压缩包里顺便有文档）</p>
<p>第一件事是创建一个有效的opengl渲染上下文（contex），然后使用glewInit()去初始化扩展入口点（initialize the extension entry points）</p>
<p>注意lib里面有两个文件</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818224754923.png" alt="image-20220818224754923"></p>
<p>技术上这两个链接库都是静态的，但是glew32.lib是链接到dll使用的。glew32s.lib(static)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">glewInit</span>();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果这样去include的话，会收获一个错误fatal error C1189: #error:  gl.h included before glew.h</p>
<p>双击这个错误我们可以在 glew.h中看到定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__gl_h_) || defined(__GL_H__) || defined(_GL_H) || defined(__X_GL_H)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> gl.h included before glew.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>所以我们应该把glew放到前面。</p>
<p>但是这部操作之后，我们发现了链接错误</p>
<p>error LNK2019: 无法解析的外部符号 __imp__glewInit@0，函数 _main 中引用了该符号</p>
<p>但是链接按理来说应该是正确的。在glew.h中搜索glewInit的定义，</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818230050838.png" alt="image-20220818230050838"></p>
<p>可以看到在实际返回类型前有一个GLEWAPI的宏定义</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818230652054.png" alt="image-20220818230652054"></p>
<p>我们没有定义GLEW_STATIC和 GLEW_BUILD，所以把GLEWAPI定义为了extern __declspec(dllimport)</p>
<p>这是一个 内置的msvc编译器，告诉链接器它来自于一个dll文件，所以需要dll引用，但是我们没有用dll版本的 glew。</p>
<p>所以我们要做的是——自己定义（其实这些文档里都有）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818230543814.png" alt="image-20220818230543814"></p>
<p>这回又可以画好我们的三角形了。但是如果按照文档运行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line"><span class="built_in">glutCreateWindow</span>(<span class="string">&quot;GLEW Test&quot;</span>);</span><br><span class="line">GLenum err = <span class="built_in">glewInit</span>();</span><br><span class="line"><span class="keyword">if</span> (GLEW_OK != err)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Problem: glewInit failed, something is seriously wrong. */</span></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">glewGetErrorString</span>(err));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Status: Using GLEW %s\n&quot;</span>, <span class="built_in">glewGetString</span>(GLEW_VERSION));</span><br></pre></td></tr></table></figure>

<p>我们将会失败，因为glewInit是有返回值的，这个失败说明初始化并不成功。</p>
<p>因为我们需要先创建一个&#x3D;&#x3D;opengl渲染上下文&#x3D;&#x3D;。</p>
<p>而这个上下文就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure>

<p>把glew初始化放在这之后就成功了。</p>
<p>我们还可以输出我们的 opengl版本号（这与glew无关）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="built_in">glGetString</span>(GL_VERSION)&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<p>可以看到我的输出是：</p>
<p>4.6.0 NVIDIA 462.30</p>
<h2 id="04-Vertex-Buffers-and-Drawing-a-Triangle"><a href="#04-Vertex-Buffers-and-Drawing-a-Triangle" class="headerlink" title="04 Vertex Buffers and Drawing a Triangle"></a><strong>04 Vertex Buffers and Drawing a Triangle</strong></h2><p>Vertex Buffer顶点缓冲区就是一个（内存）缓冲区，实质是一个数组字节的内存。</p>
<p>区别是这是Opengl中的内存缓冲区，这表明它实际在我们的GPU中（显存VRAM）</p>
<p>当我们定义一组数据来表示三角形，将它存进GPU的VRAM中，然后我们需要调用DrawCall，让GPU从VRAM中读数据。</p>
<p>此外，我们还需要告诉GPU如何读取和解释数据，以及如何把它放到屏幕上。</p>
<p>关于渲染管线，就不赘述了。</p>
<p>还要记住 Opengl是一种状态机。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);<span class="comment">//生成一个缓冲区，而buffer就是生成的缓冲区的id</span></span><br><span class="line"><span class="comment">//通常是0，1，2，3...0一般表示无效值</span></span><br></pre></td></tr></table></figure>

<p>这就是实际对象的id，无论它储存顶点还是纹理…</p>
<p>那么我们就需要表示这块缓冲区如何使用 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);<span class="comment">//绑定缓冲区——表示我们如何使用它</span></span><br><span class="line"><span class="comment">//GL_ARRAY_BUFFER表示，这块缓冲区只是一个数组</span></span><br></pre></td></tr></table></figure>

<p>而下一步就应该向缓冲区里传入数据。</p>
<p>我们可以创建缓冲区时指定大小，然后直接给出数据；或者什么都不给，用数据来更新。</p>
<p>我们现在为它提供绘制三角形的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">	 <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;<span class="comment">//先准备好数据</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW)</span><br><span class="line"><span class="comment">//也可以6*sizeof(float)，这些都是我们知道的</span></span><br></pre></td></tr></table></figure>

<p>查文档啥都有 <a target="_blank" rel="noopener" href="https://docs.gl/">https://docs.gl/</a> ，这里包含了各种版本opengl的文档</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819000352210.png" alt="image-20220819000352210"></p>
<p>非常好用（刚才我们看过opengl版本了，所以是gl4）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819000549306.png" alt="image-20220819000549306"></p>
<p>下面也有每个参数的含义</p>
<p>关于usage，是如何访问缓冲区对象的数据储存区的提示。包括访问频率（STREAM修改一次，最多使用几次,STATIC修改一次多次使用,DYNAMIC反复修改并多次使用）和访问性质(DRAW,READ,COPY)</p>
<p>静态和动态是最常用的。静态表示我们只创建一次缓冲区，不会每一帧都修改buffer，但是每一帧都绘制。</p>
<p>但要注意这只是一个Hint提示，即便声明静态，每一帧更新缓冲区仍然可以工作，只是会慢很多。</p>
<p>通常到这里我们还需要创建Index buffer，但是这里就先不用了</p>
<p>我们再来看这一串，就是在显存建立缓冲区，并指定缓冲区对象的名称（用途），最后把CPU内存的数据拿给显存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line"><span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"><span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;<span class="comment">//先准备好数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是我们依然不知道如何使用这6个浮点数据。</p>
<p>我们也没有着色器来指定如何绘制 这些数据。这是之后的内容</p>
<p>但是如果要绘制的话，可以这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES,0,3);//我们没有index buffer，可以这样做</span><br><span class="line">//Mode,First(starting index),Count(number of indices)</span><br></pre></td></tr></table></figure>

<p>另一种方式是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glDrawElements(GL_TRIANGLS,3,GL_UNSIGNED_INT,indices)//和idnex buffer一起使用</span><br><span class="line">//Mode</span><br><span class="line">//count</span><br><span class="line">//type:Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT</span><br><span class="line">//indices</span><br></pre></td></tr></table></figure>

<p>这就是DrawCall</p>
<p>注意Opengl的状态机性质，因为前面绑定了这个三角形的数据，所以drawcall就会绘制这个三角形</p>
<h2 id="05-Vertex-Attribute-and-Layouts-in-Opengl"><a href="#05-Vertex-Attribute-and-Layouts-in-Opengl" class="headerlink" title="05 Vertex Attribute and Layouts in Opengl"></a><strong>05 Vertex Attribute and Layouts in Opengl</strong></h2><p>总结一下，Opengl的管线工作流程就是为显卡提供数据，然后储存进GPU显存，包含了所有数据。我们会使用着色器程序在gpu上执行，去读取数据然后进行绘制。</p>
<p>当着色器读取数据时，顶点缓存需要知道缓存数据的布局&#x3D;&#x3D;Layout&#x3D;&#x3D;——这是一堆浮点数，包含每个顶点的位置、法线、纹理坐标。。。因此我们需要告诉Opengl内存的数据是如何布局的 。</p>
<p>顶点数据内储存了各种属性，而绑定属性的方式就是顶点属性指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glVertexAttribPointer</span><span class="params">(	GLuint	index,<span class="comment">//属性的索引，(第几个属性，而不是位置)</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLint	size, <span class="comment">//只接受1234</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="comment">//就像你不会见到float5</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLenum	type,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="comment">//初始为GL_FLOAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLboolean	normalized,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLsizei	stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> GLvoid *	pointer)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>noramlized</p>
<ul>
<li>规范化设置</li>
<li>如果规范化设置为GL_TRUE ，则表示以整数格式存储的值在被访问并转换为浮点时将映射到范围 [-1，1]（对于有符号值）或 [0，1]（对于无符号值）。否则，值将直接转换为浮点数，而无需规范化。GL_FLOAT的设置已经规范了</li>
</ul>
</li>
<li><p>stride</p>
<ul>
<li>连续通用顶点属性之间的字节偏移量：每个顶点之间的字节数量</li>
<li>比如我们有一个位置3<em>float,uv坐标2</em>float,法线3*float 12bytes+8bytes+12bytes，stride &#x3D; 32bytes</li>
<li>可以想象Opengl从一个顶点属性跳到下一个顶点的属性，就直接根据步幅寻找</li>
</ul>
</li>
<li><p>point</p>
<ul>
<li>指定当前绑定到目标的缓冲区的数据存储区中数组中第一个通用顶点属性的第一个组件的偏移量。。。缩句，数组的第一个属性的第一个组件的偏移量</li>
<li>初始为0。</li>
<li>比如位置是0，uv是12bytes(12)，法线是20bytes(20)</li>
<li>C++有提供偏移类的宏</li>
<li>注意这里需要const void*，因此需要如转换(const void*) 8</li>
</ul>
</li>
</ul>
<p>我们还需要启用这个顶点属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexArrayAttrib</span>(<span class="number">0</span>);<span class="comment">//index of vertex attribute</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;<span class="comment">//先准备好数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>以上CPU阶段的准备工作就完成了，接下来调用drawcall，就开始执行着色器程序了。</p>
<h2 id="06-How-a-Shader-Work-in-Opengl"><a href="#06-How-a-Shader-Work-in-Opengl" class="headerlink" title="06 How a Shader Work in Opengl"></a><strong>06 How a Shader Work in Opengl</strong></h2><p>实际上这个时候我们不写着色器，屏幕上已经可以画出三角形了。这是因为如果我们没有写自己的着色器的话，一些GPU会提供默认着色器。</p>
<p>回顾vs和fs的区别，vs对于每个顶点运行，fs对于每个像素运行。假如三角形非常巨大，那么同样的运算，vs只需要执行3次，fs则需要执行像素数的次数。这个特性可以用于一些性能优化。</p>
<p>其他关于shader的内容就不赘述了。</p>
<h2 id="07-Writing-a-Shader-in-Opengl"><a href="#07-Writing-a-Shader-in-Opengl" class="headerlink" title="07 Writing a Shader in Opengl"></a><strong>07 Writing a Shader in Opengl</strong></h2><p>我们需要定义一个新的函数，并且是静态的。因为不希望它在其他cpp文件中使用。</p>
<p>它用来编译我们的着色器代码。</p>
<p>着色器代码可以来自不同地方 ，我们可以简单地只写一个字符串。也可以从文件读取。</p>
<p>我们需要让Opengl编译这个程序，把vs和fs连接到一个单独的着色器程序中，并返回某种唯一的标识符，所以我们可以绑定一个着色器，然后像使用顶点缓冲那样，生成一个缓冲并返回一个id去使用它。（生成缓冲区-绑定-传递）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">ComplieShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type); <span class="comment">//在gpu中创建（绑定）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();<span class="comment">//把std string转换为原生字符串；</span></span><br><span class="line">    <span class="comment">//或const char* src = &amp;source[0]</span></span><br><span class="line">    <span class="comment">//我们一直在使用引用，因为要保证编译时原来的字符串始终存在。</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="comment">//通过glGetShaderiv来查询它是否有错误</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result)&#123;<span class="comment">//GL_FALSE = 0</span></span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">    	<span class="comment">//char message[length];栈分配不能使用，因为length不是常量</span></span><br><span class="line">        <span class="comment">//大多数人会使用堆分配，记得删除。但还是在栈分配上，可以如下</span></span><br><span class="line">        <span class="type">char</span>* message =(<span class="type">char</span>*) <span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Fail to complie&quot;</span>&lt;&lt;(type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex&quot;</span> : <span class="string">&quot;fragment&quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;message&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在很多地方没有使用内置变量GLuint等，是因为作者趋向使用多种图形api</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="comment">//unsigned int vs = glCreateShader(GL_VERTEX_SHADER);</span></span><br><span class="line">    <span class="comment">//把这一步封装到了ComplieShader里，因为所有shader都是一样的步骤，只是类型不同 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">ComplieShader</span>(GL_VERTEX_SHADER,vertexShader);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">ComplieShader</span>(GL_FRAGMENT_SHADER,fragmentShader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这样我们就编译好了着色器，并且取得他们的id</span></span><br><span class="line">    <span class="comment">//就像编译C++一样，对于两份文件，我们需要链接到一个程序中</span></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//着色器已经链接到一个程序中了，我们可以删除掉了。就像我们可以删除obj中间文件</span></span><br><span class="line">    <span class="comment">//我们的实际程序已经在program里了</span></span><br><span class="line">    <span class="comment">//还有如glDetachShader之类的会删除源代码，但可以不用</span></span><br><span class="line">    <span class="comment">//它们占用内存很少，并且处理图像、调试等等保留着色器源代码是有用的</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glShaderSource</span><span class="params">(GLuint , shader</span></span></span><br><span class="line"><span class="params"><span class="function">					GLsizei , count</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">const</span> GLchar **, string</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">const</span> GLint *length)</span></span>;</span><br><span class="line"><span class="comment">//shader</span></span><br><span class="line"><span class="comment">//Specifies the handle of the shader object whose source code is to be replaced.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//count</span></span><br><span class="line"><span class="comment">//Specifies the number of elements in the string and length arrays.字符串的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string</span></span><br><span class="line"><span class="comment">//Specifies an array of pointers to strings containing the source code to be loaded into the shader.</span></span><br><span class="line"><span class="comment">//需要提供一个双指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//length</span></span><br><span class="line"><span class="comment">//Specifies an array of string lengths.</span></span><br><span class="line"><span class="comment">//null表示以null终止</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>着色器的编译和传递方法就完成了。</p>
<p>接下来我们编写着色器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">std::string vertexShader = </span><br><span class="line">    <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout(location = 0) in vec4 position;\n&quot;</span></span><br><span class="line">    <span class="comment">//和顶点属性的laout一致。</span></span><br><span class="line">    <span class="comment">//注意这里是vec4，而我们实际只有vec2，剩余的部分Opengl会默认转换z0w1</span></span><br><span class="line">	<span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;	gl_Position = position;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">std::string fragmentShader =</span><br><span class="line">    <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout(location = 0) out vec4 color;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;	color = vec4(1.0,0.0,0.0,1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader,fragmentShader);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非常顺利</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819124846651.png" alt="image-20220819124846651"></p>
<p>再检查着色器的错误处理</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819125229576.png" alt="image-20220819125229576"></p>
<p>源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">ComplieShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fail to complie&quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex&quot;</span> : <span class="string">&quot;fragment&quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">ComplieShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">ComplieShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;GlewInit fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    &#125;;<span class="comment">//先准备好数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::string vertexShader =</span><br><span class="line">        <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;layout(location = 0) in vec4 position;\n&quot;</span></span><br><span class="line">        <span class="comment">//和顶点属性的laout一致。</span></span><br><span class="line">        <span class="comment">//注意这里是vec4，而我们实际只有vec2，剩余的部分Opengl会默认转换z0w1</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;void main()&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;	gl_Position = position;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">    std::string fragmentShader =</span><br><span class="line">        <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;layout(location = 0) out vec4 color;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;void main()&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;	color = vec4(1.0,0.0,0.0,1.0);\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader, fragmentShader);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(shader);<span class="comment">//清理着色器</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/24/TA/OpenGL/Opengl%20learning_01/" data-id="cmfe9guit0027ewuhameh2hkn" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Opengl/" rel="tag">Opengl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.6纹理压缩" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/08/24/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.6%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9/">【笔记】【百人计划】图形3.6 纹理压缩</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/24/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.6%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9/" class="article-date">
  <time datetime="2022-08-24T12:49:23.000Z" itemprop="datePublished">2022-08-24</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="1-什么是纹理压缩"><a href="#1-什么是纹理压缩" class="headerlink" title="1. 什么是纹理压缩"></a><strong>1. 什么是纹理压缩</strong></h3><p>纹理压缩：是为了解决<strong>内存、带宽</strong>问题，专为在计算机图形渲染系统中存储纹理而使用的图像压缩技术。</p>
<h4 id="1-1-图片与纹理"><a href="#1-1-图片与纹理" class="headerlink" title="1.1 图片与纹理"></a><strong>1.1 图片与纹理</strong></h4><ul>
<li>图片格式<ul>
<li>图片格式是图片文件的存储格式，通常在磁盘、内存中储存和传输文件时使用。</li>
<li>例如：jpg、png、gif、bmp等</li>
</ul>
</li>
<li>纹理格式<ul>
<li>纹理格式是显卡能够直接进行采样的纹理数据格式，通常在向显卡中加载纹理时使用。</li>
</ul>
</li>
<li>纹理管线<ul>
<li>纹理压缩格式基于块压缩，能够更快读取像素所需字节块进行解压所以支持随机访问。</li>
<li>图片压缩格式基于整张图片进行压缩，无法直接实现单个像素的解析。</li>
<li>图片压缩格式无法被GPU识别，还需要经CPU解压缩成非压缩纹理格式才能被识别。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824164504787.png" alt="image-20220824164504787"></p>
<h3 id="2-常见纹理压缩格式"><a href="#2-常见纹理压缩格式" class="headerlink" title="2. 常见纹理压缩格式"></a><strong>2. 常见纹理压缩格式</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824164711622.png" alt="image-20220824164711622"></p>
<h4 id="2-1-非压缩格式"><a href="#2-1-非压缩格式" class="headerlink" title="2.1 非压缩格式"></a><strong>2.1 非压缩格式</strong></h4><table>
<thead>
<tr>
<th align="center">非压缩格式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">RGBA8888(RGBA32)</td>
<td>一个像素32位，包含A通道（一个像素消耗4字节）</td>
</tr>
<tr>
<td align="center">RGBA4444(RGBA16)</td>
<td>一个像素16位，包含A通道（一个像素消耗2字节）</td>
</tr>
<tr>
<td align="center">RGB888(RGB24)</td>
<td>一个像素24位，无A通道（一个像素消耗3字节）</td>
</tr>
<tr>
<td align="center">RGB565(RGB16)</td>
<td>一个像素16位，无A通道（一个像素消耗2字节）</td>
</tr>
</tbody></table>
<h4 id="2-2-压缩格式"><a href="#2-2-压缩格式" class="headerlink" title="2.2 压缩格式"></a><strong>2.2 压缩格式</strong></h4><h5 id="DXTC"><a href="#DXTC" class="headerlink" title="DXTC"></a><strong>DXTC</strong></h5><p>DXTC纹理压缩格式来源于S3公司提出的S3TC算法，基本思想是把4x4的像素块压缩成一个64或128位的数据块，优点是创建了一个固定大小且独立的编码片段，没有共享查找表或其他依赖关系，简化了解码过程。</p>
<ul>
<li><p>DXT1(BC1)</p>
<ul>
<li>每个块有2个16位RGB颜色值（RGB565），代表了此4x4像素块中颜色极端值，然后通过线性插值计算出两个中间颜色值，16个2位索引值则表示了每一个像素的颜色值索引；</li>
<li>(索引2个极端颜色+2个计算中间颜色)</li>
<li>适用于不具有透明度信息的贴图（或一位（0、1）透明信息-完全不透明或完全透明）<ul>
<li>有透明信息时，只计算一个中间颜色值，剩下的一个索引表示透明信息</li>
</ul>
</li>
<li>参照RGB24的压缩率-64&#x2F;(24*16) &#x3D;1&#x2F;6 </li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824165255015.png" alt="image-20220824165255015"></li>
</ul>
</li>
<li><p>DXT2&#x2F;3(BC2)</p>
<ul>
<li>DXT2&#x2F;3与DXT1类似，表示颜色信息的64位数据块不变，另外附加了64位数据来表示每个像素的Alpha信息，整个数据块变为128位</li>
<li>每个像素占用8位，0-3表示透明信息，4-7表示颜色信息</li>
<li>压缩率（RGBA32）：128&#x2F;(32*16) &#x3D; 1&#x2F;4</li>
</ul>
</li>
<li><p>DXT4&#x2F;5(BC3)</p>
<ul>
<li>DXT4&#x2F;5与DXT2&#x2F;3的差异在于其Alpha信息使用了线性插值，表示颜色信息的64位数据块依然不变，Alpha信息则由2个8位Alpha极端值和16个3位索引值组成。</li>
<li>压缩率（RGBA32）：128&#x2F;(32*16) &#x3D; 1&#x2F;4</li>
</ul>
</li>
<li><p>在Unity内贴图类型选为法线后会采用DXTnm压缩格式（居于DXT5），该格式会把法线贴图R通道存入A通道，然后RB通道清除为1，这样可以将法线XY信息分别存入到RGB&#x2F;A中分别进行压缩，以获得更高的精度，然后再根据XY构建出Z通道数据。</p>
</li>
</ul>
<h5 id="ATI1-2"><a href="#ATI1-2" class="headerlink" title="ATI1&#x2F;2"></a><strong>ATI1&#x2F;2</strong></h5><ul>
<li><p>ATI1</p>
<ul>
<li>为ATI公司开发的纹理压缩格式，也被称为BC4，其每个数据块存储单个颜色的数据通道，以与DXT5中的Alpha数据相同的方式进行编码，常用于存储高度图，光滑度贴图，效果与原始图像基本无差异；</li>
<li>压缩率（R8）：64&#x2F;(8*16)&#x3D;1&#x2F;2</li>
</ul>
</li>
<li><p>ATI2</p>
<ul>
<li>也被称为BC5，每个块中存储两个颜色通道的数据，同上以与DX5中Alpha数据相同的方式进行编码，相当于存储了两个BC4块。</li>
<li>压缩率（RG16）：128&#x2F;(8*16)&#x3D;1&#x2F;2</li>
</ul>
</li>
<li><p>如果是在将法线存储在XY双通道中采用BC5格式压缩，由于每个通道都有自己的索引，因此法线贴图XY信息可以比在BC1中保留更多的保真度，缺点是需要使用两倍内存，也需要更多带宽才能将纹理传递到着色器中；</p>
</li>
</ul>
<h5 id="BC6-7"><a href="#BC6-7" class="headerlink" title="BC6&#x2F;7"></a><strong>BC6&#x2F;7</strong></h5><p>仅在D3D11级图形硬件中受支持，他们每个块占用16字节，BC7针对8为RGB或RGBA数据，BC6针对RGB半精度浮点数据，因此BC6是唯一一个可以原生存储HDR的BC格式</p>
<ul>
<li>BC6是专门针对HDR图像设计的压缩算法，压缩比为1&#x2F;6</li>
<li>BC7是专门针对LDR图像设计的压缩算法，压缩比为1&#x2F;3<ul>
<li>该格式用于高质量的RGBA压缩，可以显著减少由于压缩法线带来的错误效果</li>
</ul>
</li>
</ul>
<h5 id="ETC"><a href="#ETC" class="headerlink" title="ETC"></a><strong>ETC</strong></h5><p>DirectX选择了DXTC作为标准压缩格式，对于Opengl则选择了爱立信研发的ETC格式，几乎所有安卓设备都可以支持ETC压缩，所以其在移动平台上被广泛使用。</p>
<p>ETC与DXTC具有相同的特点，将4x4的像素单元压缩成64位数据块，并将像素单元水平或竖直朝向分为两个区块，每个像素颜色等于基础颜色加上索引指向的亮度范围。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824183152849.png" alt="image-20220824183152849"></p>
<ul>
<li><p>ETC1</p>
<ul>
<li>每个数据块分区中的4位亮度索引信息会从16个内置亮度表中获取当前像素单元对应的亮度表，每个像素的2位像素索引值可以从亮度表的四个值中选取对应的亮度补充值</li>
<li>压缩率（RGB24）：64&#x2F;(16*24)&#x3D;1&#x2F;6</li>
</ul>
</li>
<li><p>ETC2</p>
<ul>
<li>ETC1的扩展，支持了Alpha通道的压缩，硬件要求Opengl ES3.0和Opengl4.3以上</li>
</ul>
</li>
<li><p>差别</p>
<ul>
<li>ETC1要求长宽为2的幂次的贴图，适用于所有安卓设备，压缩率比较高，但不适合带Alpha通道的贴图</li>
<li>ETC2要求长宽能被4整除的贴图，设备有硬件要求，支持Alpha通道压缩，内存占用大于ETC1</li>
</ul>
</li>
</ul>
<h5 id="ASTC"><a href="#ASTC" class="headerlink" title="ASTC"></a><strong>ASTC</strong></h5><p>ASTC是ARM和AMD联合开发的纹理压缩格式，各项指标都不错，</p>
<ul>
<li>优点<ul>
<li>可根据不同图片选择不同压缩率的算法</li>
<li>图片不需要为2的幂次</li>
<li>同时支持LDR和HDR</li>
</ul>
</li>
<li>缺点<ul>
<li>兼容性不够完善</li>
<li>解码时间较长</li>
</ul>
</li>
</ul>
<p>ASTC也是基于块的压缩算法，与BC7类似，数据块大小固定为128位，不同的是块中像素数量可变，从4x4到12x12像素都有。</p>
<p>每个数据块中存储了两个插值端点，但不一定存储的是颜色信息，也可能是Layer信息，这样可以用来对Normal或Alpha进行更好的压缩</p>
<p>对于块中每个像素，存储对应插值端点的权重，存储的权重数量可以少于纹素数量，可通过插值得到每一个纹素的权重值，然后再进行颜色的计算。</p>
<ul>
<li>数据块构成<ul>
<li>11位：权重、高度信息、特殊块标识</li>
<li>2位：Part数量</li>
<li>4位：16种插值端点模式（如LDR&#x2F;HDR，RGB&#x2F;RGBA）</li>
<li>111位：插值端点信息，纹素权重值，配置信息</li>
</ul>
</li>
</ul>
<h5 id="PVRTC"><a href="#PVRTC" class="headerlink" title="PVRTC"></a><strong>PVRTC</strong></h5><p>由Imagination公司专为PowerVR显卡设计，仅支持Iphone，Ipad和部分安卓机。</p>
<p>不同于DXTC和ETC这类基于块的算法，PVRTC将图像分为了低频和高频信号，低频信号由两张低分辨率图像AB组成，高频信号则是低精度的调制图像，记录了每个像素混合的权重，解码时AB图像经过双线性插值放大，然后根据调制图像的权重进行混合</p>
<ul>
<li>PVRTC<ul>
<li>PVRTC 2-bpp(bit per pixel)</li>
<li>PVRTC 4-bpp把一个4x4的像素单元压缩成一个64位数据块，每一个块中存储一个32位（每个像素2位）的调制数据，一个1位的调制标识，15位(RGB555&#x2F;RGBA4443)的颜色A，1位颜色A不透明标识（决定按照RGB还是RGBA进行存储），14位(RGB554&#x2F;RGBA4433)颜色B，1位颜色B不透明标识</li>
<li>压缩率（RGB）：64&#x2F;(24*16) &#x3D; 1&#x2F;6</li>
<li>压缩率（RGBA）：64&#x2F;(32*16) &#x3D; 1&#x2F;8</li>
</ul>
</li>
</ul>
<h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a><strong>2.3 总结</strong></h4><ul>
<li>画质比较<ul>
<li>RGBA&gt;ASTC 4x4&gt;ASTC6x6&gt;ETC2 ≈ETC1</li>
</ul>
</li>
<li>压缩比</li>
</ul>
<table>
<thead>
<tr>
<th align="center">压缩格式</th>
<th align="center">压缩率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DXT1</td>
<td align="center">1&#x2F;6</td>
</tr>
<tr>
<td align="center">DXT2&#x2F;3</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">DXT4&#x2F;5</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">ATI1</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">ATI2</td>
<td align="center">1&#x2F;4</td>
</tr>
<tr>
<td align="center">BC6</td>
<td align="center">1&#x2F;6</td>
</tr>
<tr>
<td align="center">BC7</td>
<td align="center">1&#x2F;3</td>
</tr>
<tr>
<td align="center">ASTC</td>
<td align="center">1&#x2F;4~1&#x2F;35.95</td>
</tr>
<tr>
<td align="center">PVRTC</td>
<td align="center">1&#x2F;6</td>
</tr>
</tbody></table>
<h3 id="3-实际应用中的选择"><a href="#3-实际应用中的选择" class="headerlink" title="3. 实际应用中的选择"></a><strong>3. 实际应用中的选择</strong></h3><ul>
<li>PC<ul>
<li>低质量使用DXT1，不支持A通道，使用DXT5格式支持A通道</li>
<li>高质量使用BC7，支持A通道</li>
</ul>
</li>
<li>安卓<ul>
<li>低质量使用ETC1，不支持A通道</li>
<li>低质量使用ETC2，支持A通道（Opengl ES3.0&#x2F;Opengl 4.3以上版本）</li>
<li>高质量使用ASTC（Android5.0&#x2F;Opengl ES3.1以上版本）</li>
</ul>
</li>
<li>IOS<ul>
<li>高质量使用ASTC（Iphone6以上版本）</li>
<li>低质量使用PVRTC2（支持Iphone6以下版本）</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>结合今天课程，针对ASTC与ETC2这两个格式进行打包测试，分析内存占用占比。</p>
<p>3.7的作业正好也差不多。。。放个链接</p>
<p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/Lyp-tjMR_/#%E4%BD%9C%E4%B8%9A">https://xzyw7.github.io/post/Lyp-tjMR_/#%E4%BD%9C%E4%B8%9A</a></p>
<p>(ASTC6x6&amp;ETC2)最后包体的体积是非常接近的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824023612935.png" alt="image-20220824023612935"></p>
<p>ASCT</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024417255.png" alt="image-20220824024417255"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024516591.png" alt="image-20220824024516591"></p>
<p>ETC2</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024425619.png" alt="image-20220824024425619"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824024506074.png" alt="image-20220824024506074"></p>
<p>就包体而言ASCT6x6是更大一些的，但是最后的内存占用却小了一些。</p>
<p>（帧率的差别应该主要来源于CPU的性能差别，ASTC的CPU性能占用稍高，也就是解码的消耗）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824025009019.png" alt="image-20220824025009019"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824025016354.png" alt="image-20220824025016354"></p>
<p>再用单张贴图的压缩结果来看看各种压缩格式的效果（ASTC压缩实在是有点猛，相比也会占用更多CPU时间）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021751226.png" alt="image-20220824021751226"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021823244.png" alt="image-20220824021823244"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021805123.png" alt="image-20220824021805123"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021840952.png" alt="image-20220824021840952"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824021857439.png" alt="image-20220824021857439"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Av411K7bt">https://www.bilibili.com/video/BV1Av411K7bt</a></p>
<p>【技术美术百人计划】图形 3.6 纹理压缩——包体瘦身术</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/24/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.6%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9/" data-id="cmfe9guj40041ewuhfevy60i6" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.7.2command buffer及urp概述" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/08/24/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7.2command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/">【笔记】【百人计划】图形3.7.2 command buffer及urp概述</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/24/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7.2command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2022-08-24T08:58:51.000Z" itemprop="datePublished">2022-08-24</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="一、Command-Buffer"><a href="#一、Command-Buffer" class="headerlink" title="一、Command Buffer"></a>一、Command Buffer</h2><p>Command Buffer：用来存储渲染命令的缓冲区</p>
<ul>
<li>保存渲染命令列表<ul>
<li>如set render target, draw mesh等等，可以设置在摄像机渲染期间的不同时间点执行</li>
</ul>
</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212010010.png" alt="image-20221004212010010"></p>
<ul>
<li>如图使用Command Buffer获取渲染这三个物体之前的背景，输出到RT，渲染物体时采样RT进行处理，获得各种效果</li>
<li>也可以在选择物体时使用多pass进行外扩描边(ExcuteInEditorMode的HeaderAttribute)</li>
</ul>
<h4 id="从Opengl指令分析Command-Buffer原理"><a href="#从Opengl指令分析Command-Buffer原理" class="headerlink" title="从Opengl指令分析Command Buffer原理"></a>从Opengl指令分析Command Buffer原理</h4><p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212333393.png" alt="image-20221004212333393"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212443470.png" alt="image-20221004212443470"></p>
<p>Unity里FrameDebugger打开的一大堆指令，也是Command Buffer</p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212836046.png" alt="image-20221004212836046"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004212938333.png" alt="image-20221004212938333"></p>
<h4 id="从自定义RenderPipeline分析（ScriptableRenderContext与Command-Buffer）"><a href="#从自定义RenderPipeline分析（ScriptableRenderContext与Command-Buffer）" class="headerlink" title="从自定义RenderPipeline分析（ScriptableRenderContext与Command Buffer）"></a>从自定义RenderPipeline分析（ScriptableRenderContext与Command Buffer）</h4><p>这一段也许可以自己去看看catlike coding的SRP部分</p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004215426213.png" alt="image-20221004215426213"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004215744770.png" alt="image-20221004215744770"></p>
<h2 id="二、Command-Buffer常用函数"><a href="#二、Command-Buffer常用函数" class="headerlink" title="二、Command Buffer常用函数"></a>二、Command Buffer常用函数</h2><p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004215945624.png" alt="image-20221004215945624"></p>
<ul>
<li>RenderTarget</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220319374.png" alt="image-20221004220319374"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220610753.png" alt="image-20221004220610753"></p>
<ul>
<li>RenderTexture<ul>
<li>申请临时的RT必须手动Release</li>
<li>Release与Destroy的区别<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41251356">https://zhuanlan.zhihu.com/p/41251356</a></li>
<li>Release释放显存不释放内存</li>
<li>Destroy会把Object销毁的同时连带显存释放掉，因此频繁使用Destroy会加重申请内存的负担</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220340735.png" alt="image-20221004220340735"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220434194.png" alt="image-20221004220434194"></p>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004220529916.png" alt="image-20221004220529916"></p>
<ul>
<li>DrawMesh</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004223532948.png" alt="image-20221004223532948"></p>
<h2 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h2><ul>
<li>URP</li>
<li>RenderFeature与Command Buffer原理分析</li>
<li>Volume组件</li>
</ul>
<h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><ul>
<li>Scene窗口CameraColorTexture丢失[MSAA导致的bug ResolveAA]</li>
<li>深度缓冲和模板缓冲[16bit和24&#x2F;32bit]</li>
<li>RT精度格式问题</li>
<li>加速优化</li>
</ul>
<p><img src="/%E5%9B%BE%E5%BD%A23.7.2%20command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/image-20221004225932580.png" alt="image-20221004225932580"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="完成洛基中的传送门效果"><a href="#完成洛基中的传送门效果" class="headerlink" title="完成洛基中的传送门效果"></a>完成洛基中的传送门效果</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13F411e7Ai">https://www.bilibili.com/video/BV13F411e7Ai</a></p>
<p>【技术美术百人计划】图形 3.72 command buffer及urp概述</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/24/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7.2command%20buffer%E5%8F%8Aurp%E6%A6%82%E8%BF%B0/" data-id="cmfe9guj5004bewuhftuic3zr" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.7移动端TB(D)R架构基础" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/08/24/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7%E7%A7%BB%E5%8A%A8%E7%AB%AFTB(D)R%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/">【笔记】【百人计划】图形3.7 移动端TB(D)R架构基础</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/24/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7%E7%A7%BB%E5%8A%A8%E7%AB%AFTB(D)R%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-08-24T07:58:51.000Z" itemprop="datePublished">2022-08-24</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="一、当前移动端GPU概况"><a href="#一、当前移动端GPU概况" class="headerlink" title="一、当前移动端GPU概况"></a><strong>一、当前移动端GPU概况</strong></h3><h4 id="1-1-移动端和桌面端功耗对比"><a href="#1-1-移动端和桌面端功耗对比" class="headerlink" title="1.1 移动端和桌面端功耗对比"></a><strong>1.1 移动端和桌面端功耗对比</strong></h4><p>对于移动端我们通常用soc芯片名称来代指CPU</p>
<p>移动端GPU生产厂商主要是高通adreno，Mali和PowerVR</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822235329719.png" alt="image-20220822235329719"></p>
<h4 id="1-2-移动端和桌面端带宽对比"><a href="#1-2-移动端和桌面端带宽对比" class="headerlink" title="1.2 移动端和桌面端带宽对比"></a><strong>1.2 移动端和桌面端带宽对比</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822235406315.png" alt="image-20220822235406315"></p>
<h3 id="二、名词解释"><a href="#二、名词解释" class="headerlink" title="二、名词解释"></a><strong>二、名词解释</strong></h3><ul>
<li>System on Chip（Soc）<ul>
<li>Soc是把CPU、GPU、内存、通信基带、GPS模块等等整合在一起的芯片的称呼。常见的有A系Soc（苹果），骁龙Soc（高通），麒麟Soc（华为），联发科Soc，猎户座Soc（三星），2020年苹果推出M系Soc，暂用于Mac，这说明手机、笔记本、PC的通用芯片已经出现了。</li>
</ul>
</li>
<li>System Memory<ul>
<li>Soc中GPU和CPU共用一块片内LPDDR物理内存，就是常说的手机内存，也叫System Memory，大概几个G。</li>
<li>此外CPU和GPU还分别有自己的高速SRAM的Cache，也叫On-chip Memory，一般几百k-几M。不同距离的内存访问存在不同时间消耗，距离越近消耗越低，读取System Memory的时间消耗大概是On-chip Memory的几倍到几十倍</li>
<li>（soc上gpu和cpu共享一个（虚拟）内存地址空间）</li>
</ul>
</li>
<li>On-Chip Memory<ul>
<li>在TB(D)R架构下会存储Tile的颜色、深度和模板缓冲，读写修改都非常快。</li>
</ul>
</li>
<li>Stall停滞<ul>
<li>当一个GPU核心的两次计算结果之间有依赖关系而必须串行时，等待的过程便是Stall。</li>
</ul>
</li>
<li>FillRate<ul>
<li>像素填充率 &#x3D; ROP运行的时钟频率 * ROP的个数 * 每个时钟ROP可以处理的像素个数</li>
</ul>
</li>
<li>TB(D)R<ul>
<li>Tile-Based  (Deferred) Rendering</li>
<li>是目前主流的移动GPU渲染架构，对应一般PC上的GPU渲染架构则是IMR（Immediate Mode Rendering）</li>
<li>指屏幕被分块（16*16或32*32像素）渲染</li>
<li>TBR：VS - Defer - Rasterize - PS</li>
<li>TBDR：VS - Defer - Rasterize - Defer - PS</li>
<li>Defer字面是延迟，但从渲染数据的角度来看，Defer就是“阻塞+批处理”GPU的“一帧”的多个数据，然后一起处理</li>
</ul>
</li>
</ul>
<h3 id="三、立即渲染IMR"><a href="#三、立即渲染IMR" class="headerlink" title="三、立即渲染IMR"></a><strong>三、立即渲染IMR</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> draw <span class="keyword">in</span> renderPass:</span><br><span class="line">    <span class="keyword">for</span> primitive <span class="keyword">in</span> draw:</span><br><span class="line">        <span class="keyword">for</span> vertex <span class="keyword">in</span> primitive:</span><br><span class="line">            execute_vertex_shader(vertex)</span><br><span class="line">        <span class="keyword">if</span> primitive <span class="keyword">not</span> culled:</span><br><span class="line">            <span class="keyword">for</span> fragment <span class="keyword">in</span> primitive:</span><br><span class="line">                execute_fragment_shader(fragment)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823000924957.png" alt="image-20220823000924957"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001016993.png" alt="image-20220823001016993"></p>
<h3 id="四、基于块元的渲染TB-D-R"><a href="#四、基于块元的渲染TB-D-R" class="headerlink" title="四、基于块元的渲染TB(D)R"></a><strong>四、基于块元的渲染TB(D)R</strong></h3><p>TB(D)R宏观上分为2阶段</p>
<ol>
<li>第一阶段执行所有与几何相关的处理，并生成Primitive List，并且确定每个tile上面有哪些primitive</li>
<li>第二阶段将逐块执行光栅化及其后续处理，并在完成后将Frame Buffer从Tile Buffer写回到System Memory中。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pass one</span></span><br><span class="line"><span class="keyword">for</span> draw <span class="keyword">in</span> renderPass:</span><br><span class="line">    <span class="keyword">for</span> primitive <span class="keyword">in</span> draw:</span><br><span class="line">        <span class="keyword">for</span> vertex <span class="keyword">in</span> primitive:</span><br><span class="line">            execute_vertex_shader(vertex)</span><br><span class="line">        <span class="keyword">if</span> primitive <span class="keyword">not</span> culled:</span><br><span class="line">            append_tile_list(primitive)</span><br><span class="line"><span class="comment"># Pass two</span></span><br><span class="line"><span class="keyword">for</span> tile <span class="keyword">in</span> renderPass:</span><br><span class="line">    <span class="keyword">for</span> primitive <span class="keyword">in</span> tile:</span><br><span class="line">        <span class="keyword">for</span> fragment <span class="keyword">in</span> primitive:</span><br><span class="line">            execute_fragment_shader(fragment)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001450220.png" alt="image-20220823001450220"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001533374.png" alt="image-20220823001533374"></p>
<h3 id="五、TB-D-R的硬件渲染顺序"><a href="#五、TB-D-R的硬件渲染顺序" class="headerlink" title="五、TB(D)R的硬件渲染顺序"></a><strong>五、TB(D)R的硬件渲染顺序</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823001818885.png" alt="image-20220823001818885"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>TBR的核心目的是降低带宽，减少功耗，但渲染帧率上并不比IMR块</strong></p>
<ul>
<li>优点<ul>
<li>TBR给消除Overdraw提供了机会，PowerVR用了HSR技术，Mali用了Forward Pixel Killing技术，目标一样，就是要最大限度减少被遮挡Pixel的texturing和shading。</li>
<li>TBR主要是cached friendly，在cache里读写的速度要比全局内存的速度快得多，以降低render rate的代价，降低带宽，省电</li>
</ul>
</li>
<li>缺点<ul>
<li>Binning过程是在vertex阶段之后，将输出的几何数据写入到DDR，然后才被fs读取。几何数据过多的管线，容易在此处有性能瓶颈。</li>
<li>如果某些三角形叠加在数个tile上，需要绘制数次。意味着总渲染时间将高于即时渲染模式。</li>
</ul>
</li>
</ul>
<h3 id="六、Binning过程"><a href="#六、Binning过程" class="headerlink" title="六、Binning过程"></a><strong>六、Binning过程</strong></h3><p>Binning过程（类似四叉树）&#x2F;第一个Defer</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823002346662.png" alt="image-20220823002346662"></p>
<p>确定哪些块元渲染哪些图元</p>
<h3 id="七、不同GPU的Early-Depth-Test"><a href="#七、不同GPU的Early-Depth-Test" class="headerlink" title="七、不同GPU的Early-Depth-Test"></a><strong>七、不同GPU的Early-Depth-Test</strong></h3><p>第二个Defer</p>
<ul>
<li><p>Android</p>
<ul>
<li>Qualcomm Adreno采用外置模块LRZ。在正常渲染管线前，多执行一次vs生成低精度depth texture，提前剔除不可见的triangles。直接用硬件做occlusion culling，功能类似软光栅遮挡剔除&#x2F;pre-Z</li>
<li>Arm Mali的FPK（Forward Pixel Killing）<ul>
<li>发生在Early-Z之后</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823002835382.png" alt="image-20220823002835382"></li>
</ul>
</li>
</ul>
</li>
<li><p>IOS</p>
<ul>
<li><p>PowerVR的HSR</p>
</li>
<li><p>TBDR的HSR实现</p>
<ul>
<li>HSR&#x3D;Hidden Surface Removal</li>
<li>对每个被投影光束交接的对象进行排序处理（使用分块减少数据集大小）</li>
<li>只有最近的不透明和最近的透明对象需要被渲染</li>
<li>余下的片元被剔除</li>
</ul>
</li>
<li><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823003102289.png" alt="image-20220823003102289"></p>
</li>
</ul>
</li>
</ul>
<h3 id="八、优化建议"><a href="#八、优化建议" class="headerlink" title="八、优化建议"></a><strong>八、优化建议</strong></h3><ul>
<li>不使用FrameBuffer的时候clear或者discard<ul>
<li>主要是清空积存在tile buffer上的中间数据，所以在unity里面对render texture的使用也特别说明了一下，当不再使用这个rt之前，调用一次Discard。在Opengl ES上善用glClear，glInvalidateFrameBuffer避免不必要的Resolve（Resolve就是tile buffer刷新到system memory）行为</li>
</ul>
</li>
<li>不要在一帧里面频繁切换FrameBuffer的绑定<ul>
<li>本质上就是减少tile buffer和system memory之间的stall操作</li>
</ul>
</li>
<li>对于移动平台，建议使用alpha blend而非alpha test<ul>
<li>在实际使用中，你应该分析并比较alpha test和alpha blend的表现，因为这取决于具体内容，通常在移动平台上应避免使用alpha混合来实现透明。需要进行alpha blend时，尝试缩小混合区域的覆盖范围。</li>
</ul>
</li>
<li>手机上必须要做Alpha Test，先做一遍preZ</li>
<li>图片尽量压缩，例如：ASTC，ETC2</li>
<li>图片尽量走mipmap</li>
<li>尽量使用从Vertex shader传来的Varying变量UV值采样贴图（连续的），不要在FragmentShader里动态计算贴图的UV值（非连续的），否则CacheMiss</li>
<li>在延迟渲染尽量利用Tile Buffer</li>
<li>如果你在unity里面调整ProjectSetting&#x2F;Quality&#x2F;Rendering&#x2F;Texture Quality不同的设置，或者不同分辨率下，帧率有很多变化，那么多半是带宽出问题。</li>
<li>MSAA在TBDR下反而是非常快速的。</li>
<li>少在fs中使用discard，调用gl_FragDepth从而打断Early-DT(HLSL中为Clip，GLSL中为discard)</li>
<li>在shader里面浮点数精度，有目的区分使用float，half；<ul>
<li>带宽用量减少</li>
<li>GPU中使用的周期数减少，因为着色器编译器可以优化你的代码以提高并行化程度。</li>
<li>要求的统一变量寄存器数量减少，这反过来又降低了寄存器数量溢出风险</li>
</ul>
</li>
<li>在移动端TB(D)R架构中，顶点处理部分容易成为瓶颈，避免使用曲面细分shader，置换贴图等负操作，提倡使用模型lod，本质上减少FrameData的压力，Unity中尽早在应用阶段借助umbra遮挡剔除。</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><p>结合今天的课程，将最近做的demo继续安卓平台<strong>打包</strong>，<strong>对比</strong>使用课上的优化点前后的性能变化。</p>
<p>这是第一次接触安卓平台的打包与性能分析。。关于性能分析使用了Unity的UPR工具。由于没有什么比较完整的demo，之前所有作业都是塞在一个项目里做的，就直接使用这个场景了，虽然感觉也很难触碰到性能瓶颈什么的。而且能够针对上面优化建议处理的点也不太多。于是选择了最直接的图片纹理压缩的部分（正好下一章节就会讲纹理压缩），应该也算非常适合了。</p>
<p>ASTC和ETC2两种压缩格式都非常接近</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824014740272.png" alt="image-20220824014740272"></p>
<p>而当我手动地取消所有纹理的压缩，改为8位浮点精度储存后，发现对性能的影响比想象中大得多。。。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824014834325.png" alt="image-20220824014834325"></p>
<p>首先是apk文件的大小就增大了一些。其次是最明显的纹理资源峰值这一项，UPR还贴心地提供了说明和优化建议。而且，这里Mipmap甚至已经关掉了。（其实这里做法是相反的，应该关闭压缩开启mip，这样这两个功能在纹理和渲染效率上的作用才是协同的）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824015319329.png" alt="image-20220824015319329"></p>
<p>那么在手机内存占用上，也发生了相应的变化</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020406052.png" alt="image-20220824020406052"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020414939.png" alt="image-20220824020414939"></p>
<ul>
<li><p>ReservedTotal峰值</p>
<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020439183.png" alt="image-20220824020439183"></li>
</ul>
</li>
<li><p>ReservedGFX峰值</p>
<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824020513219.png" alt="image-20220824020513219"></li>
</ul>
</li>
</ul>
<p>其次就是帧率也发生了下降。这当然也是由于纹理资源数据变大，计算的速度也就下降了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824015213541.png" alt="image-20220824015213541"></p>
<p>性能分析工具本身还有很多需要去研究的地方，当然这也需要项目内容的支撑。。。鉴于现在也没有什么合适的内容，这里也只能到此为止了，算是一次小小的尝试。当打包出来的项目在手机上成功渲染出画面的时候，还是非常激动的。。。</p>
<p>（此外，曲面细分与几何着色器生成的草地没能在手机上绘制出来，想必也是手机平台不支持这两个着色器的缘故了。）</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Bb4y167zU">https://www.bilibili.com/video/BV1Bb4y167zU</a></p>
<p>【技术美术百人计划】图形 3.7 移动端TB(D)R架构基础</p>
<p>[2] <a target="_blank" rel="noopener" href="https://blog.imaginationtech.com/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/">https://blog.imaginationtech.com/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://upr.unity.cn/instructions/desktop">https://upr.unity.cn/instructions/desktop</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/24/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.7%E7%A7%BB%E5%8A%A8%E7%AB%AFTB(D)R%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" data-id="cmfe9guj40047ewuh18j885hu" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.5Early-z和Z-prepass" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/08/23/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.5Early-z%E5%92%8CZ-prepass/">【笔记】【百人计划】图形3.5 Early-z和Z-prepass(preZ)</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/23/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.5Early-z%E5%92%8CZ-prepass/" class="article-date">
  <time datetime="2022-08-23T13:16:58.000Z" itemprop="datePublished">2022-08-23</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="一、深度测试"><a href="#一、深度测试" class="headerlink" title="一、深度测试"></a><strong>一、深度测试</strong></h3><ul>
<li><p>fs-Alpha Test-Stencil Test-&#x3D;&#x3D;Depth Test&#x3D;&#x3D;</p>
</li>
<li><p>解决物体可见遮挡性的问题</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822155007188.png" alt="image-20220822155007188" style="zoom:50%;" />

<p>因为测试阶段发生在fs之后，片元即便被丢弃，已经经过了fs中大量的无用的计算。</p>
<h3 id="二、提前深度测试Early-Z"><a href="#二、提前深度测试Early-Z" class="headerlink" title="二、提前深度测试Early-Z"></a><strong>二、提前深度测试Early-Z</strong></h3><ul>
<li>解决过多不必要的片元计算问题</li>
<li>光栅化-&#x3D;&#x3D;EarlyZ&#x3D;&#x3D;-fs-Alpha Test-Stencil Test-&#x3D;&#x3D;Depth Test&#x3D;&#x3D;</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822155402937.png" alt="image-20220822155402937" style="zoom: 67%;" />

<ul>
<li>EarlyZ也可以基于模板测试在着色前丢弃片元</li>
<li><strong>EarlyZ剔除的最小单位不是1像素，而是像素块（2x2）</strong></li>
</ul>
<h4 id="2-1-EarlyZ失效"><a href="#2-1-EarlyZ失效" class="headerlink" title="2.1 EarlyZ失效"></a><strong>2.1 EarlyZ失效</strong></h4><p>通常在EarlyZ阶段不仅会进行深度测试，还会写入深度</p>
<ol>
<li>开启ALpha Test或Clip&#x2F;discard等手动丢弃片元操作<ul>
<li>如果手动丢弃片元，导致如果前面的片元丢弃了，深度仍然存在，后续的像素也会被丢弃。</li>
</ul>
</li>
<li>手动修改GPU插值得到的深度</li>
<li>开启Alpha Blend<ul>
<li>开启Alpha Blend的物体一般不会开启深度写入ZWrite off</li>
</ul>
</li>
<li>关闭深度测试Depth Test</li>
<li>开启Multi-Sampling：多重采样会影响周边像素，而EarlyZ无法得知周边像素是否被裁剪，无法提前剔除</li>
<li>以及其他任何导致需要混合后面颜色的操作</li>
</ol>
<p>此外，Early-Z技术会导致**深度数据冲突（depth data hazard）**的问题</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1617944-20190906001537033-642734220.png" alt="img" style="zoom:50%;" />

<p>避免深度数据冲突的方法之一是在写入深度值之前，再次与frame buffer的值进行对比：</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1617944-20190906001545523-562795391.png.png" alt="1617944-20190906001545523-562795391.png" style="zoom: 67%;" />

<h4 id="2-2-高效利用EarlyZ"><a href="#2-2-高效利用EarlyZ" class="headerlink" title="2.2 高效利用EarlyZ"></a><strong>2.2 高效利用EarlyZ</strong></h4><p>将不透明物体由近向远渲染，EarlyZ的优化效果最好</p>
<ul>
<li>CPU进行深度排序</li>
<li>场景复杂时，排序消耗增大。</li>
<li>严格按照从近到远渲染，不能同时搭配合批优化手段</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822155921813.png" alt="image-20220822155921813" style="zoom: 67%;" />



<h3 id="三、使用Z-Prepass"><a href="#三、使用Z-Prepass" class="headerlink" title="三、使用Z-Prepass"></a><strong>三、使用Z-Prepass</strong></h3><ol>
<li>在第一个pass即Z-Prepass中只写入深度，不计算输出任何颜色<ul>
<li>自动计算了最小深度的zbuffer，无需cpu排序</li>
<li>EarlyZ阶段也可以提升一点效率，虽然本来就没什么计算</li>
</ul>
</li>
<li>第二个pass关闭深度写入，并且将深度比较函数设置为相等</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Tags&#123;<span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span>&#125;</span><br><span class="line">    <span class="comment">//PreZ</span></span><br><span class="line">    Pass &#123;</span><br><span class="line">        ZWrite On 	<span class="comment">// 开启深度写入</span></span><br><span class="line">        ColorMask <span class="number">0</span> <span class="comment">// 关闭颜色输出</span></span><br><span class="line">        CGROGRAM</span><br><span class="line">        ...<span class="comment">//省略顶点变换部分</span></span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常地计算输出颜色</span></span><br><span class="line">    Pass &#123;</span><br><span class="line">        ZWrite Off	<span class="comment">// 关闭深度写入</span></span><br><span class="line">        ZTest Equal <span class="comment">// 深度相等通过</span></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        ...</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、Z-Prepass带来的问题"><a href="#四、Z-Prepass带来的问题" class="headerlink" title="四、Z-Prepass带来的问题"></a><strong>四、Z-Prepass带来的问题</strong></h3><h4 id="4-1-动态批处理问题"><a href="#4-1-动态批处理问题" class="headerlink" title="4.1 动态批处理问题"></a><strong>4.1 动态批处理问题</strong></h4><p>多pass的shader无法进行动态批处理-增加drawcall</p>
<h5 id="解决方法：提前分离的PrePass"><a href="#解决方法：提前分离的PrePass" class="headerlink" title="解决方法：提前分离的PrePass"></a>解决方法：提前分离的PrePass</h5><p>仍然使用两个pass</p>
<ol>
<li>将原先第一个pass（Z-Prepass）单独分离出来为单独一个shader，并使用这个shader将整个场景的Opaque物体渲染一遍（写入深度）</li>
<li>原先材质只剩下原先的第二个Pass，仍关闭深度写入，并且深度比较函数设置为相等</li>
</ol>
<p>两个pass都能够分别被批处理</p>
<h4 id="4-2-Z-Prepass解决透明渲染"><a href="#4-2-Z-Prepass解决透明渲染" class="headerlink" title="4.2 Z-Prepass解决透明渲染"></a><strong>4.2 Z-Prepass解决透明渲染</strong></h4><p>不写入深度的透明渲染会出现深度穿插错误的问题</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161301143(1).png" alt="image-20220822161301143(1)"></p>
<p>（无法看到透明物体的背面）</p>
<ul>
<li>如果要用Z-Prepass同时渲染物体背面<ul>
<li>需要先渲染背面，剔除正面</li>
<li>在下一个pass渲染正面，剔除背面</li>
<li>可用于头发渲染</li>
</ul>
</li>
</ul>
<h4 id="4-3-其他问题"><a href="#4-3-其他问题" class="headerlink" title="4.3 其他问题"></a><strong>4.3 其他问题</strong></h4><h5 id="计算消耗"><a href="#计算消耗" class="headerlink" title="计算消耗"></a>计算消耗</h5><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161643680.png" alt="image-20220822161643680"></p>
<p>权衡片元计算复杂性&#x2F;overdraw与Z-Prepass的消耗，根据实际情况采用</p>
<h3 id="五、Early-Z与Z-Prepass的实例应用"><a href="#五、Early-Z与Z-Prepass的实例应用" class="headerlink" title="五、Early-Z与Z-Prepass的实例应用"></a><strong>五、Early-Z与Z-Prepass的实例应用</strong></h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jaffhan/p/7382106.html">https://www.cnblogs.com/jaffhan/p/7382106.html</a></p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161834083.png" alt="image-20220822161834083" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822161855886.png" alt="image-20220822161855886" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822162042913.png" style="zoom:67%;" />

<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><ol>
<li><strong>做下preZ的效果测试</strong></li>
</ol>
<p>左边的狮子是preZ，右边的狮子是普通的Alpha。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823202352241.png" alt="image-20220823202352241" style="zoom:80%;" />

<p>因为是透明渲染，所以自然而然会想到preZ的方法能否应用到之前深度测试的透视效果。</p>
<p>因为preZ记录了最前面的一个深度。透视，也就是说透明物体前面被遮挡住了，并且已经绘制了这个遮挡物体，那么就是遮挡物体的深度写入了深度缓冲。我们也就没有了被遮挡物体最近面的深度了。而之后要绘制出来，也要用Greater的判定方式，最终透明物体无法表现出自遮挡。</p>
<p>并且如果没有遮挡物的时候，物体自身最近片元就写入了深度。那么物体自己对自己形成遮挡，最后会发生没有遮挡时，绘制出了物体自身重叠部分。这种没有对透视效果做特殊处理，所以最后一次绘制物体自身的时候会覆盖（这是深度缓冲依然是物体自身最近距离，测试规则为LEqual）但是如果透视部分有特殊效果，那么正常的物体渲染可能会漏出这一部分。</p>
<p>总之结论就是，这个效果同一物体多pass的实现方法，无法用preZ来完成。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220823203258886(1).png" alt="image-20220823203258886(1)"></p>
<ol start="2">
<li><strong>总结earlyZ的限制</strong></li>
</ol>
<ul>
<li><p>EarlyZ-失效</p>
<ul>
<li>开启ALpha Test或Clip&#x2F;discard等手动丢弃片元操作<ul>
<li>如果手动丢弃片元，导致如果前面的片元丢弃了，深度仍然存在，后续的像素也会被丢弃。</li>
</ul>
</li>
<li>手动修改GPU插值得到的深度</li>
<li>开启Alpha Blend<ul>
<li>开启Alpha Blend的物体一般不会开启深度写入ZWrite off</li>
</ul>
</li>
<li>关闭深度测试Depth Test</li>
<li>开启Multi-Sampling：多重采样会影响周边像素，而EarlyZ无法得知周边像素是否被裁剪，无法提前剔除</li>
<li>以及其他任何导致需要混合后面颜色的操作</li>
</ul>
</li>
<li><p>导致深度数据冲突</p>
</li>
<li><p>为了最大利用EarlyZ按照从近到远顺序渲染，但CPU阶段排序耗时，且严格按照从近到远渲染不能同时搭配合批优化手段</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FK4y1u7iw">https://www.bilibili.com/video/BV1FK4y1u7iw</a></p>
<p>【技术美术百人计划】图形 3.5 Early-z和Z-prepass</p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aM4y1g75f">https://www.bilibili.com/video/BV1aM4y1g75f</a></p>
<p>【技术美术百人计划】图形 2.7.2 GPU硬件架构概述</p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/timlly/p/11471507.html">https://www.cnblogs.com/timlly/p/11471507.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/23/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.5Early-z%E5%92%8CZ-prepass/" data-id="cmfe9guj40044ewuh0u534u6n" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形3.4延迟渲染管线介绍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/08/23/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.4%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/">【笔记】【百人计划】图形3.4 延迟渲染管线介绍</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/23/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.4%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2022-08-23T02:52:59.000Z" itemprop="datePublished">2022-08-23</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="1-渲染路径"><a href="#1-渲染路径" class="headerlink" title="1.渲染路径"></a><strong>1.渲染路径</strong></h3><p>渲染路径（Rendering Path）：决定光照的实现方式。就是当前渲染目标使用光照的流程</p>
<h3 id="2-渲染方式"><a href="#2-渲染方式" class="headerlink" title="2.渲染方式"></a><strong>2.渲染方式</strong></h3><h4 id="2-1-前向渲染Forward-Rendering"><a href="#2-1-前向渲染Forward-Rendering" class="headerlink" title="2.1 前向渲染Forward Rendering"></a><strong>2.1 前向渲染Forward Rendering</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820011602900.png" alt="image-20220820011602900"></p>
<p>在渲染每一帧时，每个顶点、片元都要执行一次着色器代码。这时需要将所有的光照信息都传递到片元着色器中。虽然大部分情况下的光源都趋向于小型化，而其照亮的区域也不大，但即便是光源离这个像素所对应的世界空间中的位置很远，计算光照时还是会把所有光源考虑进去。复杂度是$O(mn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For each light:</span><br><span class="line">	For each object affected by the light:</span><br><span class="line">		framebuffer += object * light</span><br></pre></td></tr></table></figure>



<h4 id="2-2-延迟渲染Deferred-Rendering"><a href="#2-2-延迟渲染Deferred-Rendering" class="headerlink" title="2.2 延迟渲染Deferred Rendering"></a><strong>2.2 延迟渲染Deferred Rendering</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820012923949.png" alt="image-20220820012923949"></p>
<p>主要解决大量光照渲染的方案。先不要迭代三角形做光照计算，而是先找出能看到的所有像素，再去迭代光照。直接迭代三角形的话，由于大量三角形不可见，是浪费的。</p>
<p>如前向渲染下，近处光源和远处光源计算量相等。但延迟渲染下，近处的计算量会大于远处。因为远处的像素更少。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820012418691.png" alt="image-20220820012418691"></p>
<p>Gbuffer</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/v2-ad11e89e29c6ef9dc8e7c01a9203efa7_720w.jpg" alt="img"></p>
<p>流程：</p>
<p>分成两个pass</p>
<ul>
<li>几何处理pass<ul>
<li>首先将场景渲染一次，获取待渲染对象的各种几何信息，储存到G-buffer。并且开启深度测试，所以G-buffer只写入最近的片元的信息。</li>
</ul>
</li>
<li>光照处理pass<ul>
<li>遍历所有G-buffer的各种参数，执行光照计算。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For each object:</span><br><span class="line">	Render to multiple targets</span><br><span class="line">For each light:</span><br><span class="line">	Apply light as a <span class="number">2</span>D postprocess</span><br></pre></td></tr></table></figure>

<p>复杂度是$O(m+n)$ 。</p>
<h5 id="问题：如何渲染透明物体"><a href="#问题：如何渲染透明物体" class="headerlink" title="问题：如何渲染透明物体"></a><strong>问题：如何渲染透明物体</strong></h5><p>透明物体在前向渲染中，一般最后渲染，并且不写入深度。</p>
<p>所以在延迟渲染中，还是需要用前向渲染的方式，最后渲染透明物体</p>
<h4 id="2-3-不同渲染路径的优劣及特性"><a href="#2-3-不同渲染路径的优劣及特性" class="headerlink" title="2.3 不同渲染路径的优劣及特性"></a><strong>2.3 不同渲染路径的优劣及特性</strong></h4><h5 id="2-3-1-区别"><a href="#2-3-1-区别" class="headerlink" title="2.3.1 区别"></a><strong>2.3.1 区别</strong></h5><ul>
<li><p>后处理方式不同</p>
<ul>
<li>假设需要深度信息来进行后处理，前向渲染就需要单独渲染深度图</li>
</ul>
</li>
<li><p>着色计算不同</p>
<ul>
<li>延迟渲染只能计算一个光照模型，因为是统一在LightPass计算的</li>
</ul>
</li>
<li><p>抗锯齿方式不同</p>
</li>
</ul>
<h5 id="2-3-2-优劣"><a href="#2-3-2-优劣" class="headerlink" title="2.3.2 优劣"></a><strong>2.3.2 优劣</strong></h5><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>前向渲染</td>
<td>1. 支持半透明渲染</td>
<td>1. 光源数量对计算复杂度影响巨大</td>
</tr>
<tr>
<td></td>
<td>2. 支持使用多个光照pass</td>
<td>2. 访问深度等数据需要额外计算</td>
</tr>
<tr>
<td></td>
<td>3. 支持自定义光照计算方式</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>延迟渲染</td>
<td>1. 大量光照场景优势明显</td>
<td>1. 对MSAA支持不友好</td>
</tr>
<tr>
<td></td>
<td>2. 只渲染可见像素，节省计算量</td>
<td>2. 透明物体渲染存在问题</td>
</tr>
<tr>
<td></td>
<td>3. 对后处理支持良好</td>
<td>3. 占用大量的显存带宽</td>
</tr>
<tr>
<td></td>
<td>4. 用更少的shader</td>
<td></td>
</tr>
</tbody></table>
<h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a><strong>3.其他</strong></h4><h5 id="3-1-渲染路径的设置方式"><a href="#3-1-渲染路径的设置方式" class="headerlink" title="3.1 渲染路径的设置方式"></a><strong>3.1 渲染路径的设置方式</strong></h5><p>(2021.2版本以前，URP不支持延迟渲染)</p>
<ol>
<li>项目设置Tier Settings 的Rendering Path改为延迟渲染，并勾选Use Defaults</li>
<li>相机的Rendering Path使用延迟渲染</li>
</ol>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820014419975.png" alt="image-20220820014419975"></p>
<h5 id="3-2-移动端优化"><a href="#3-2-移动端优化" class="headerlink" title="3.2 移动端优化"></a><strong>3.2 移动端优化</strong></h5><ul>
<li>两个TBDR<ul>
<li>一个是SIGGRAPH2010提出，通过分块来降低带宽内存用量</li>
<li>一个是PowerVR基于手机GPU的TBR架构提出的，通过HSR减少overdraw</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220820014624273.png" alt="image-20220820014624273"></p>
<h5 id="3-3-其他渲染路径"><a href="#3-3-其他渲染路径" class="headerlink" title="3.3 其他渲染路径"></a><strong>3.3 其他渲染路径</strong></h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54694743">https://zhuanlan.zhihu.com/p/54694743</a></p>
<ul>
<li>延迟光照 Light Pre-Pass&#x2F;Deferred Lighting<ul>
<li>减少G-buffer占用的过多开销，支持多种光照模型</li>
</ul>
</li>
<li>Forward+ 即Tiled Forward Rendering，分块正向渲染<ul>
<li>减少带宽，支持多光源，强制需要一个preZ</li>
</ul>
</li>
<li>群组渲染Clustered Rendering<ul>
<li>带宽相对减少，多光源下效率提升</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li>总结延迟渲染管线的优缺点<ul>
<li>文内</li>
</ul>
</li>
<li>如何优化（移动端优化技术）<ul>
<li>3.7见</li>
</ul>
</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1244y1i7oV">https://www.bilibili.com/video/BV1244y1i7oV</a></p>
<p>【技术美术百人计划】图形 3.4  延迟渲染管线介绍</p>
<p>[2] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/08%20Deferred%20Shading/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/08%20Deferred%20Shading/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/23/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.4%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/" data-id="cmfe9guj3003uewuh7si6eouw" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/" rel="tag">百人计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>