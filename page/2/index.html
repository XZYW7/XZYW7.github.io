<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">XZYW7&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="XZYW7&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-TA/百人计划/图形3.1 深度与模板测试" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.1%20%E6%B7%B1%E5%BA%A6%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95/" class="article-date">
  <time datetime="2025-09-10T13:18:14.025Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形3-1-深度与模板测试"><a href="#图形3-1-深度与模板测试" class="headerlink" title="图形3.1 深度与模板测试"></a><strong>图形3.1 深度与模板测试</strong></h2><h3 id="一、模板测试Stencil-Test"><a href="#一、模板测试Stencil-Test" class="headerlink" title="一、模板测试Stencil Test"></a><strong>一、模板测试Stencil Test</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816182543699.png" alt="image-20220816182543699"></p>
<h4 id="1-1-渲染管线中的逐片元操作"><a href="#1-1-渲染管线中的逐片元操作" class="headerlink" title="1.1 渲染管线中的逐片元操作"></a><strong>1.1 渲染管线中的逐片元操作</strong></h4><ul>
<li>逐片元操作（可配置，不可编程）<ul>
<li>像素权限测试Pixel Ownership Test（屏幕窗口使用权限，如scene和game窗口区分）</li>
<li>裁剪测试Scissor Test（可以对渲染部分区域进行控制）</li>
<li>透明度测试Alpha Test（片元透明度大于阈值，则通过测试，否则剔除——只能实现不透明和全透明）</li>
<li>模板测试Stencil Test</li>
<li>深度测试Depth Test</li>
<li>混合Blending</li>
<li>Dithering</li>
<li>Logic Op</li>
</ul>
</li>
</ul>
<h4 id="1-2-模板测试理解"><a href="#1-2-模板测试理解" class="headerlink" title="1.2 模板测试理解"></a><strong>1.2 模板测试理解</strong></h4><ul>
<li>通过一定条件来判断是对该片元抛弃还是保留</li>
<li>模板缓冲区<ul>
<li>和颜色缓冲区、深度缓冲区类似</li>
<li>为屏幕上每个像素点保存一个uint8</li>
<li>可以用这个值与预先设定的参考值比较，根据结果来决定是否更新对应像素的颜色。</li>
<li>这个比较的过程被称为模板测试</li>
</ul>
</li>
<li>发生在透明度测试后，深度测试前</li>
<li>通过测试，则更新像素点，否则不更新语法表示</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stencil&#123;</span><br><span class="line">    Ref referenceValue</span><br><span class="line">    ReadMask readMask</span><br><span class="line">    WriteMask writeMask</span><br><span class="line">    Comp comparisonFunction</span><br><span class="line">    Pass stencilOperation</span><br><span class="line">    Fail stencilOperation</span><br><span class="line">    ZFail stencilOperation<span class="comment">//模板测试通过了，但是深度测试没通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(referenceValue&amp;readMask comparisonFunction stencilBufferValue&amp;readMask)</span><br><span class="line">pass</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">discard</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-1-比较函数Comparison-Function"><a href="#1-2-1-比较函数Comparison-Function" class="headerlink" title="1.2.1 比较函数Comparison Function"></a><strong>1.2.1 比较函数Comparison Function</strong></h5><table>
<thead>
<tr>
<th align="center">Greater</th>
<th align="center">GEqual</th>
<th align="center">Less</th>
<th align="center">LEqual</th>
<th align="center">Equal</th>
<th align="center">NotEqual</th>
<th align="center">Always</th>
<th align="center">Never</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$&gt;$</td>
<td align="center">$\geq$</td>
<td align="center">$&lt;$</td>
<td align="center">$\leq$</td>
<td align="center">$&#x3D;$</td>
<td align="center">$\neq$</td>
<td align="center">总是通过</td>
<td align="center">总是失败</td>
</tr>
</tbody></table>
<h5 id="1-2-2-模板（更新）操作stencilOperation"><a href="#1-2-2-模板（更新）操作stencilOperation" class="headerlink" title="1.2.2 模板（更新）操作stencilOperation"></a><strong>1.2.2 模板（更新）操作stencilOperation</strong></h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Keep</td>
<td align="center">保留当前缓冲内容，即stencilBufferValue不变</td>
</tr>
<tr>
<td align="center">Zero</td>
<td align="center">将0写入缓冲，即stencilBufferValue变为0</td>
</tr>
<tr>
<td align="center">Replace</td>
<td align="center">将参考值写入缓冲，即将stencilBufferValue赋值为referenceValue</td>
</tr>
<tr>
<td align="center">IncrSat</td>
<td align="center">stencilBufferValue加1，如果超过255，则保留为255</td>
</tr>
<tr>
<td align="center">DecrSat</td>
<td align="center">stencilBufferValue减1，如果小于0，则保留为0</td>
</tr>
<tr>
<td align="center">Invert</td>
<td align="center">将stencilBufferValue按位取反</td>
</tr>
<tr>
<td align="center">IncrWarp</td>
<td align="center">stencilBufferValue加1，如果超过255，则变成0（然后继续自增）</td>
</tr>
<tr>
<td align="center">DecrWarp</td>
<td align="center">stencilBufferValue减1，如果小于0，则变成255（然后继续自减）</td>
</tr>
</tbody></table>
<h4 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a><strong>1.3 总结</strong></h4><ul>
<li><p>使用模板缓冲区最重要的两个值：当前模板缓冲值stencilBufferValue和模板参考值referenceValue</p>
</li>
<li><p>模板测试主要就是对这两个值使用特定的比较操作</p>
</li>
<li><p>模板测试之后要对模板缓冲区的值进行更新操作，Keep，Zero，Replace等</p>
</li>
<li><p>模板测试之后可以根据结果对模板缓冲区做不同的更新操作，比如测试成功操作pass，测试失败操作fail，深度测试失败Zfail，还有正对正面和背面精确更新操作PassBack，PassFront，FailBack等</p>
</li>
<li><p>应用</p>
<ul>
<li>描边<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816205437129.png" alt="image-20220816205437129"></li>
</ul>
</li>
<li>多边形填充<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816205429461.png" alt="image-20220816205429461"></li>
</ul>
</li>
<li>反射区域控制<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816205345560.png" alt="image-20220816205345560"></li>
</ul>
</li>
<li>Shadow Volume</li>
</ul>
</li>
</ul>
<h3 id="二、深度测试Depth-Test"><a href="#二、深度测试Depth-Test" class="headerlink" title="二、深度测试Depth Test"></a><strong>二、深度测试Depth Test</strong></h3><ul>
<li>一些特性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816205656742.png" alt="image-20220816205656742"></p>
<p>在这里面值得注意的是最后一张，greater的部分，绿色的部分消失了。这是因为蓝色外面的部分还没有渲染，是无穷远，greater的比较无法通过，就不被渲染。像这种涉及无穷远比较的，比如天空盒，要多注意深度测试的比较方式。</p>
<h4 id="2-1-渲染管线中的深度测试"><a href="#2-1-渲染管线中的深度测试" class="headerlink" title="2.1 渲染管线中的深度测试"></a><strong>2.1 渲染管线中的深度测试</strong></h4><blockquote>
<p>  Early-Z</p>
<p>  现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</p>
<p>  片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。</p>
<p>  ——LearnOpengl</p>
</blockquote>
<ul>
<li><p>（Early-Z）</p>
</li>
<li><p>片元着色器</p>
</li>
<li><p>逐片元操作（可配置，不可编程）</p>
<ul>
<li>像素权限测试Pixel Ownership Test（屏幕窗口使用权限，如scene和game窗口区分）</li>
<li>裁剪测试Scissor Test（可以对渲染部分区域进行控制）</li>
<li>透明度测试Alpha Test（片元透明度大于阈值，则通过测试，否则剔除——只能实现不透明和全透明）</li>
<li>模板测试Stencil Test</li>
<li>深度测试Depth Test</li>
<li>混合Blending</li>
<li>Dithering</li>
<li>Logic Op</li>
</ul>
</li>
</ul>
<h4 id="2-2-深度测试理解"><a href="#2-2-深度测试理解" class="headerlink" title="2.2 深度测试理解"></a><strong>2.2 深度测试理解</strong></h4><p>深度测试就是当前对象在屏幕（Frame Buffer）对应的像素点，将对象自身的深度值与该当前该像素点缓存的深度值进行比较，如果通过，本对象在该像素点才会将颜色写入颜色缓冲，否则不会写入。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度缓冲区</span></span><br><span class="line"><span class="keyword">if</span>(ZWrite On &amp;&amp; (currentDepthValue ComparisonFunction DepthBufferValue))</span><br><span class="line">写入深度</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">忽略深度</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色缓冲区</span></span><br><span class="line"><span class="keyword">if</span>(currentDepthValue Comparison Function DepthBufferValue)</span><br><span class="line">写入颜色缓冲</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">不写入颜色缓冲</span><br></pre></td></tr></table></figure>

<ul>
<li>从发展角度理解<ul>
<li>控制渲染顺序<ul>
<li>画家算法</li>
<li>Z-Buffer算法</li>
</ul>
</li>
<li>控制Z-Buffer对深度的储存<ul>
<li>Z-Test</li>
<li>Z-Write</li>
</ul>
</li>
<li>控制不同类型物体渲染顺序<ul>
<li>透明物体</li>
<li>不透明物体</li>
<li>渲染队列</li>
</ul>
</li>
<li>减少overdraw<ul>
<li>Early-Z</li>
<li>Z-Cull</li>
<li>Z-check</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-2-1-深度缓冲区Z-Buffer"><a href="#2-2-1-深度缓冲区Z-Buffer" class="headerlink" title="2.2.1 深度缓冲区Z-Buffer"></a><strong>2.2.1 深度缓冲区Z-Buffer</strong></h5><p>深度缓冲就像颜色缓冲，在每个片段中储存了信息，并且和颜色缓冲一样拥有宽度和高度，深度缓冲是由窗口系统自动创建的，他会以16、24、32位float的形式储存深度值。在大部分系统中深度缓冲精度都是24位。（Z-Buffer中储存的是当前深度信息，对于每个像素储存一个深度值）</p>
<p>通过Z-Write和Z-Test来调用Z-Buffer，实现想要的渲染结果</p>
<h5 id="2-2-2-深度写入Z-Write"><a href="#2-2-2-深度写入Z-Write" class="headerlink" title="2.2.2 深度写入Z-Write"></a><strong>2.2.2 深度写入Z-Write</strong></h5><p>深度写入包括两种状态：Z-Write On 与Z-Write Off</p>
<p>当我们开启深度写入时，物体被渲染时，对应每个像素的深度都写入到深度缓冲区。反之，不会写入。但是物体写入深度，除了需要深度写入开启，还需要通过深度测试。</p>
<p>Z-Test分为通过和不通过两种情况，Z-Write分为开启和关闭两种情况，一共就是四种情况</p>
<table>
<thead>
<tr>
<th align="center">深度测试</th>
<th align="center">深度写入</th>
<th align="center">深度缓冲区</th>
<th align="center">颜色缓冲区</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通过</td>
<td align="center">开启</td>
<td align="center">写入</td>
<td align="center">写入</td>
</tr>
<tr>
<td align="center">通过</td>
<td align="center">关闭</td>
<td align="center">不写入</td>
<td align="center">写入</td>
</tr>
<tr>
<td align="center">失败</td>
<td align="center">开启</td>
<td align="center">不写入</td>
<td align="center">不写入</td>
</tr>
<tr>
<td align="center">失败</td>
<td align="center">关闭</td>
<td align="center">不写入</td>
<td align="center">不写入</td>
</tr>
</tbody></table>
<p>这里顺便附上之前用Opengl做天空盒时对深度测试的理解。（现在看来glDepthMask就是开启深度写入，glDepthFunc就是比较函数，只有开启深度测试，深度写入才有用）可以根据上面的表格来更深入地理解下面的描述。</p>
<blockquote>
<p>  此外，还额外进行了天空盒的绘制，天空盒其实也就是先绘制一个立方体，然后将其z坐标取为w，使得在坐标归一化除以w时，z&#x3D;1位于无限远的位置，这样能够使得天空的面永远在无限远处。</p>
<p>  期间还需要对深度缓存进行一些操作。以下是我的理解。</p>
<p>  &#x2F;&#x2F;在不进行天空盒z&#x3D;w操作的基础上，我们先渲染一遍天空盒，并且在此期间关闭深度遮罩不写入深度缓存，渲染完毕后开启深度遮罩，渲染其他物体，此时，其他物体覆盖在天空盒上,正常渲染</p>
<p>  &#x2F;&#x2F;(是否写入深度缓存结果上也等同于是否进行深度测试，即可以关闭深度遮罩，也可以关闭深度测试)</p>
<pre><code>//如果不关闭深度遮罩，天空盒深度将写入深度缓存，如果物体在天空盒后面，则被遮挡。



//理解测试：那么在不进行z=w的时候，先绘制天空盒，不关闭深度遮罩，但是在绘制完天空盒之后，清除深度缓存，能正常绘制其他物体。测试正确。

//现在进行z=w的操作，并且先渲染天空盒，采用关闭深度测试的方式，即便z=1.0，也能正常渲染（未写入深度缓冲）。但是如果把天空盒放在最后渲染,天空盒将覆盖所有物体。

//如果是采用关闭深度遮罩的方式呢？只是不写入深度缓存，但实际上还是会进行深度测试，z=1.0无法渲染天空盒，因为原本就是1，但如果用LEQUAL,则可以渲染天空盒（默认为LESS）

//实际上，天空盒深度值已经是1.0的情况，开启深度遮罩没有任何意义（开启深度遮罩只是为了避免天空盒深度小于其他物体的情况，1.0已经最大），渲染天空盒和物体的顺序也不会有影响

//但是，后渲染天空盒，保留深度测试，可以利用深度测试提升性能
</code></pre>
</blockquote>
<h5 id="2-2-3-比较函数Comparison-Function"><a href="#2-2-3-比较函数Comparison-Function" class="headerlink" title="2.2.3 比较函数Comparison Function"></a><strong>2.2.3 比较函数Comparison Function</strong></h5><table>
<thead>
<tr>
<th align="center">Greater</th>
<th align="center">GEqual</th>
<th align="center">Less</th>
<th align="center">LEqual</th>
<th align="center">Equal</th>
<th align="center">NotEqual</th>
<th align="center">Always</th>
<th align="center">Never</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$&gt;$</td>
<td align="center">$\geq$</td>
<td align="center">$&lt;$</td>
<td align="center">$\leq$</td>
<td align="center">$&#x3D;$</td>
<td align="center">$\neq$</td>
<td align="center">总是通过</td>
<td align="center">总是失败</td>
</tr>
</tbody></table>
<h5 id="2-2-4-默认状态"><a href="#2-2-4-默认状态" class="headerlink" title="2.2.4 默认状态"></a><strong>2.2.4 默认状态</strong></h5><p>Z-Write On，Z-Test Lequal，深度缓存一开始为无穷大。（这些和Opengl是不一样的）</p>
<h4 id="2-3-渲染队列"><a href="#2-3-渲染队列" class="headerlink" title="2.3 渲染队列"></a><strong>2.3 渲染队列</strong></h4><h5 id="2-3-1-Unity中的渲染队列"><a href="#2-3-1-Unity中的渲染队列" class="headerlink" title="2.3.1 Unity中的渲染队列"></a><strong>2.3.1 Unity中的渲染队列</strong></h5><p>Unity中设置队列</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816220946497.png" alt="image-20220816220946497"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot; = &quot;Transparent&quot;&#125;<span class="comment">//默认是Geometry</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">渲染队列</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Background（1000）</td>
<td>最早被渲染的物体的队列</td>
</tr>
<tr>
<td align="center">Geometry（2000）</td>
<td>不透明物体的渲染队列。大多数物体都应该是用该队列进行渲染（默认渲染队列）</td>
</tr>
<tr>
<td align="center">AlphaTest（2450）</td>
<td>有透明通道，需要进行AlphaTest的物体的队列，比在Geometry中更有效</td>
</tr>
<tr>
<td align="center">Transparent（3000）</td>
<td>半透明物体。一般是不写入深度的物体，Alpha Blend等的在该队列渲染</td>
</tr>
<tr>
<td align="center">Overlay（4000）</td>
<td>最后被渲染的物体。一般是覆盖效果，如镜头光晕，屏幕贴片。</td>
</tr>
</tbody></table>
<ul>
<li>渲染队列的物体排序：根据深度排序，深度小的在最前，深度大的在最后</li>
<li>不透明物体的渲染顺序：从前往后</li>
<li>透明物体的渲染顺序：从后往前（OverDraw）</li>
</ul>
<h5 id="2-3-2-Tips"><a href="#2-3-2-Tips" class="headerlink" title="2.3.2 Tips"></a><strong>2.3.2 Tips</strong></h5><p>多pass shader中，unity会选择所有pass里队列最靠前的作为物体的队列，然后根据pass的编写顺序逐pass执行</p>
<h4 id="2-4-Early-Z"><a href="#2-4-Early-Z" class="headerlink" title="2.4 Early-Z"></a><strong>2.4 Early-Z</strong></h4><p>传统的渲染管线中，Z-Test是在Blending阶段，这时的深度测试，所有对象都计算过了片元着色器。大量的计算是无用的。</p>
<p>现代GPU运用了Early-Z技术，在Vs和Fs之间，进行一次深度测试。如果深度测试失败，就不必进行片元着色器的计算。但是最终的Z-Test仍需进行，保证最终遮挡结果正确。前面一次主要是Z-Cull为了裁剪达到优化目的。后一次是Z-Check，为了检查。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816221825445.png" alt="image-20220816221825445"></p>
<h4 id="2-5-深度值"><a href="#2-5-深度值" class="headerlink" title="2.5 深度值"></a><strong>2.5 深度值</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220816222256273.png" alt="image-20220816222256273"></p>
<p>这个非线性深度也能够回答GAMES101中闫老师在投影矩阵那部分，讲frustum中间的点在投影矩阵之后是变远了还是变近了的问题。</p>
<blockquote>
<p>  要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1&#x2F;z  成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度。花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。</p>
<p>  由于非线性方程与 1&#x2F;z  成正比，在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值，这就是一个float提供给我们的一半精度了，这在z值很小的情况下提供了非常大的精度。在50.0和100.0之间的z值将会只占2%的float精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：<br>  $$<br>  F_{depth}&#x3D;\frac{1&#x2F;z-1&#x2F;near}{1&#x2F;far-1&#x2F;near}<br>  $$
  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/depth_non_linear_graph.png" alt="img"></p>
<h5 id="2-5-1-深度冲突Z-fighting"><a href="#2-5-1-深度冲突Z-fighting" class="headerlink" title="2.5.1 深度冲突Z-fighting"></a><strong>2.5.1 深度冲突Z-fighting</strong></h5><blockquote>
<p>  一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</p>
</blockquote>
<p>所以实际上z-fighting的问题还是精度的问题。</p>
<p>一般解决方法就是稍微移动一点，不要重合。Learnopengl里还基于深度储存的精度剔除，可以把近平面设置远一点。或者是用更大的精度来储存。（实际上永远不会有足够的精度来保证完全重合）</p>
<h4 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a><strong>2.6 总结</strong></h4><ul>
<li>是用深度缓冲区最重要的两个值：当前深度缓冲currentDepthValue和深度缓冲值zbufferValue，并通过比较操作获取理想渲染结果</li>
<li>Unity中的渲染顺序：先渲染不透明物体（从前往后），再渲染透明物体（从后往前）</li>
<li>通过深度写入和深度测试组合控制半透明物体的渲染</li>
<li>引入Early-z技术后的深度测试渲染流程</li>
<li>深度缓冲区储存0-1的浮点值（非线性深度）</li>
<li>应用<ul>
<li>基于深度的着色（湖水）<ul>
<li>（摄像机到地面距离和湖水深度作比较，以差值比例控制着色）</li>
</ul>
</li>
<li>ShadowMap</li>
<li>透明物体、粒子渲染</li>
<li>透视X-ray效果</li>
<li>切边效果</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><p><strong>根据课程内容，使用深度测试与模板测试做一些有意思的效果</strong></p>
<h4 id="模板测试-描边"><a href="#模板测试-描边" class="headerlink" title="模板测试-描边"></a><strong>模板测试-描边</strong></h4><p>正好撞见Unity的描边，我们就来试试模板测试的描边</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819163419228.png" alt="image-20220819163419228"></p>
<p>我们来拆解一下这个效果</p>
<ul>
<li>2pass<ul>
<li>一个pass绘制物体<ul>
<li>写入一个模板值</li>
</ul>
</li>
<li>一个pass绘制物体法线外扩<ul>
<li>模板比较</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>现在问题就在于，如何进行法线外扩。</p>
<p><a target="_blank" rel="noopener" href="https://www.laowangomg.com/?p=712">https://www.laowangomg.com/?p=712</a></p>
<p>这篇文章总结的非常详细。</p>
<p>其实最重要的问题是，我们在什么时候进行法线外扩？从模型空间到齐次裁剪空间过程中，在哪一步？</p>
<p>问题在于，我们应该让法线如何外扩？对于模型上的所有顶点，沿法线方向移动距离s，这是模型空间、世界空间、相机空间的做法。这样做的问题在于，我们可以把这个距离看作都是世界空间的距离，在经过投影变换后，不同位置的尺度会发生变化，也就是说，导致描边不均匀。</p>
<p>上面的博客给出的办法是——在齐次裁剪空间进行法线外扩，并且我们可以忽略z轴上的变化。只考虑屏幕的xy方向。</p>
<p>但是在我的实践中发现了一个问题，就是其实描边的宽度还是会出现不一致。并且这和渲染窗口分辨率有关。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819220901399.png" alt="image-20220819220901399"></p>
<p>于是我们就知道是怎么回事了：</p>
<p><strong>齐次裁剪空间时宽度一致的外扩尺度，经过视口变换后不再一致</strong>，但是我们肯定没有办法在视口变换的阶段处理顶点的位置，因此我们仍然需要进行改变。</p>
<p>我们要解决的核心问题是，让它在屏幕上能保持尺度的一致，其实，就是&#x3D;&#x3D;观察空间&#x3D;&#x3D;保持一致。</p>
<p>之前说在MVP空间的外扩都会导致投影后尺度变化。事实的确如此，在观察空间也会出现这个问题。</p>
<p>那么，在观察空间如何解决这一问题呢？我们可以借用裁剪空间的方法，只考虑屏幕上xy的变化，而忽略z的尺度变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.pos.xy += <span class="built_in">normalize</span>(vNormal.xy) * _OutLine;</span><br><span class="line"><span class="comment">//o.pos.xyz += normalize(vNormal.xyz) * _OutLine;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看出使用XYZ和xy的细微差别，这也很好理解。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1660921557672.gif" alt="1660921557672"></p>
<p>这里我还做了一项处理就是让描边的粗细不受距离的影响，或者说，距离增加，描边的粗细也应该增加。不然就会像这样</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819222542483.png" alt="image-20220819222542483"></p>
<p>这应该如何处理呢？</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819232155564.png" alt="image-20220819232155564"></p>
<p>我们的h1&#x2F;z1是由参数控制的，不妨令z1为1，则h1就等于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">normalize</span>(o.pos.xy)*_OutLine</span><br></pre></td></tr></table></figure>

<p>那么要令距离z2的点在投影上和h1具有相同的高度，h2就很好求了。</p>
<p>这里还要注意，将z值取绝对值，我们只需要正值的计算。这样再调一调粗细的参数，效果和unity的描边效果就是基本一致的。</p>
<p>但是这种做法的局限性在于顶点法线，如果比较尖锐的顶点不是插值的法线的话，就会出现面片的分离。这就需要对模型法线进行处理，涉及到相应的工具制作。这也就是之后下一步工作的伏笔了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1660923128047.gif" alt="1660923128047"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line"></span><br><span class="line">    Stencil&#123;</span><br><span class="line">        Ref <span class="number">0</span></span><br><span class="line">            Comp Equal</span><br><span class="line">    &#125;</span><br><span class="line">	Cull front</span><br><span class="line">    CGPROGRAM</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> _OutLine;</span><br><span class="line">    <span class="type">float</span> _Attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="function">v2f <span class="title">vert</span><span class="params">(a2v v)</span> </span>&#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos = <span class="built_in">mul</span>(UNITY_MATRIX_MV,v.vertex);</span><br><span class="line">        float3 vNormal = <span class="built_in">mul</span>((float3x3) UNITY_MATRIX_V, <span class="built_in">UnityObjectToWorldNormal</span>(v.normal));</span><br><span class="line">        o.pos.xy += <span class="built_in">normalize</span>(vNormal.xy) * _OutLine * <span class="built_in">abs</span>(o.pos.z);</span><br><span class="line">        o.pos = <span class="built_in">mul</span>(UNITY_MATRIX_P,o.pos);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span></span><br><span class="line">        fixed4 color =<span class="built_in">fixed4</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fixed4</span>(color);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们为了放止描边被遮挡，也可做如下处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stencil&#123;</span><br><span class="line">    Ref <span class="number">1</span></span><br><span class="line">        Comp Always</span><br><span class="line">        Pass replace</span><br><span class="line">        ZFail replace</span><br><span class="line">&#125;<span class="comment">//物体pass</span></span><br><span class="line"></span><br><span class="line">Stencil&#123;</span><br><span class="line">    Ref <span class="number">0</span></span><br><span class="line">        Comp Equal</span><br><span class="line">&#125;</span><br><span class="line">Cull front</span><br><span class="line">ZTest always<span class="comment">//描边pass</span></span><br></pre></td></tr></table></figure>



<h4 id="深度测试-遮挡透视"><a href="#深度测试-遮挡透视" class="headerlink" title="深度测试-遮挡透视"></a><strong>深度测试-遮挡透视</strong></h4><p>首先当然是做一个遮挡扫描效果。</p>
<p>我们来拆解下这个效果的组成</p>
<ul>
<li>遮挡物<ul>
<li>正常的</li>
</ul>
</li>
<li>被遮挡物<ul>
<li>多pass<ul>
<li>以正常部分的队列为物体渲染队列从前往后</li>
</ul>
</li>
<li>正常部分<ul>
<li>Geometry</li>
<li>开启深度测试LESS，开启深度写入</li>
</ul>
</li>
<li>遮挡部分<ul>
<li>Transparent</li>
<li>开启深度测试Greater，不写入深度</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们首先来写一下遮挡部分</p>
<p>在透明的处理上，顺便看了下3.2部分的混合，用正常的透明混合方法Blend SrcAlpha OneMinusSrcAlpha</p>
<p>当然也可以选择其他的（感觉差不太多）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817153223447.png" alt="image-20220817153223447" style="zoom:50%;" />

<h5 id="大问题"><a href="#大问题" class="headerlink" title="大问题"></a><strong>大问题</strong></h5><p>出现了一个大问题。为遮挡物赋予一些材质时，会导致渲染顺序出错。</p>
<p>正常来说，遮挡物和被遮挡物都会处于Geometry的渲染队列，并且遮挡物先渲染，再渲透明Pass，最后是非透明Pass这是非常合理的.</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211331779.png" alt="image-20220817211331779"></p>
<p>赋予某些材质后。</p>
<p>有些时候是正常的，有些时候，透明pass会在遮挡物之前渲染，导致透明物体被遮挡。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211349707.png" alt="image-20220817211349707"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211648337.png" alt="image-20220817211648337"></p>
<p>这还不是最麻烦的。在这个状态下，如果后退摄像机一点，这里两个透明物体中的其中一个被渲染出来了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211717544.png" alt="image-20220817211717544"></p>
<p>如果再后退一点——透明物体都正常绘制了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211752817.png" alt="image-20220817211752817"></p>
<p>**但是，这依然不是最麻烦的。**如果这个时候，再把摄像机后退一些会发生什么呢？</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817211856345.png" alt="image-20220817211856345"></p>
<p>这就是我所感觉到的绝望。</p>
<p>解决方法我想到了很多。</p>
<ol>
<li>被遮挡物体物体两个Pass都放在了Geometry渲染。如果把两个Pass放在Geometry之后的其他Pass渲染，就没问题了。但要注意修改Tags的pass时，最好是subshader的pass，这样会比较稳定，如果只改两个Pass的tags，是不稳定的。</li>
<li>和上面的方法基本思想一样，做法刚好相反。就是一定要保证遮挡物在被遮挡物两个pass之前渲染，把遮挡物的队列设成Geometry-1（或者更前面）就好了。</li>
<li>换一个遮挡物的shader和材质。这个是比较麻烦的。因为，即便是一个原本能正常绘制的shader，在我完全复制所有代码以后，重新生成的材质，依然出现了上述问题。这就比较玄学了，这也是最头疼的部分。。。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/468122471%E7%94%A8%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8A%8A%E4%B8%A4%E4%B8%AApass%E5%88%86%E5%BC%80%E5%88%B0%E4%B8%A4%E4%B8%AAshader%EF%BC%8C%E7%94%A8UsePass%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%90%84%E8%87%AA%E7%9A%84subshader%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E5%90%84%E8%87%AA%E7%9A%84Tag%E3%80%82%E7%BB%93%E6%9E%9C%E4%B9%9F%E6%98%AF%E6%AD%A3%E5%B8%B8%E7%9A%84%E3%80%82">https://zhuanlan.zhihu.com/p/468122471用这篇文章的处理方法，把两个pass分开到两个shader，用UsePass的方法，这样各自的subshader可以设置各自的Tag。结果也是正常的。</a></li>
</ol>
<p>但是，虽然这些方法能解决问题，我还是不知道为什么会出现这样的问题，以及，其实没有解决问题的根本——为什么在这些shader中渲染顺序会出错，不应该都是按深度排序的吗？</p>
<p>首先会考虑是否是z精度的问题？但是又怎么会随距离周期变化呢？</p>
<p>发现其实DepthPass顺序就错了，也就是说直接原因还是深度。但是为什么某些材质就没有这个问题了呢？并且SubShader和Pass的Tag也有影响。。。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220817213753109.png" alt="image-20220817213753109"></p>
<p><strong>又找到了一个绝妙的解决方法</strong></p>
<p>我直接重新做一个shader，然后用两次UsePass。。。当然，缺少原来CGINCLUDE的参数和属性，这一部分直接原样复制过去就行了。</p>
<p>果然能解决问题。</p>
<p>。。。但是令人崩溃的又来了。。。我继续把两个UsePass分别替换回原来的两个Pass的代码。。。竟然也是对的。。。问题是这样和原来的代码有啥区别。。。shader的名字的区别。。。为什么。。。已经麻了，就当是bug吧。</p>
<p>感觉跟unity的资源读取和shader编译的过程有一定关系。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhlabcd/p/11767018.html%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%87%BA%E7%8E%B0%E4%BA%86%E4%B8%80%E6%A0%B7%E7%9A%84%E7%8E%B0%E8%B1%A1%EF%BC%8C%E4%BD%86%E6%98%AF%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%8E%9F%E5%9B%A0%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%B8%8D%E8%BF%87%E5%8F%AF%E8%83%BD%E6%9C%89%E4%B8%80%E5%AE%9A%E5%85%B1%E6%80%A7%E3%80%82">https://www.cnblogs.com/zhlabcd/p/11767018.html这篇文章出现了一样的现象，但是看起来原因不太一样，不过可能有一定共性。</a></p>
<p>背后的真正原因，只能有缘再解决了</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Tb4y1C7Qa">https://www.bilibili.com/video/BV1Tb4y1C7Qa</a></p>
<p>【技术美术百人计划】图形 3.1 深度与模板测试  传送门效果示例</p>
<p>[2] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/">https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/427742656">https://zhuanlan.zhihu.com/p/427742656</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://www.laowangomg.com/?p=712">https://www.laowangomg.com/?p=712</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/468122471">https://zhuanlan.zhihu.com/p/468122471</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A23.1%20%E6%B7%B1%E5%BA%A6%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95/" data-id="cmfe1u6ph0027scuh75yr8oad" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.7.2 GPU硬件架构概述" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.7.2%20GPU%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2025-09-10T13:18:14.025Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-2-7-2-GPU硬件架构概述"><a href="#图形-2-7-2-GPU硬件架构概述" class="headerlink" title="图形 2.7.2 GPU硬件架构概述"></a>图形 2.7.2 GPU硬件架构概述</h1><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822162918576.png" alt="image-20220822162918576"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h3><p>GPU是Graphics Processing Unit（图形处理单元）的缩写。顾名思义，GPU最初就是用于更高效的图像的绘制和图元数据处理。和CPU相比，GPU简化了控制模块与Cache模块，但是具有大量的ALU（算术逻辑单元），并且可以进行并行运算。因此，CPU更擅长逻辑、控制、串行运算，GPU更易于运行并行程序。</p>
<p>GPU和通常所说的显卡严格来说是据有区别的，GPU是显卡（Video card、Display card、Graphics card）最核心的部件，但除了GPU，显卡还有扇热器、通讯元件、与主板和显示器连接的各类插槽。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822162950559.png" alt="image-20220822162950559"></p>
<p>我们通常所说的显卡和GPU实际上具有一定区别。GPU是显卡的核心部分，再加上散热器，以及和主板、显示器的各种插槽等，就构成了显卡。显卡不能独立工作，需要装载到主板上，结合CPU、内存、显存、显示器等硬件组成完整的PC</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822163026806.png" alt="image-20220822163026806"></p>
<p>当前市场主流的GPU厂商有Nvidia、AMD、ARM、Imagination、Qualcomm、苹果。</p>
<p>目前在PC、手机、VR一体机等设备上，GPU都发挥着作用，为我们在设备上绘制出更快速、优质的画面奠定了基础。甚至除了绘制，在人工智能领域，近几年神经网络能够成为主流，GPU在其中也起到重要的作用。</p>
<h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a><strong>发展历史</strong></h3><p>1999年，Nvidia的GeForce 256 发布，Nvidia将GPU定义为“集成了变换，照明，三角形设置&#x2F;裁剪和渲染引擎的单芯片处理器，每秒能够处理至少1000万个多边形。GeForce 256被认为是第一块完成商业化的GPU，将GPU引入市场，是市场上第一款采用硬件加速T&amp;L（Transformation&amp;Lighting）的消费级卡。而在GeForce 256之前，也并非没有“具有完整T&amp;L引擎的显卡”，但是它们从未引入市场。实际上，20世纪70年代就有了“GPU”的概念，索尼于1994年PS1推出时使用“GPU”的术语。该系统有一个32位索尼GPU（由东芝设计）。这个阶段的GPU也已经基本具备渲染、Z缓冲、Alpha混合、雾计算、模板缓冲、纹理映射、纹理过滤等功能。</p>
<p>从下面开始，以Nvidia的GPU发展过程为代表来讲述现代GPU和GPU架构的发展历史。</p>
<p>2001年的GeForce3 开始，引入了可编程的渲染管线（可编程顶点着色器，可配置的32位浮点片段着色管线）。</p>
<p>2006年推出了GeForce8 系列（G8x），也正是在这一代的GPU的基础上，开始有了GPU架构——Tesla架构。</p>
<p>2010年的Fermi架构是第一个完整的GPU计算架构，是NVIDIA GPU 架构自初代 G80 以来最重大的飞跃。后来的Kepler架构、Maxwell架构都是基于Fermi架构的基础。</p>
<p>2012年的Kepler架构显卡（600，700系列）和2014年的Maxwell架构显卡采用28nm工艺制造，使性能提高了20%。</p>
<p>2014年的Maxwell架构，立体像素全局光照VXGI技术首次让游戏GPU能够提供实时动态全局光照</p>
<p>2016年的GeForce GTX系列采用接替Maxwell的Pascal架构。Pascal 架构将处理器和数据集成在同一个程序包内，以实现更高的计算效率。1080系列、1060系列都是基于Pascal架构。</p>
<p>2017年发布的Volta 架构配备了640 个Tensor core，这是专为深度学习设计的内核，每秒可提供超过100 兆次浮点运算(TFLOPS) 的深度学习效能，比前一代的Pascal 架构快5 倍以上。使用Volta架构的Titan V显卡也是专用于AI和仿真。</p>
<p>从2018年开始的Turing架构，融合了Volta专用的Tensor Core，同时增加了RT core，这是光线追踪技术的核心。RT Core 能够以高达每秒 10 Giga Rays 的速度对光线和声音在 3D  环境中的传播进行加速计算。Turing 架构将实时光线追踪运算加速至上一代 NVIDIA Pascal架构的 25 倍，并能以高出 CPU  30 多倍的速度进行电影效果的最终帧渲染。为了体现对光线追踪的支持，NVIDIA在这之后的显卡前缀都采用了RTX。</p>
<p>2020年的RTX 30系列采用了最新的Ampere架构。Ampere架构的Tensor core采用新的Tensor Float32（TF32）与64位浮点（FP64）精度标准。RT core也进行了更新，运算能力达到第一代的两倍。</p>
<h3 id="GPU架构组成"><a href="#GPU架构组成" class="headerlink" title="GPU架构组成"></a><strong>GPU架构组成</strong></h3><p>每一代的GPU架构虽然具有差异，但也有一些相同的概念和组成部分。</p>
<p>以Fermi架构为例，Fermi架构拥有16个SM （Stream Multiprocessor 流多处理器&#x2F;计算单元）。SM支持并发执行多个thread。Kepler、Maxwell架构中甚至对SM升级为SMX、SMM。程序员编写的Shader是在SM上运行的。</p>
<p>每个SM包含：</p>
<ul>
<li>2个Warp Scheduler</li>
<li>2个Dispatch Unit（分发单元）</li>
<li>2个Warp（线程束）</li>
<li>16组LD&#x2F;ST（加载存储单元）</li>
<li>4个SFU（特殊函数单元）</li>
<li>128KB Register File（寄存器）</li>
<li>64KB Shared Memory &#x2F;L1 Cache</li>
<li>Uniform Cache（全局缓存）</li>
</ul>
<p>每个Warp包含32个Core（也叫做SP——Stream Processor）；</p>
<p>每个Core包含1个FPU（浮点数单元），1个ALU（算术逻辑单元）</p>
<p>Warp Scheduler负责Warp调度，Warp Scheduler的指令通过Dispatch Units送到运算核心（Core）执行。</p>
<p>LD&#x2F;ST(Load&#x2F;Store)加载&#x2F;存储模块用于辅助一个Warp从Shared Memory或显存加载或存储数据。</p>
<p>对于L1 Cache，部分GPU架构中是与Shared Memory共用的（如Fermi架构）。</p>
<p>Turing：</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822163459068.png" alt="image-20220822163459068"></p>
<p>共性：</p>
<ul>
<li>GPC（图形处理簇）</li>
<li>TPC（纹理处理簇）</li>
<li>Thread（线程）</li>
<li>SM、SMX、SMM（流多处理器）</li>
<li>Warp线程束、Warp Scheduler（Warp编排器）</li>
<li>SP（Streaming Processor，流处理器）</li>
<li>Core（执行数学运算的核心）</li>
<li>ALU（逻辑运算单元）</li>
<li>FPU（浮点运算单元）</li>
<li>SFU（特殊函数单元）</li>
<li>ROP（render output unit，渲染输入单元）</li>
<li>Load&#x2F;Store Unit（加载存储单元）</li>
<li>L1 Cache</li>
<li>L2 Cache</li>
<li>Shared Memory（共享内存）</li>
</ul>
<h3 id="微观物理架构"><a href="#微观物理架构" class="headerlink" title="微观物理架构"></a><strong>微观物理架构</strong></h3><ul>
<li>GPC<ul>
<li>TPC<ul>
<li>SM<ul>
<li>Poly Morph Engine（多边形引擎）</li>
<li>L1 Cache</li>
<li>Shared Memory</li>
<li>Core<ul>
<li>ALU</li>
<li>FPU</li>
<li>Execution Context（执行上下文）<ul>
<li>汇编代码会被GPU推送到执行上下文（Execution Context），然后ALU会逐条获取（Detch）、解码（Decode）汇编指令，并执行它们。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="GPU存储架构"><a href="#GPU存储架构" class="headerlink" title="GPU存储架构"></a><strong>GPU存储架构</strong></h3><h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a><strong>内存架构</strong></h4><p>GPU的存储架构分级由</p>
<ul>
<li>Register File (Memory)寄存器<ul>
<li>位于每个SM中，访问速度最快的存储体，用于存放线程执行时所需的变量</li>
</ul>
</li>
<li>Shared Memory共享内存<ul>
<li>位于每个SM中</li>
</ul>
</li>
<li>L1 Cache</li>
<li>L2 Cache</li>
<li>Constant Memory常量内存<ul>
<li>位于每个SM中和片外的RAM存储器中</li>
</ul>
</li>
<li>Texture Memory纹理内存<ul>
<li>位于每个SM中和片外的RAM存储器中</li>
</ul>
</li>
<li>Global Memory全局内存<ul>
<li>位于片外存储体。容量大，访问延迟高、传输速度较慢，使用二级缓存L2 Cache做缓冲</li>
</ul>
</li>
<li>Local Memory本地内存<ul>
<li>一般位于片内存储体，变量、数组、结构体等都存放在此处，但是有大数组、大结构体以至于寄存器区放不下他们，编译器在编译阶段就会将他们放到片外的DDR芯片中（最好的情况也会放到L2 Cache），且将他们标记为“Local”型</li>
</ul>
</li>
</ul>
<p>构成，它们的存取速度从寄存器到显存依次变慢。</p>
<p>他们物理上所在的位置，决定了他们的速度、大小以及访问规则</p>
<table>
<thead>
<tr>
<th>存储类型</th>
<th>访问周期</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1</td>
</tr>
<tr>
<td>共享内存</td>
<td>1~32</td>
</tr>
<tr>
<td>L1缓存</td>
<td>1~32</td>
</tr>
<tr>
<td>L2缓存</td>
<td>32~64</td>
</tr>
<tr>
<td>纹理、常量缓存</td>
<td>400~600</td>
</tr>
<tr>
<td>全局内存</td>
<td>400~600</td>
</tr>
</tbody></table>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>在不同的平台（PC或移动设备），GPU的存储架构分为分离式和耦合式（是否共享内存）。</p>
<p>分离式架构中CPU和GPU各自有独立的缓存和内存，通过PCI-e总线通讯，缺点是PCI-e相对于两者具有低带宽和高延迟，数据的传输成为其中的性能瓶颈。一般用于PC；</p>
<p>耦合式架构中CPU与GPU共享内存和缓存。AMD的APU采用的就是这种架构。目前主要是用在游戏主机、移动设备中，如PS4，智能手机。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/1617944-20190906001850363-356121869.png" alt="img" style="zoom:67%;" />

<p>在储存管理方面，分离式架构中CPU与GPU各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式架构，GPU没有独立的内存，与CPU共享系统内存，由MMU进行存储管理。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822173521235.png" alt="image-20220822173521235"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822173644684.png" alt="image-20220822173644684"></p>
<h3 id="GPU逻辑管线"><a href="#GPU逻辑管线" class="headerlink" title="GPU逻辑管线"></a><strong>GPU逻辑管线</strong></h3><p>我们根据GPU的渲染过程来了解每个部分在GPU中发挥的作用。以Fermi的SM为例</p>
<p>1、程序通过图形API(DX、GL、WEBGL)发出draw call指令，指令会被推送到驱动程序，驱动会检查指令的合法性，然后会把指令放到GPU可以读取的Push buffer中。</p>
<p>2、经过一段时间或者显式调用flush指令后，驱动程序把Push buffer的内容发送给GPU，GPU通过主机接口（Host Interface）接受这些命令，并通过前端（Front End）处理这些命令。</p>
<p>3、在图元分配器(Primitive Distributor)中开始工作分配，处理index buffer中的顶点产生三角形分成批次(batches)，然后发送给多个GPCs（Graphics Processing Cluster）。</p>
<p>4、在GPC中，每个SM中的Poly Morph Engine负责通过三角形索引(triangle indices)取出三角形的数据(vertex data)——Vertex Fetch。</p>
<p>5、在获取数据之后，在SM中以32个线程为一组的线程束(Warp)来调度，来开始处理顶点数据。</p>
<p>6、SM的warp调度器会按照顺序分发指令给整个warp，单个warp中的线程会锁步(lock-step)执行各自的指令，如果线程碰到不激活执行的情况也会被遮掩(be masked  out)。</p>
<p>7、warp中的指令可以被一次完成，也可能经过多次调度，例如通常SM中的LD&#x2F;ST(加载存取)单元数量明显少于基础数学操作单元。</p>
<p>8、由于某些指令比其他指令需要更长的时间才能完成，特别是内存加载，warp调度器可能会简单地切换到另一个没有内存等待的warp，这是GPU如何克服内存读取延迟的关键，只是简单地切换活动线程组。为了使这种切换非常快，调度器管理的所有warp在寄存器文件中都有自己的寄存器。这里就会有个矛盾产生，Shader需要越多的寄存器，就会给warp留下越少的空间，就会产生越少的warp，这时候在碰到内存延迟的时候就会只是等待，而没有可以运行的warp可以切换。</p>
<p>9、一旦warp完成了vertex shader的所有指令，运算结果会被Viewport Transform模块处理，三角形会被裁剪然后准备栅格化，GPU会使用L1和L2缓存来进行vertex shader和pixel shader的数据通信。</p>
<p>10、接下来这些三角形将被分割，再分配给多个GPC，三角形的范围决定着它将被分配到哪个光栅引擎(raster engines)，每个raster engines覆盖了多个屏幕上的tile，这等于把三角形的渲染分配到多个tile上面。也就是像素阶段就把按三角形划分变成了按显示的像素划分了。</p>
<p>11、SM上的Attribute Setup保证了从vertex shader来的数据经过插值后是pixel shade是可读的。</p>
<p>12、GPC上的光栅引擎(raster engines)在它接收到的三角形上工作，来负责这些这些三角形的像素信息的生成（同时会处理裁剪Clipping、背面剔除和Early-Z剔除）。</p>
<p>13、32个像素线程将被分成一组，或者说8个2x2的像素块，这是在像素着色器上面的最小工作单元，在这个像素线程内，如果没有被三角形覆盖就会被遮掩，SM中的warp调度器会管理像素着色器的任务。</p>
<p>14、接下来的阶段就和vertex shader中的逻辑步骤完全一样，但是变成了在像素着色器线程中执行。 由于不耗费任何性能可以获取一个像素内的值，导致锁步执行非常便利，所有的线程可以保证所有的指令可以在同一点。</p>
<p>15、最后一步，现在像素着色器已经完成了颜色的计算还有深度值的计算，在这个点上，我们必须考虑三角形的原始api顺序，然后才将数据移交给ROP(render output  unit，渲染输入单元)，一个ROP内部有很多ROP单元，在ROP单元中处理深度测试，和framebuffer的混合，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。</p>
<h3 id="SIMD和SIMT"><a href="#SIMD和SIMT" class="headerlink" title="SIMD和SIMT"></a><strong>SIMD和SIMT</strong></h3><ul>
<li>SIMD（Single Instruction Multiple Data），单指令多数据，在GPU的ALU内，一条指令可以处理多维向量（一般是4D）的数据，比如以下shader指令<ul>
<li>float4 c&#x3D;a+b;</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;对于没有SIMD的处理单元，需要4条指令将4个float数值相加，汇编如下</span><br><span class="line">ADD c.x, a.x, b.x</span><br><span class="line">ADD c.y, a.y, b.y</span><br><span class="line">ADD c.z, a.z, b.z</span><br><span class="line">ADD c.w, a.w, b.w</span><br><span class="line">;有了SIMD技术，只需一条指令</span><br><span class="line">SIMD_ADD c,a,b</span><br></pre></td></tr></table></figure>

<ul>
<li>SIMT（Single Instruction Multiple Threads），单指令多线程，是SIMD的升级版，可对GPU中单个SM中的多个Core同时处理同一指令，并且每个Core存取的数据可以不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SIMT_ADD c,a,b</span><br><span class="line">;上述指令会被同时送入在单个SM中被编组的所有Core中，同时执行运算，但a,b,c的值可以不同</span><br><span class="line">;相当于</span><br><span class="line">__global__ void add(float *a, float *b, float *c) &#123;</span><br><span class="line">	int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">	a[i] = b[i] + c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="co-issue"><a href="#co-issue" class="headerlink" title="co-issue"></a><strong>co-issue</strong></h4><p>co-issue是为了解决SIMD运算单元无法充分利用的问题。如下图，由于float的数量不同，ALU的利用率也不同</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822171640666.png" alt="image-20220822171640666"></p>
<p>为了解决着色器在低维向量的利用率低的问题，可以通过合并1D与3D或2D与2D的指令。例如下图，DP3指令用了3D数据，ADD指令只有1D数据，co-issue会自动将它们合并，在同一个ALU只需一个指令周期即可执行完</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220822171813268.png" alt="image-20220822171813268"></p>
<p>但是对于向量运算单元（Vector ALU），如果其中一个变量既是操作数又是存储数的情况，无法使用co-issue</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li>vs和fs都是在同一个单元中执行的，vs按照三角形来并行处理，fs按照像素来并行处理。</li>
<li>vs和fs中的数据通过L1和L2缓存传递</li>
<li>warp和thread都是逻辑上的概念，sm和sp、core都是物理上的概念。线程束≠流处理器数</li>
</ul>
<h4 id="优化建议："><a href="#优化建议：" class="headerlink" title="优化建议："></a><strong>优化建议：</strong></h4><ol>
<li>尽量使用自己扩展的几何实例化代替unity提供的静态合批，动态合批。前者将合并mesh增加额外的vbo内存占用。后者则会增加cpu端的耗时开销。</li>
<li>尽量减少顶点数与三角形面数。前者减少vs计算，另外可以减少gpu显存中frameData的内存存储。后者减少fs的消耗</li>
<li>避免每帧提交buffer数据，比如unity的CPU版本粒子系统。可使用GPU版本粒子系统，将修改数据移动到gpu端。另外特别提醒尽量避免大片的透明粒子特效，这将造成严重的overdraw</li>
<li>减少渲染状态的设置与获取。例如在update中获取设置shader的属性或公共变量。因为前面说到cpu通过MMIO获取寄存器数据，这将耗费更多的时间周期。</li>
<li>3D物件应使用LOD减少处理的顶点与面数消耗，开启mipmap减少贴图缓存命中的丢失</li>
<li>避免Alpha Test的使用，造成Early-Z失效</li>
<li>避免三角面过小，这会加剧过度绘制的情况。也就是一个三角形只占3个像素点，却使用了12个线程去计算像素值，然后遮蔽其余9个的计算机结果。</li>
<li>在寄存器数量与变体中寻找平衡，使用if变量达成静态分支，取代变体。一方面可以减少变体数量，一方面可以使得URP中的SRP Batch更高效合批</li>
<li>避免动态的判断分支。也就是Shader中if true和false都会走的情况</li>
<li>减少复杂函数调用。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/timlly/p/11471507.html#22-gpu%E5%8E%86%E5%8F%B2">https://www.cnblogs.com/timlly/p/11471507.html#22-gpu%E5%8E%86%E5%8F%B2</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.nvidia.cn/data-center/ampere-architecture/">https://www.nvidia.cn/data-center/ampere-architecture/</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Graphics_processing_unit">图形处理单元 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aM4y1g75f">https://www.bilibili.com/video/BV1aM4y1g75f</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://www.daimajiaoliu.com/daima/486fc2a23900400">云渲染与分布式并行集群渲染技术 (daimajiaoliu.com)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.7.2%20GPU%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/" data-id="cmfe1u6ph0029scuh4ca046ad" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.5 BUMP图改进" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.5%20BUMP%E5%9B%BE%E6%94%B9%E8%BF%9B/" class="article-date">
  <time datetime="2025-09-10T13:18:14.024Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形2-5-BUMP图改进"><a href="#图形2-5-BUMP图改进" class="headerlink" title="图形2.5 BUMP图改进"></a>图形2.5 BUMP图改进</h1><h3 id="一、凹凸贴图Bump-Mapping"><a href="#一、凹凸贴图Bump-Mapping" class="headerlink" title="一、凹凸贴图Bump Mapping"></a><strong>一、凹凸贴图Bump Mapping</strong></h3><ul>
<li>把物体的细节分为三种尺度<ul>
<li>宏观尺度（覆盖很多像素）<ul>
<li>由几何图元来表示</li>
</ul>
</li>
<li>中观尺度（覆盖少量像素）<ul>
<li>细节复杂，无法使用单个三角形渲染，并且足够大</li>
</ul>
</li>
<li>微观尺度（可能覆盖小于一个像素）<ul>
<li>在着色模型当中表现，模拟物体表面微观几何形状的相互作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>凹凸映射是模拟中观尺度的常用方法之一，能够让观察者感知到比几何模型尺度更小的细节</p>
<p>基本思想：在纹理中把尺度细节相关的信息编码进去，在着色过程中用受到干扰的表面代替真实表面，就让表面看起来具有小尺度的细节。</p>
<p>总之，凹凸贴图是对物体表面贴图进行变化再进行光照计算的一种技术。（增加物体真实感，但不需要额外的几何复杂度）</p>
<ul>
<li>分类<ul>
<li>法线贴图</li>
<li>视差贴图</li>
<li>浮雕贴图</li>
</ul>
</li>
</ul>
<p>在这三种技术中都会用到法线(贴图)</p>
<h3 id="二、法线贴图Normal-Mapping"><a href="#二、法线贴图Normal-Mapping" class="headerlink" title="二、法线贴图Normal Mapping"></a><strong>二、法线贴图Normal Mapping</strong></h3><p>法线贴图是一张存有物体局部表面法线信息的贴图。</p>
<p>计算光照时，程序读取法线图，并获取当前着色点的法线信息，结合光照信息进行光照计算。</p>
<p>法线贴图一般由高模映射到对应的底模上来生成，但像金属、木头等细节丰富的物体，可借助程序化软件如：Photoshop,Substance Designer等生成对应法线贴图</p>
<h4 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a><strong>切线空间</strong></h4><p>法线的储存一般放在模型的切线空间中</p>
<ul>
<li>切线空间<ul>
<li>物体表面切线、副切线、法线方向为基，组成的几何空间</li>
</ul>
</li>
<li>读取切线空间法线，需要将法线从切线空间转换到世界空间</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731003919885.png" alt="image-20220731003919885" style="zoom:67%;" />



<h4 id="世界和切线空间转换"><a href="#世界和切线空间转换" class="headerlink" title="世界和切线空间转换"></a><strong>世界和切线空间转换</strong></h4><p>切线空间坐标系的正交基是世界空间下的顶点法线（N）、切线（T）、副切线（B），法线为z轴，切线为x轴，副切线为y轴</p>
<p>构建一个3x3的矩阵做空间向量的坐标系转换。<br>$$<br>TBN &#x3D; \begin{bmatrix}T_x&amp;B_x&amp;N_x\<br>T_y&amp;B_y&amp;N_y\<br>T_z&amp;B_z&amp;N_z\<br>\end{bmatrix}\<br>\ \<br>TBN^{-1}&#x3D;TBN^T&#x3D;\begin{bmatrix}T_x&amp;T_y&amp;T_z\<br>B_x&amp;B_y&amp;B_z\<br>N_x&amp;N_y&amp;N_z\<br>\end{bmatrix}\<br>$$<br>想不清哪个是世界-切线，哪个是切线-世界，考虑一个单位阵，左乘矩阵，看看会变成什么就知道了。</p>
<ul>
<li>切线空间的好处<ul>
<li>切线空间记录的是相对的法线信息，对于一个物体表面记录的法线扰动，可以同样应用到球形物体上（植物的光照处理），但是模型空间记录法线就是绝对的，只能在该物体上用。</li>
<li>方便制作UV动画，贴图采样变化一致</li>
<li>法线纹理可重用</li>
<li>便于计算储存，0-1的储存映射范围，知道两个可以计算另一个</li>
</ul>
</li>
<li>Unity中法线贴图的压缩格式<ul>
<li>非移动平台，unity会把法线贴图转换成DXRT5nm格式，这种格式只有两个有效通道AG通道，可以节省空间<ul>
<li>在DXRT5nm格式中，AG通道分别储存对应法线的x，y分量，z分量需要通过一个简单的计算求得。</li>
</ul>
</li>
<li>移动平台，unity使用传统RGB通道</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/7416ead6-fc7e-4e52-9dba-b56d68996a2a.png" alt="7416ead6-fc7e-4e52-9dba-b56d68996a2a" style="zoom: 33%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/8b45fbb7-0987-4b01-9c95-c47166d160b4.png" alt="8b45fbb7-0987-4b01-9c95-c47166d160b4" style="zoom: 67%;" />



<h3 id="三、视差贴图Parallax-Mapping"><a href="#三、视差贴图Parallax-Mapping" class="headerlink" title="三、视差贴图Parallax Mapping"></a><strong>三、视差贴图Parallax Mapping</strong></h3><p>法线贴图只能改变法线而改变光照，无法使模型表面产生遮挡效果</p>
<p>视差贴图Parallax Mapping是一种类似法线贴图的技术。它用于提高模型表面细节并赋予其遮挡关系，可以和法线贴图一起使用。</p>
<p>视差贴图需要引进一张新的贴图——高度图。高度图一般是用于顶点位移使用的（位移&#x2F;置换贴图 Displacement mapping），但性能消耗高，需要大量三角形。视差贴图的核心是改变纹理坐标来改变遮挡关系，视差贴图就利用储存模型信息的高度图，<strong>利用模型表面高度信息来对纹理进行偏移</strong>。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731010656743.png" alt="image-20220731010656743" style="zoom: 67%;" />

<p>在着色时，模型在切线空间下所有点都在切平面内（0.0），核心就是对于要计算的片元A时，真正应该计算的点是视线与物体的“实际”交点B点。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731011441775.png" alt="image-20220731011441775"></p>
<p>要计算B点，就需要AB两点在平面上的UV偏差，为了简便，采取近似计算的方法，根据高（深）度图及切线空间下视角方向，近似求解偏移量，视角方向（v）与切平面的正切值与A点的高度值相乘来近似求解，并通过一个缩放值来控制。（有比较大的误差，必须要用这个scale来调整）<br>$$<br>d &#x3D; \frac{v.xy}{v.z}\cdot ha\cdot scale<br>$$</p>
<h4 id="陡峭视察映射Steep-Parallax-Mapping"><a href="#陡峭视察映射Steep-Parallax-Mapping" class="headerlink" title="陡峭视察映射Steep Parallax Mapping"></a>陡峭视察映射Steep Parallax Mapping</h4><p>陡峭视察映射也是近似，但更准确一些</p>
<p>陡峭视察映射将深度分为等距的若干层，从顶端开始采样，并且每次沿视角方向偏移一定值，若当前层深度大于采样出的深度，则停止检查并返回结果</p>
<p>（有点ray marching的感觉，那其实在优化上也可以借鉴一下分级采样？<a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/CbZTf-uM4/#real-time-global-illuminationscreen-space%EF%BC%89">https://xzyw7.github.io/post/CbZTf-uM4/#real-time-global-illuminationscreen-space）</a></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731012950141.png" alt="image-20220731012950141"></p>
<p>也可以根据v和n的角度来对采样层数进行控制</p>
<h3 id="四、浮雕贴图Relief-Mapping"><a href="#四、浮雕贴图Relief-Mapping" class="headerlink" title="四、浮雕贴图Relief Mapping"></a><strong>四、浮雕贴图Relief Mapping</strong></h3><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731014135800.png" alt="image-20220731014135800" style="zoom:50%;" />

<p>视差贴图在使用较大的uv偏移时存在失真。</p>
<p>浮雕贴图更容易提供更多的深度，还可以做自阴影、AO效果</p>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>浮雕映射一般采用射线步进、二分查找来决定uv偏移量</p>
<p>第一种使用射线步进来查找可能的交点（直接用二分查找可能漏掉较薄的区域导致结果不准确），确定交点位于哪一个步进内。之后在该步进内使用二分查找快速确定交点位置，最后返回结果，偏移贴图。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220731014352296.png" alt="image-20220731014352296"></p>
<ul>
<li>解决最后一步二分查找性能开销问题<ul>
<li>视差闭塞贴图（Parallax Occlusion Mapping）</li>
<li>在步进后，分别对步进两端uv值采样，对结果插值，作为p点的结果（插值导致表面平滑效果更好）</li>
</ul>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><p>结合先行版基础渲染光照介绍（一）将本次课所讲的案例结合进先前的光照效果</p>
<p>这里就4个案例嘛</p>
<h4 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h4><p>左一：standard shader</p>
<p>左二：custom shader，使用法线贴图</p>
<p>右一：custom shader，无法线贴图</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220801232026790.png" alt="image-20220801232026790"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct v2f &#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    float3 normal : TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    float2 uv : TEXCOORD2;</span><br><span class="line">    float3 tangent : TEXCOORD3;</span><br><span class="line">    float3 bitangent : TEXCOORD4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fixed3 normal = <span class="built_in">normalize</span>(i.normal);</span><br><span class="line">fixed3x3 TBN = fixed3x3(<span class="built_in">normalize</span>(i.tangent),<span class="built_in">normalize</span>(i.bitangent),normal);</span><br><span class="line">TBN = <span class="built_in">transpose</span>(TBN);<span class="comment">//Unity shader的矩阵是行优先的，所以我们要取个转置；</span></span><br><span class="line">fixed3 bump = <span class="built_in">normalize</span>(UnpackNormal(tex2D(_Normal, i.uv)));</span><br><span class="line">normal = <span class="built_in">normalize</span>(mul(TBN,bump));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不想像入门精要那样传一整个矩阵，我们可以传递的变量也是有限的，甚至可以只传tangent，副切线用叉乘计算。甚至也可以用之前的ddx和ddy的trick来计算。</p>
<p><a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/zezxM-QCJ/#ddxddy%E4%B8%8E%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE">https://xzyw7.github.io/post/zezxM-QCJ/#ddxddy%E4%B8%8E%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE</a></p>
<p>（Tips：有注意到在learnopengl中有描述，在一些网格较大的时候，出现TBN不互相垂直的情况，可以用施密特正交化来解决。）</p>
<h4 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h4><p>这个时候发现……狮子模型这个素材没有高度图……还得换个素材……</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fixed3 LightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<span class="comment">//normalize(_WorldSpaceLightPos0.xyz);//</span></span><br><span class="line">fixed3 ViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));<span class="comment">//normalize(_WorldSpaceCameraPos.xyz - i.worldPos);</span></span><br><span class="line">float3 h = <span class="built_in">normalize</span>(LightDir + ViewDir);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fixed3 normal = <span class="built_in">normalize</span>(i.normal);</span><br><span class="line">fixed3 bitangent = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(normal,i.tangent.xyz) * i.tangent.w);</span><br><span class="line">fixed3x3 TBN = fixed3x3(<span class="built_in">normalize</span>(i.tangent.xyz),bitangent,normal);</span><br><span class="line">TBN = <span class="built_in">transpose</span>(TBN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//视差贴图</span></span><br><span class="line"><span class="type">float</span> height = tex2D(_heightMap,i.uv).r;</span><br><span class="line">float3 ViewDirTS = <span class="built_in">normalize</span>(mul(<span class="built_in">transpose</span>(TBN),ViewDir));</span><br><span class="line">float2 offUV = ViewDirTS.xy/ViewDirTS.z * height * _heightScale;</span><br><span class="line">i.uv -= offUV;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法线贴图</span></span><br><span class="line">fixed3 bump = <span class="built_in">normalize</span>(UnpackNormal(tex2D(_Normal, i.uv)));</span><br><span class="line">normal = <span class="built_in">normalize</span>(mul(TBN,bump));</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802000836213.png" alt="image-20220802000836213"></p>
<p>视差贴图在视线接近垂直的时候效果还是很好的，但是正如learnopengl中所说，当从一个角度看过去的时候，会有一些问题产生（和法线贴图相似），陡峭的地方会产生不正确的结果。并且它的效果非常依赖于_heightScale这一参数</p>
<h4 id="陡峭视差贴图"><a href="#陡峭视差贴图" class="headerlink" title="陡峭视差贴图"></a>陡峭视差贴图</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">float2 steepParallaxMapping (float2 uv, float3 viewDir) &#123;</span><br><span class="line">    <span class="type">float</span> numLayers = <span class="number">20</span>;</span><br><span class="line">    <span class="type">float</span> layerHeight = <span class="number">1.0</span>/numLayers;</span><br><span class="line">    float2 deltaUV = <span class="number">1.0</span>/numLayers * viewDir.xy / viewDir.z * _heightScale;</span><br><span class="line">    float2 currentUV = uv;</span><br><span class="line">    <span class="type">float</span> currentHeight = tex2D(_heightMap,uv).r;</span><br><span class="line">    <span class="type">float</span> currentLayerHeight = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(currentLayerHeight &lt; currentHeight)</span><br><span class="line">    &#123;</span><br><span class="line">        currentUV -= deltaUV;</span><br><span class="line">        currentHeight = tex2Dlod(_heightMap, float4(currentUV,<span class="number">0.0</span>,<span class="number">0.0</span>)).r;</span><br><span class="line">        <span class="comment">//currentHeight = tex2Dgrad(_heightMap, currentUV,0.0,0.0).r;  </span></span><br><span class="line">        currentLayerHeight += layerHeight;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentUV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间一直出现的报错“unable to unroll loop”，给tex2D改成tex2Dlod或tex2Dgrad就好了</p>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/391443312">https://zhuanlan.zhihu.com/p/391443312</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144434084">https://zhuanlan.zhihu.com/p/144434084</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57994423/why-i-cant-use-tex2d-inside-a-loop-in-unity-shaderlab">https://stackoverflow.com/questions/57994423/why-i-cant-use-tex2d-inside-a-loop-in-unity-shaderlab</a></p>
<p><em>tex2D只能从“均匀控制流”调用，因为它必须通过计算“导数”来计算LOD。tex2Dlod没有，因为您提供了LOD。</em></p>
<p>tex2Dlod和tex2Dgrad都能指定纹理层，所以能够在循环中调用。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802161513119.png" alt="image-20220802161513119"></p>
<h4 id="浮雕贴图"><a href="#浮雕贴图" class="headerlink" title="浮雕贴图"></a>浮雕贴图</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">float2 steepParallaxMapping (float2 uv, float3 viewDir) &#123;</span><br><span class="line">    <span class="type">float</span> numLayers = <span class="number">20</span>;</span><br><span class="line">    <span class="type">float</span> layerHeight = <span class="number">1.0</span>/numLayers;</span><br><span class="line">    float2 deltaUV = <span class="number">1.0</span>/numLayers * viewDir.xy / viewDir.z * _heightScale;</span><br><span class="line">    float2 currentUV = uv;</span><br><span class="line">    <span class="type">float</span> currentHeight = tex2D(_heightMap,uv).r;</span><br><span class="line">    <span class="type">float</span> currentLayerHeight = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(currentLayerHeight &lt; currentHeight)</span><br><span class="line">    &#123;</span><br><span class="line">        currentUV -= deltaUV;</span><br><span class="line">        currentHeight = tex2Dlod(_heightMap, float4(currentUV,<span class="number">0.0</span>,<span class="number">0.0</span>)).r;  </span><br><span class="line">        currentLayerHeight += layerHeight;  </span><br><span class="line">    &#125;</span><br><span class="line">    float2 left = currentUV;</span><br><span class="line">    float2 right = currentUV+deltaUV;</span><br><span class="line">    <span class="type">float</span> dist = <span class="number">1</span>;</span><br><span class="line">    float2 midpoint = (left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">        midpoint = (left+right)/<span class="number">2</span>;</span><br><span class="line">        currentHeight = tex2Dlod(_heightMap, float4(midpoint,<span class="number">0.0</span>,<span class="number">0.0</span>)).r;</span><br><span class="line">        currentLayerHeight = <span class="built_in">length</span>(midpoint)/<span class="built_in">length</span>(viewDir.xy) * viewDir.z;</span><br><span class="line">        <span class="keyword">if</span> (currentLayerHeight &lt; currentHeight) &#123;</span><br><span class="line">            right = midpoint;</span><br><span class="line">            dist = currentHeight - currentLayerHeight;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentLayerHeight &gt; currentHeight) &#123;</span><br><span class="line">            left = midpoint;</span><br><span class="line">            dist = -currentHeight + currentLayerHeight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> midpoint;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="视察闭塞贴图"><a href="#视察闭塞贴图" class="headerlink" title="视察闭塞贴图"></a>视察闭塞贴图</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float2 left = currentUV;</span><br><span class="line">float2 right = currentUV+deltaUV;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> afterDepth  = currentHeight-currentLayerHeight;</span><br><span class="line"><span class="type">float</span> beforeDepth = tex2D(_heightMap, right).r -currentLayerHeight + layerHeight;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> weight = afterDepth / (afterDepth - beforeDepth);</span><br><span class="line">float2 finalTexCoords = right * weight + left * (<span class="number">1.0</span> - weight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> finalTexCoords;</span><br></pre></td></tr></table></figure>

<p>POM是肉眼可见的效果不错（上：SPM，中：RPM，下：POM），RPM就不太能看得出变化了，但其实还是有的</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802175923830.png" alt="image-20220802175923830" style="width:80%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802180825768.png" alt="image-20220802180825768" style="width:80%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220802175853495.png" alt="image-20220802175853495" style="width:80%;" />

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ub4y1Z765">https://www.bilibili.com/video/BV1Ub4y1Z765</a> 【技术美术百人计划】图形 2.5 BUMP图改进</p>
<p>[2] Unity Shader入门精要 p146-155</p>
<p>[3] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.5%20BUMP%E5%9B%BE%E6%94%B9%E8%BF%9B/" data-id="cmfe1u6pf001zscuh26mj434x" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.6 伽马校正" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.6%20%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3/" class="article-date">
  <time datetime="2025-09-10T13:18:14.024Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形-2-6-伽马校正"><a href="#图形-2-6-伽马校正" class="headerlink" title="图形 2.6  伽马校正"></a>图形 2.6  伽马校正</h1><h3 id="Gamma矫正"><a href="#Gamma矫正" class="headerlink" title="Gamma矫正"></a><strong>Gamma矫正</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730122434969.png" alt="image-20220730122434969"></p>
<h4 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a><strong>传递函数</strong></h4><ul>
<li>OETF<ul>
<li>光转电传递函数 ，负责把场景线性光转到非线性视频信号值</li>
</ul>
</li>
<li>EOTF<ul>
<li>电转光传递函数，负责把非线性视频信号值转换成显示光亮度</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730122710864.png" alt="image-20220730122710864" style="zoom:50%;" />

<h4 id="Gamma矫正-1"><a href="#Gamma矫正-1" class="headerlink" title="Gamma矫正"></a>Gamma矫正</h4><ul>
<li>Gamma是指对线性三色值和非线性视频信号之间进行编码和解码的操作</li>
<li>图像经过gamma编码储存在硬盘中，将获取到的物理数据做一次gamma值约为0.45(1&#x2F;2.2)的映射，这样的过程叫做gamma编码（此时的图像像素比实际物理像素要更亮——线性空间）</li>
<li>在显示图像时，需要将每个像素做一次gamma值约为2.2的矫正，使最终的结果为正确的物理数据（经过显示的gamma矫正后，之前偏亮的图像亮度降低——gamma空间）</li>
</ul>
<p>$$<br>V_{out}&#x3D;V_{in}^{gamma}<br>$$</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730144948798.png" alt="image-20220730144948798" style="zoom:80%;" />

<h4 id="为什么需要gamma矫正"><a href="#为什么需要gamma矫正" class="headerlink" title="为什么需要gamma矫正"></a><strong>为什么需要gamma矫正</strong></h4><ul>
<li>非线性转换的目的主要是为了优化储存空间和带宽，传递函数能够更好地利用编码空间</li>
<li>显示图像的数据都是8bit，但是人眼对暗部变化更敏感，为了充分利用带宽，那么需要使用更多空间去存储暗部值，也就是说暗部使用更高精度保存，亮部使用更低精度保存。</li>
</ul>
<p>以这张图来说明，对于人眼来说，上面的图像变化更均匀，但实际下面的图像才是物理上亮度均匀变化的。</p>
<p>（上面这张的中间灰度叫做美术中灰，下面的中间灰度叫做物理中灰）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730145336723.png" alt="image-20220730145336723" style="zoom:50%;" />

<p>将这两种变化进行一个映射，就是gamma曲线 </p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730145547142.png" alt="image-20220730145547142" style="zoom:50%;" />



<h4 id="韦伯定律"><a href="#韦伯定律" class="headerlink" title="韦伯定律"></a><strong>韦伯定律</strong></h4><ul>
<li>感觉的差别阈限随原来刺激量的变化而变化，而且表现为一定的规律性，用公式表达就是$\Delta\Phi&#x2F;\Phi &#x3D; C$ ，其中$\Phi$ 为原刺激量，$\Delta\Phi$ 为此时的差别阈限，C为常数，又称为韦伯率。（所受刺激越大，需要增加的刺激也要足够大才会让人感觉到明显变化，但是只适用于中等强度的刺激）</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul>
<li>人眼对暗部变化更敏感</li>
<li>我们目前使用的真彩格式RGBA32，每个通道只有8位用于记录信息，为了合理使用带宽和存储空间，需要进行非线性转换</li>
<li>目前我们所普遍使用的sRGB颜色空间标准，他的传递函数gamma值位2.2（2.4）</li>
</ul>
<h3 id="CRT与gamma矫正"><a href="#CRT与gamma矫正" class="headerlink" title="CRT与gamma矫正"></a><strong>CRT与gamma矫正</strong></h3><ul>
<li>CRT<ul>
<li>早期使用的CRT显示器（阴极射线显像管），设备的亮度与电压并不成线性关系，而是gamma值约为2.2类似幂律的关系</li>
<li>这种硬件特性与gamma矫正的需求正好是一种巧合</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730150841828.png" alt="image-20220730150841828" style="zoom: 67%;" />

<p>人眼对于中灰的感受取决于环境</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730151319961.png" alt="image-20220730151319961" style="zoom:50%;" />

<ul>
<li>线性工作流<ul>
<li>在生产各个环境，需要正确使用gamma编码与解码，使最终得到的颜色数据与最初输入的物理数据一致</li>
<li>如果是使用gamma空间的贴图，在传给着色器前需要从gamma空间转到线性空间</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730154948879.png" alt="image-20220730154948879" style="zoom:67%;" />

<p> <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730155223847.png" alt="image-20220730155223847"></p>
<h3 id="Unity中的颜色空间"><a href="#Unity中的颜色空间" class="headerlink" title="Unity中的颜色空间"></a><strong>Unity中的颜色空间</strong></h3><p>Edit-Project Settings-Player-Other Settings下的Rendering部分，修改Color Space</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730155540487.png" alt="image-20220730155540487"></p>
<ul>
<li>选择Gamma Space，Unity不会做任何处理</li>
<li>选择Linear Space，引擎的渲染流程在线性空间计算，理想情况下项目使用线性空间的贴图，不需要勾选sRGB，勾选sRGB的贴图会通过硬件特性采样时进行线性转换。</li>
</ul>
<h4 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a><strong>硬件支持</strong></h4><p>线性空间需要图形API的硬件支持，目前支持的平台</p>
<ol>
<li>Windows，Mac OS x和Linux（Standalone）</li>
<li>Xbox One</li>
<li>PS 4</li>
<li>Android（Opengl ES 3.0）</li>
<li>iOS（Metal）</li>
<li>WebGL</li>
</ol>
<h4 id="硬件特性支持"><a href="#硬件特性支持" class="headerlink" title="硬件特性支持"></a><strong>硬件特性支持</strong></h4><p>主要由两个硬件特性来支持</p>
<ul>
<li><p>sRGB Frame Buffer</p>
<ul>
<li>将Shader的计算结果输出到显示器前做Gamma矫正</li>
<li>作为纹理被读取时会自动把储存的颜色从sRGB空间转换到线性空间</li>
<li>调用ReadPixels()、ReadBackImage()时，会直接返回sRGB空间下的颜色</li>
<li>sRGB Frame Buffer只支持每通道8bit的格式，不支持浮点格式</li>
<li>HDR开启后会先把渲染结果绘制到浮点格式的FB中，最后绘制到sRGB FB上</li>
</ul>
</li>
<li><p>sRGB Sampler</p>
<ul>
<li>将sRGB的贴图进行线性采样的转换</li>
</ul>
</li>
</ul>
<p>使用硬件完成sRGB贴图的线性采样和shader计算结果的gamma矫正，比起在shader里对贴图采样和计算结果的矫正要快</p>
<h3 id="贴图制作导出的处理"><a href="#贴图制作导出的处理" class="headerlink" title="贴图制作导出的处理"></a><strong>贴图制作导出的处理</strong></h3><h4 id="Substance-Painter"><a href="#Substance-Painter" class="headerlink" title="Substance Painter"></a><strong>Substance Painter</strong></h4><p>sp贴图导出时，线性的颜色经过gamma变换，颜色被提亮了，所以需要在Unity中勾选sRGB选项，让它在采样时能还原回线性值。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730160341610.png" alt="image-20220730160341610"></p>
<h4 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a><strong>Photoshop</strong></h4><p>如果使用线性空间，一般来说Photoshop可以什么都不改，导出的贴图只要在Unity中勾上sRGB就可以了。</p>
<p>如果调整Photoshop的gamma值为1，导出的贴图在Unity中也不需要勾选sRGB</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730160653259.png" alt="image-20220730160653259"></p>
<ul>
<li><p>ps对颜色管理特别精确，Unity里看到的颜色要经过显示器的Gamma变换，而ps不会，ps会读取显示器的Color Profile，反向补偿回去。</p>
</li>
<li><p>ps中有第二个Color Profile，叫做Document Color Profile。通常默认为sRGB Color Profile，和显示器的Color Profile一致，颜色被压暗了，所以ps中看到的结果才和Unity一样。</p>
</li>
</ul>
<h5 id="混合"><a href="#混合" class="headerlink" title="混合"></a><strong>混合</strong></h5><p>Unity中的混合是线性的（线性空间模式下），ps图层与图层之间混合时，每个上层图层都经过了gamma变换，才做了混合。需要在设置中更改选择“用灰度系数混合rgb颜色”，参数设置为1，这样图层才是直接混合的结果。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730161152441.png" alt="image-20220730161152441"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><h4 id="手动尝试伽马校正的几种方法"><a href="#手动尝试伽马校正的几种方法" class="headerlink" title="手动尝试伽马校正的几种方法"></a><strong>手动尝试伽马校正的几种方法</strong></h4><h5 id="1-Unity线性空间"><a href="#1-Unity线性空间" class="headerlink" title="1.Unity线性空间"></a><strong>1.Unity线性空间</strong></h5><p>项目设置使用Linear空间，并且albedo贴图勾选sRGB</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730165247570.png" alt="image-20220730165247570"></p>
<h5 id="2-Unity-Gamma空间"><a href="#2-Unity-Gamma空间" class="headerlink" title="2.Unity Gamma空间"></a><strong>2.Unity Gamma空间</strong></h5><p>在项目设置里选择gamma空间</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730170411814.png" alt="image-20220730170411814"></p>
<p>可以观察到输出的颜色中，高光更亮、范围更大，因为光照是线性计算的，而且直接按照gamma空间输出了；但是直接输出的颜色更暗了。</p>
<h6 id="手动Gamma矫正"><a href="#手动Gamma矫正" class="headerlink" title="手动Gamma矫正"></a><strong>手动Gamma矫正</strong></h6><p>对于输出的radiance，我们进行gamma矫正</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> fixed4(LinearToGammaSpace(color),<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>以及采样贴图时，变换到线性空间计算</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed3 albedo = GammaToLinearSpace(tex2D(_Albedo, i.uv).rgb) * _Diffuse.rgb;</span><br></pre></td></tr></table></figure>

<p>（理论上来说，albedo这种属性是线性空间的，但是这也关乎到贴图导出的设置，一般制作的都是sRGB的图片，所以还是需要转换一下。）</p>
<p>这两个封装好的函数，也可以手动地去使用2.2次方去计算。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730171629559.png" alt="image-20220730171629559"></p>
<p>可以看到法线颜色球正常了，中间的我写的shader高光也压下来一些，但是这个Standard的着色器就改不了了。</p>
<p>所以引擎还是很方便的，我们在线性空间工作模式下，很多事情都帮我们做好了。但是需要在贴图的设置上多加注意。</p>
<ul>
<li>麻烦的地方<ul>
<li>在需要手动gamma矫正的平台上，在混合这一步会出现问题（因为在混合之前就进行gamma矫正了）</li>
<li>所以一个解决方法是：在fs颜色输出时不进行gamma矫正，但是需要一步后处理来完成gamma矫正，也造成了一些性能损耗。</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cU4y1b7UF">https://www.bilibili.com/video/BV1cU4y1b7UF</a> 【技术美术百人计划】图形 2.6  伽马校正</p>
<p>[2] Unity Shader 入门精要 p356-363.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.6%20%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3/" data-id="cmfe1u6pg0021scuh3bmg9kcd" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形1.4PC手机图形API介绍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.4PC%E6%89%8B%E6%9C%BA%E5%9B%BE%E5%BD%A2API%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形1-4PC手机图形API介绍"><a href="#图形1-4PC手机图形API介绍" class="headerlink" title="图形1.4PC手机图形API介绍"></a>图形1.4PC手机图形API介绍</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h3><ul>
<li><p>图形API</p>
<ul>
<li>是一个图形库，用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序接口（API），针对GPU。</li>
</ul>
</li>
<li><p>应用端</p>
<ul>
<li>我们自己的程序端</li>
</ul>
</li>
<li><p>图元</p>
<ul>
<li>要渲染的几何物体、形状</li>
</ul>
</li>
<li><p>纹理</p>
<ul>
<li>可以理解为贴图，opengl es中纹理就是图片的另一种叫法</li>
</ul>
</li>
<li><p>纹素</p>
<ul>
<li>纹理的基础单元（纹理的像素）</li>
</ul>
</li>
<li><p>顶点数组</p>
<ul>
<li>顶点是组成图元的各个顶点的坐标数据（vertex），这些坐标数据可以一起存到要给内存数组中，这就是顶点数组</li>
</ul>
</li>
<li><p>顶点缓冲区</p>
<ul>
<li>显存中专门分配一块显存来存储这个顶点数组，这个显存就是顶点缓冲区</li>
</ul>
</li>
<li><p>顶点着色器</p>
</li>
<li><p>片元着色器</p>
</li>
</ul>
<h3 id="主流图形API"><a href="#主流图形API" class="headerlink" title="主流图形API"></a><strong>主流图形API</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722211701281.png" alt="image-20220722211701281"></p>
<ul>
<li><p>DirectX（windows）</p>
</li>
<li><p>Opengl(windows,linux,mac)</p>
</li>
<li><p>Opengl ES(移动设备——手机、oculus)</p>
<ul>
<li>Opengl ES2.0&#x2F;3.0是可编程图形管线（vs、fs），1.x是固定管线</li>
</ul>
</li>
</ul>
<h3 id="Opengl-ES3-0新功能"><a href="#Opengl-ES3-0新功能" class="headerlink" title="Opengl ES3.0新功能"></a><strong>Opengl ES3.0新功能</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722211827363.png" alt="image-20220722211827363"></p>
<ul>
<li><p>兼容性</p>
<ul>
<li>gles 3.0是向后兼容的（2.0的程序可以在3.0中使用）</li>
</ul>
</li>
<li><p>新特性</p>
<ul>
<li>阴影贴图、体渲染、gpu粒子动画、几何形状实例化、纹理压缩、gamma矫正</li>
<li>适应嵌入系统的局限性</li>
</ul>
</li>
<li><p>渲染管线</p>
<ul>
<li>移除alpha测试<ul>
<li>片段着色器可抛弃片段，因此alpha测试可以在fs中进行</li>
</ul>
</li>
<li>移除逻辑操作（LogicOp）<ul>
<li>很少使用</li>
</ul>
</li>
</ul>
</li>
<li><p>Shader编写</p>
<ul>
<li><p>版本声明</p>
</li>
<li><pre><code class="language-glsl">#version 300 es//声明为指定使用Opengl ES3.0版本
//不添加版本声明或使用#version 100 es 指定使用ES2.0
//(2.0是es中最先出的可编程管线，所以是100，为了匹配版本号，3.0跳到了300 es)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -   输入输出</span><br><span class="line"></span><br><span class="line">        -   in,out,inout关键字取代attribute，varing</span><br><span class="line">        -   gl_FragColor和gl_FragData删除了</span><br><span class="line">        -   片段着色器可以使用out声明字段输出</span><br><span class="line"></span><br><span class="line">    -   变量赋值</span><br><span class="line"></span><br><span class="line">        -   可以直接使用layout对指定位置变量赋值</span><br><span class="line"></span><br><span class="line">        -   ```glsl</span><br><span class="line">            //shader中</span><br><span class="line">            layout (location = 1) uniform float a;</span><br><span class="line">//应用端代码中</span><br><span class="line">            GLES30.glUniform1f(1,1f);</span><br><span class="line">            //2.0中必须使用如下形式</span><br><span class="line">            GLES20.glUniform1f(GLES20.glGetAttribLocation(program,&quot;a&quot;),1f)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="骁龙Adreno对应ES版本型号"><a href="#骁龙Adreno对应ES版本型号" class="headerlink" title="骁龙Adreno对应ES版本型号"></a><strong>骁龙Adreno对应ES版本型号</strong></h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Adreno">https://zh.wikipedia.org/wiki/Adreno</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9A%E9%A9%8D%E9%BE%8D%E5%85%83%E4%BB%B6%E5%88%97%E8%A1%A8#Snapdragon_888">高通骁龙组件列表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>Adreno320开始支持OpenglES3.0</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><ul>
<li>支持Opengl es3.2的骁龙GPU型号有哪些<ul>
<li>Adreno420&#x2F;430&#x2F;5xx&#x2F;6xx&#x2F;7xx</li>
</ul>
</li>
<li>如何看待Vulkan、<ul>
<li>对Vulkan了解不多，最大的特点就是：更复杂，也更高性能，并且支持跨平台。这增加了它的学习成本和上手难度的同时，能更深入地控制硬件，达到对性能更极致的追求。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.4PC%E6%89%8B%E6%9C%BA%E5%9B%BE%E5%BD%A2API%E4%BB%8B%E7%BB%8D/" data-id="cmfe1u6pc001pscuh3q1oaopa" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.1色彩空间" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.1%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形2-1色彩空间"><a href="#图形2-1色彩空间" class="headerlink" title="图形2.1色彩空间"></a>图形2.1色彩空间</h2><p>发送器-接收者-色彩空间-常用色彩空间、色彩模型-色彩空间转换-总结</p>
<h3 id="一、发送器"><a href="#一、发送器" class="headerlink" title="一、发送器"></a>一、发送器</h3><p>光源是出生点，光源发射出光线，光线通过直射反射折射等路径最终进入人眼。</p>
<p>人眼接收到光线后，人眼细胞产生一系列化学反应，把产生的信号传入大脑，大脑对颜色产生认知。</p>
<ul>
<li><p>光源</p>
<ul>
<li>产生光的物体</li>
</ul>
</li>
<li><p>波长</p>
<ul>
<li>光的波长分布理论上是无限大的，人眼可见光是局限的</li>
</ul>
</li>
<li><p>能量分布</p>
<ul>
<li>分光光度计<ul>
<li>描述光线的具体能量强度</li>
<li>拆分光线，形成单一波长光</li>
<li>测量单一波长光的实际所含能量</li>
</ul>
</li>
</ul>
</li>
<li><p>光的传播</p>
<ul>
<li>光每次经过反射、投射都会对光的能量分布产生影响</li>
</ul>
</li>
</ul>
<h3 id="二、接收者"><a href="#二、接收者" class="headerlink" title="二、接收者"></a>二、接收者</h3><p>人眼接受色彩的特性</p>
<ul>
<li>相对亮度感知<ul>
<li>在暗的环境下看亮的东西会更亮</li>
</ul>
</li>
<li>人眼HDR<ul>
<li>人眼可以自动调整曝光</li>
<li>能够分辨高亮度当中的层次区别、阴影中物体的异同</li>
</ul>
</li>
<li>人眼感光细胞分布<ul>
<li>杆状细胞<ul>
<li>感知亮度，对亮度敏感</li>
</ul>
</li>
<li>锥状细胞<ul>
<li>感知色彩</li>
<li>L细胞（红色）、M细胞（绿色）、S细胞（蓝色）</li>
<li>根据这三种细胞分布可以得出，人眼对红色感知度最高，对蓝色感知度最低</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723141425478.png" alt="image-20220723141425478" style="zoom:50%;" />

<ul>
<li>接收公式<ul>
<li>$C&#x3D;\int S(\lambda)\cdot I(\lambda) \cdot R(\lambda)d\lambda$</li>
<li>C是人眼输出到大脑的神经电信号</li>
<li>S表示LMS三个感光细胞的感知分布</li>
<li>I表示光源的功率谱分布</li>
<li>R表示反射物体的吸收功率分布</li>
</ul>
</li>
</ul>
<h3 id="三、色彩空间"><a href="#三、色彩空间" class="headerlink" title="三、色彩空间"></a>三、色彩空间</h3><p>历史上人们对人眼感知色彩的猜测</p>
<ul>
<li>人们有100多种感受色彩的细胞</li>
<li>人眼有RGB三种感知细胞</li>
<li>人眼有黑白、红绿、黄蓝三种感知细胞</li>
</ul>
<h4 id="1905-Munsell色彩系统（美术角度）"><a href="#1905-Munsell色彩系统（美术角度）" class="headerlink" title="1905 Munsell色彩系统（美术角度）"></a><strong>1905 Munsell色彩系统</strong>（美术角度）</h4><p>（HSL色相饱和亮度）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723142131075.png" alt="image-20220723142131075" style="zoom:67%;" />



<h4 id="1931-CIE色彩系统（科学角度）"><a href="#1931-CIE色彩系统（科学角度）" class="headerlink" title="1931 CIE色彩系统（科学角度）"></a>1931 CIE色彩系统（科学角度）</h4><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723143907732.png" alt="image-20220723143907732" style="zoom:67%;" />



<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723144232530.png" alt="image-20220723144232530" style="zoom:67%;" />

<p>曲线覆盖的面积相等<br>$$<br>\int_0^\infin \bar r(\lambda)d\lambda&#x3D;\int_0^\infin \bar g(\lambda)d\lambda &#x3D; \int_0^\infin \bar b(\lambda)d\lambda<br>$$</p>
<p>红色基色强度有负数部分，虽然物理正确，但很不直观，不便使用，因此进行归一化，保证色彩在-1~1之间</p>
<p>归一化后，r’g’b’都在-1~1之间，r’+g’+b’&#x3D;1，可以通过其中两个计算另一个</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723144809678.png" alt="image-20220723144809678" style="zoom:34%;" />

<h4 id="1931-XYZ-色彩系统"><a href="#1931-XYZ-色彩系统" class="headerlink" title="1931 XYZ 色彩系统"></a>1931 XYZ 色彩系统</h4><ul>
<li>Color matching function</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723144427061.png" alt="image-20220723144427061" style="zoom:50%;" /></li>
</ul>
<p>XYZ与CIE 1931RGB的转换</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723145521683.png" alt="image-20220723145521683" style="zoom:50%;" />



<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723145726749.png" alt="image-20220723145726749" style="zoom:50%;" />

<p>在该图像上无法体现出亮度，于是在归一化的基础上把XYZ的Y拿出来与xy组成Yxy色彩空可能感觉，Y表示亮度，xy表示色彩</p>
<ul>
<li>问题<ul>
<li>色彩分布不均匀</li>
</ul>
</li>
</ul>
<h4 id="定义色彩空间"><a href="#定义色彩空间" class="headerlink" title="定义色彩空间"></a>定义色彩空间</h4><p>色彩空间满足的指标</p>
<ul>
<li>色域（三个基色的坐标，由此形成三角形）</li>
<li>Gamma（如何对三角形内进行切分）</li>
<li>白点（色域三角形中心）<ul>
<li>又称为E点或者D55点。白点用于定义色域的白色。相关关键词，白平衡。组成白点的各色能量频谱一致，因此白点的频谱是最平坦的。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723150148332.png" alt="image-20220723150148332" style="zoom:34%;" />

<p>sRGB的构成：在sRGB的色域与色域中心下，gamma&#x3D;2.2</p>
<h3 id="四、常用的色彩模型与色彩空间"><a href="#四、常用的色彩模型与色彩空间" class="headerlink" title="四、常用的色彩模型与色彩空间"></a>四、常用的色彩模型与色彩空间</h3><ul>
<li>色彩模型<ul>
<li>使用一定规则描述、排列颜色的方法</li>
<li>RGB、CMYK、LAB</li>
</ul>
</li>
<li>色彩空间<ul>
<li>需要至少满足三个指标<ul>
<li>色域、白点、Gamma</li>
</ul>
</li>
<li>CIE XYZ，Adobe RGB，sRGB，Japan Color 2001 Uncoated，US web Coated（后两个基于CMYK）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723150723307.png" alt="image-20220723150723307"></p>
<h3 id="五、色彩空间转换"><a href="#五、色彩空间转换" class="headerlink" title="五、色彩空间转换"></a>五、色彩空间转换</h3><p>这里直接复制一段几年前写的色彩模型转换的笔记</p>
<h5 id="HSV-RGB"><a href="#HSV-RGB" class="headerlink" title="HSV-RGB"></a>HSV-RGB</h5><p>在实际使用中，以$photoshop$为例，其色彩模型数值取值为：</p>
<p>​	$H取0-360，S，V取0-100%（实际用户输入调整数值范围为0-100）,此处计算取0-1较方便$</p>
<p>​	$RGB均取0-255$</p>
<p>$$<br>C&#x3D;V\times S<br>\X&#x3D;C\times(1-|(H&#x2F;60^\circ)mod\ 2-1|)<br>\m&#x3D;V-C\<br>(R’,G’,B’)&#x3D;\left{\begin{array}{}<br>(C,X,0)&amp;,0^\circ\leq H&lt;60^\circ\<br>(X,C,0)&amp;,60^\circ\leq H&lt;120^\circ\<br>(0,C,x)&amp;,120^\circ\leq H&lt;180^\circ\<br>(0,X,C)&amp;,180^\circ\leq H&lt;240^\circ\<br>(X,0,C)&amp;,240^\circ\leq H&lt;300^\circ\<br>(C,0,X)&amp;,300^\circ\leq H&lt;360^\circ\<br>\end{array}{}\right.<br>\(R,G,B)&#x3D;\frac{(R’+m,G’+m,B’+m)}{255}<br>$$<br>该式子理解如下：</p>
<p>将红(R),黄(Y),绿(G),青(M),蓝(B),品红(C),红(R)</p>
<p>均匀放在一条轴上，采用<strong>线性插值</strong>的方式画出色相,如图</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/%E8%89%B2%E5%BD%A9%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC2.png" alt="色彩线性插值2"></p>
<p>如图，横坐标分布$H$，纵坐标的最低值$V(1-S)$即是$m$，因为是线性插值计算，所以RGB呈折线式分布，根据图理解，可以如下改进原公式<br>$$<br>C&#x3D;V(最高阈值)\<br>m&#x3D;V(1-S)(最低阈值)\<br>在图像处理应用中提取图像亮部或暗部，若想要改变容差，则只需要改变阈值<br>\<br>X&#x3D;V\times S\times (1-|H&#x2F;60| mod 2-1)+m\(该式可以直接表达线性插值混合部分的折线（锯齿状线条）)<br>\(R,G,B)&#x3D;255\times \left{\begin{array}{}<br>(C,X,m)&amp;,0^\circ\leq H&lt;60^\circ\<br>(X,C,m)&amp;,60^\circ\leq H&lt;120^\circ\<br>(m,C,x)&amp;,120^\circ\leq H&lt;180^\circ\<br>(m,X,C)&amp;,180^\circ\leq H&lt;240^\circ\<br>(X,m,C)&amp;,240^\circ\leq H&lt;300^\circ\<br>(C,m,X)&amp;,300^\circ\leq H&lt;360^\circ\<br>\end{array}{}\right.<br>$$</p>
<h5 id="RGB-HSV"><a href="#RGB-HSV" class="headerlink" title="RGB-HSV"></a>RGB-HSV</h5><p>$$<br>R’,G’,B’&#x3D;\frac{R,G,B}{255}\<br>Cmax&#x3D;max(R,G,B)<br>\Cmin&#x3D;min(R,G,B)<br>\\Delta&#x3D;Cmax-Cmin<br>$$</p>
<p>$H(hue)$<br>$$<br>H&#x3D;\left{\begin{array}{}0^\circ&amp; \Delta &#x3D;0\60^\circ \times(\frac{G’-B’}{\Delta}mod\ 6)&amp;,Cmax&#x3D;R’\60^\circ \times(\frac{B’-R’}{\Delta}+2)&amp;,Cmax&#x3D;G’\60^\circ \times(\frac{R’-G’}{\Delta}+4)&amp;,Cmax&#x3D;B’\end{array}{}\right.<br>$$<br>$S(saturation)$<br>$$<br>S&#x3D;\left{\begin{array}{}0&amp;,Cmax&#x3D;0\\frac{\Delta}{Cmax}&amp;,Cmax\neq0\end{array}{}\right.<br>$$<br>$V(value)$<br>$$<br>V&#x3D;Cmax<br>$$</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul>
<li><p>色彩空间的定义</p>
<ul>
<li>基于CIE XYZ色彩空间，确定一定的色域、白点，以及特定的gamma采样方式，所决定出的色彩区域。</li>
</ul>
</li>
<li><p>人眼可见光范围</p>
<ul>
<li>390nm~760nm</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Qb4y1S7CC">https://www.bilibili.com/video/BV1Qb4y1S7CC</a> 【技术美术百人计划】图形 2.1 色彩空间介绍</p>
<p>[2] <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43280713/article/details/84133949">https://blog.csdn.net/weixin_43280713/article/details/84133949</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/freshair_cnblog/p/11493706.html">https://www.cnblogs.com/freshair_cnblog/p/11493706.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.1%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/" data-id="cmfe1u6pc001rscuhao8e6nbh" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.2模型与材质基础" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.2%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9D%90%E8%B4%A8%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形2-2模型与材质基础"><a href="#图形2-2模型与材质基础" class="headerlink" title="图形2.2模型与材质基础"></a>图形2.2模型与材质基础</h2><h3 id="一、渲染管线与模型基础"><a href="#一、渲染管线与模型基础" class="headerlink" title="一、渲染管线与模型基础"></a>一、渲染管线与模型基础</h3><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723154809728.png" alt="image-20220723154809728" style="zoom:80%;" />

<h4 id="uv"><a href="#uv" class="headerlink" title="uv"></a>uv</h4><p>在建模软件中完成UV展开，UV放置在一个横向u，纵向v，（0-1）的二维坐标系中</p>
<p>展开后的uv在sp等软件中绘制贴图</p>
<h4 id="模型信息"><a href="#模型信息" class="headerlink" title="模型信息"></a>模型信息</h4><p>模型的表达（以obj为例）</p>
<ul>
<li>v顶点坐标</li>
<li>vt对应纹理坐标 texcoord</li>
<li>vn顶点法线</li>
<li>f面</li>
<li>顶点色（fbx）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>#</strong></th>
<th><strong>obj格式</strong></th>
<th><strong>fbx格式</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>多个object</td>
<td>支持</td>
<td>支持</td>
<td>在文件中存放多个三维模型</td>
</tr>
<tr>
<td>单object拥有多个材质</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>Polygons面</td>
<td>支持</td>
<td>支持</td>
<td>易于被3ds max等软件编辑加工  注：导入到ue4时，必须为三角形面</td>
</tr>
<tr>
<td>Normal</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>Material</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>光滑组（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Smoothing_group">Smoothing Group</a>）</td>
<td>支持</td>
<td>支持</td>
<td>光滑组中的点或面使用平均法线来计算光照，使得整个mesh区域看起来更平滑</td>
</tr>
<tr>
<td>uv套数</td>
<td>1</td>
<td>多套</td>
<td></td>
</tr>
<tr>
<td>顶点Color</td>
<td>不支持</td>
<td>支持</td>
<td>导入ue4时，Vertex Color Import Option设置为Replace</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/zh-CN/Engine/Content/Importing/FBX/StaticMeshes/#%E9%9D%99%E6%80%81%E7%BD%91%E6%A0%BC%E4%BD%93lod">ue4 lod</a></td>
<td>不支持</td>
<td>支持</td>
<td>导入ue4时，勾选Import Mesh LODs</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/zh-CN/Engine/Content/Importing/FBX/StaticMeshes/#%E7%A2%B0%E6%92%9E">ue4 simple collision</a></td>
<td>支持</td>
<td>支持</td>
<td>任意凸体碰撞命名规则：UCX_[RenderMeshName]、UCX_[RenderMeshName]_00</td>
</tr>
<tr>
<td>socket插槽</td>
<td>不支持</td>
<td>支持</td>
<td>命名规则：SOCKET_[RenderMeshName]、SOCKET_[RenderMeshName]_01</td>
</tr>
<tr>
<td>skeleton骨骼</td>
<td>不支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>skeletal mesh网格</td>
<td>不支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>animation sequence</td>
<td>不支持</td>
<td>支持</td>
<td>fbx可在文件中存放多个动作序列</td>
</tr>
</tbody></table>
<h3 id="二、材质基础"><a href="#二、材质基础" class="headerlink" title="二、材质基础"></a>二、材质基础</h3><ul>
<li><p>材质</p>
<ul>
<li><p>描述物体对光的接收与散射</p>
</li>
<li><p>漫反射</p>
</li>
<li><p>镜面反射</p>
</li>
<li><p>折射</p>
<ul>
<li>菲涅尔定律可以描述反射与折射的比例</li>
</ul>
</li>
<li><p>粗糙镜面反射glossy（磨砂金属）</p>
</li>
<li><p>粗糙镜面折射（毛玻璃）</p>
</li>
<li><p>多层材质</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723160309345.png" alt="image-20220723160309345" style="zoom:50%;" />
</li>
<li><p>次表面散射（Subsurface scattering）</p>
<ul>
<li><p>光线传入物体内部后，经过多次弹射再离开物体表面</p>
</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723160453573.png" alt="image-20220723160453573" style="zoom:80%;" />
</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723160606384.png" alt="image-20220723160606384" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>改变材质表面</p>
<ul>
<li>使用法线贴图对法线做出调整，影响光照计算的结果</li>
</ul>
</li>
</ul>
<h3 id="三、模型数据解析"><a href="#三、模型数据解析" class="headerlink" title="三、模型数据解析"></a>三、模型数据解析</h3><ul>
<li><p>顶点动画</p>
<ul>
<li>在vs中改变模型的顶点位置，达到模型运动的效果</li>
<li>（需要一定数量的顶点，效果才比较明显）</li>
</ul>
</li>
<li><p>纹理动画</p>
<ul>
<li>在fs中修改模型uv信息，使采样贴图时发生位移而产生运动效果</li>
</ul>
</li>
<li><p>顶点色</p>
<ul>
<li>在渲染时影响输出结果，控制颜色范围</li>
<li>例：当前顶点色达到一定值，就认定为阴影中</li>
<li>片元当中使用重心坐标插值</li>
</ul>
</li>
<li><p>顶点法线与面法线</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723162706622.png" alt="image-20220723162706622" style="zoom: 67%;" />

<h3 id="四、扩展"><a href="#四、扩展" class="headerlink" title="四、扩展"></a>四、扩展</h3><p>NPR中，通常在vs中将顶点往法线方向偏移（模型背面），然后在fs中直接输出一个颜色，达到描边效果。</p>
<p>BackFacing描边时，线条断开就是因为没有平滑顶点之间的法线（面法线外扩），法线不连续导致的。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723162821829.png" alt="image-20220723162821829" style="zoom:80%;" />



<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h4 id="顶点色还可以做什么"><a href="#顶点色还可以做什么" class="headerlink" title="顶点色还可以做什么"></a>顶点色还可以做什么</h4><ul>
<li>在渲染上<ul>
<li>直接作为物体颜色</li>
<li>与贴图颜色混合。</li>
<li>取代一些光照：如教程中罪恶装备案例对阴影的处理</li>
</ul>
</li>
<li>其他应用<ul>
<li>不直接用于渲染，正如贴图，顶点色还可以储存其他信息、属性</li>
</ul>
</li>
</ul>
<h4 id="模型光滑组对法线有什么影响"><a href="#模型光滑组对法线有什么影响" class="headerlink" title="模型光滑组对法线有什么影响"></a>模型光滑组对法线有什么影响</h4><p>首先要知道什么是光滑组，这其实也是我第一次见这个名词。</p>
<p>光滑组：（smoothing group）是用来设置边缘线的光滑显示的。</p>
<p>光滑组定义了模型边缘渲染的方式（flat shading和Gouraud&#x2F;Phong shading），也就是101中所说的着色频率（Shading frequencies）</p>
<p>这也就控制了所说的边缘“软硬”</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/20210720084550788.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p>那这样回答这个问题就很简单了</p>
<p>Flat shading使用的是面法线；gouraud shading使用的是顶点法线；在vs中计算顶点着色，片元对颜色插值；phong shading使用顶点法线，片元上对法线插值后，在fs中计算光照。</p>
<p>光滑组所做的也就是决定模型哪些部分采用法线插值</p>
<p>因此光滑组的作用也很有趣，让一个模型的着色方式不同，来表现同一模型的不同细节。</p>
<h5 id="过渡部分"><a href="#过渡部分" class="headerlink" title="过渡部分"></a>过渡部分</h5><p>尝试了Maya中对应的“软硬边”功能，因为非常值得思考的是，在光滑组与非光滑组的过渡部分如何处理？</p>
<center>
<figure>
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723175542376.png" alt="image-20220723175542376" style="width: 30%;display:inline;margin:0" />
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723175557394.png" alt="image-20220723175557394" style="width: 34%;display:inline;margin:0" />
</figure>
</center>









<p>我们来研究这里的细节。首先对于完整的硬边三角形和软边三角形不必说。</p>
<p>对于硬边三角形的顶点法线，就是面法线，因此，4个硬边相接的顶点上，出现了4个顶点法线，分别是用1256这四个面法线代替的。关注2354这里的顶点法线，只有完整的硬边面5，还保持着面法线，</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723180155081.png" alt="image-20220723180155081" style="zoom:50%;" />

<p>我尝试对这个顶点剩余的硬边进行软化，观察这个顶点法线是否变化</p>
<center>
    <figure>
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723180950650.png" alt="image-20220723180950650" style="width:40%;display:inline;margin:0" />
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723181006044.png" alt="image-20220723181006044" style="width:40%;display:inline;margin:0" />
    </figure>
</center>

<p>出现明显的偏移，因此可以得出结论</p>
<p>软边会使相邻两个面的面法线进行插值得到一个顶点法线。</p>
<p>像这里4条边，只需要3条软边，就完成了周围四个面法线（其实是面法线所代替的4个顶点法线）的插值得到的顶点法线，这和4条软边是一样的。</p>
<center>
    <figure>
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723182303248.png" alt="image-20220723182303248" style="width:34%;display:inline;margin:0" />
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723182545394.png" alt="image-20220723182545394" style="width:40%;display:inline;margin:0" />
    </figure>
</center>

<p>研究了半天，放了个最简单的例子，其实就理解为软边会使相邻两个面法线插值好了</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220723185549252.png" alt="image-20220723185549252"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kh411U7F7">https://www.bilibili.com/video/BV1kh411U7F7</a> 【技术美术百人计划】图形 2.2 模型与材质基础</p>
<p>[2]<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a> GAMES101-现代计算机图形学入门-闫令琪</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.2%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9D%90%E8%B4%A8%E5%9F%BA%E7%A1%80/" data-id="cmfe1u6pc001tscuh36tzecju" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.3常用函数介绍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.3%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="图形2-3-常用函数介绍（HLSL）"><a href="#图形2-3-常用函数介绍（HLSL）" class="headerlink" title="图形2.3 常用函数介绍（HLSL）"></a>图形2.3 常用函数介绍（HLSL）</h1><p>微软文档HLSL内部函数：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions">https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions</a></p>
<h3 id="一、基本数学运算"><a href="#一、基本数学运算" class="headerlink" title="一、基本数学运算"></a>一、基本数学运算</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(a,b)<span class="comment">//最大值</span></span><br><span class="line"><span class="built_in">min</span>(a,b)<span class="comment">//最小值</span></span><br><span class="line">mul(a,b)<span class="comment">//变量相乘，矩阵、向量运算（a是向量则看作行向量，b是向量则看作列向量）</span></span><br><span class="line"><span class="built_in">abs</span>(a)<span class="comment">//绝对值</span></span><br><span class="line"><span class="built_in">round</span>(x)<span class="comment">//最接近的整数</span></span><br><span class="line"><span class="built_in">sqrt</span>(x)<span class="comment">//平方根</span></span><br><span class="line">rsqrt(x)<span class="comment">//平方根倒数</span></span><br><span class="line"><span class="built_in">degrees</span>(x)<span class="comment">//弧度转角度</span></span><br><span class="line">redians(x)<span class="comment">//角度转弧度</span></span><br><span class="line">noise(x)<span class="comment">//噪声函数</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/XirtyqUXBhtPF1TVBTHfSA" alt="img" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/PoFwPqTWyla31R3yk3012w" alt="img" style="zoom:50%;" />

<h3 id="二、幂指对函数"><a href="#二、幂指对函数" class="headerlink" title="二、幂指对函数"></a>二、幂指对函数</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pow</span>(x,y);<span class="comment">//x^y</span></span><br><span class="line"><span class="built_in">exp</span>(x);<span class="comment">//e^x</span></span><br><span class="line"><span class="built_in">exp2</span>(x);<span class="comment">//2^x</span></span><br><span class="line"><span class="built_in">ldexp</span>(x, <span class="built_in">exp</span>);<span class="comment">//x*2^exp</span></span><br><span class="line"><span class="built_in">log</span>(x);<span class="comment">//lnx</span></span><br><span class="line">log10(x);<span class="comment">//log_10 x</span></span><br><span class="line"><span class="built_in">log2</span>(x);<span class="comment">//log_2 x</span></span><br><span class="line"><span class="built_in">frexp</span>(x, <span class="keyword">out</span> <span class="built_in">exp</span>);<span class="comment">//把浮点数x分解为尾数mantissa和指数 x = ret * 2^exp，返回值是位数，exp参数返回的值是指数（如果x参数为0，则尾数和指数均返回0）</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/_yUmM743gYLSz4W_MD43_A" alt="img" style="zoom:50%;" />

<h3 id="三、三角函数与双曲函数"><a href="#三、三角函数与双曲函数" class="headerlink" title="三、三角函数与双曲函数"></a>三、三角函数与双曲函数</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sin</span>(x);<span class="built_in">cos</span>(x);<span class="built_in">tan</span>(x);<span class="comment">//x均为弧度</span></span><br><span class="line">sincos(x, <span class="keyword">out</span> s, <span class="keyword">out</span> c);<span class="comment">//返回x的正弦值和余弦值</span></span><br><span class="line"><span class="built_in">tan</span>(y,x);<span class="comment">//返回y/x的正切值</span></span><br><span class="line"><span class="built_in">asin</span>(x);<span class="comment">//反正弦</span></span><br><span class="line"><span class="built_in">acos</span>(x);<span class="comment">//反余弦</span></span><br><span class="line"><span class="built_in">atan</span>(x);<span class="comment">//反正切</span></span><br><span class="line">atan2(y,x);<span class="comment">//输出y/x的反正切</span></span><br><span class="line"><span class="built_in">sinh</span>(x);<span class="comment">//双曲正弦,(e^x-e^(-x))/2</span></span><br><span class="line"><span class="built_in">cosh</span>(x);<span class="comment">//双曲余弦,(e^x+e^(-x))/2</span></span><br><span class="line"><span class="built_in">tanh</span>(x);<span class="comment">//双曲正切,(e^x-e^(-x))/(e^x+e^(-x))</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/-LFsB20otdFaLNoYINhjAw" alt="img" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/Vg17wEEh7tRZ3NIyopuNxA" alt="img" style="zoom:50%;" />

<h3 id="四、数据范围类"><a href="#四、数据范围类" class="headerlink" title="四、数据范围类"></a>四、数据范围类</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ceil</span>(x);<span class="comment">//向上取整</span></span><br><span class="line"><span class="built_in">floor</span>(x);<span class="comment">//向下取整</span></span><br><span class="line"><span class="built_in">step</span>(x,y);<span class="comment">//x&lt;=y为1，否则为0</span></span><br><span class="line">saturate(x);<span class="comment">//返回将x钳制到0和1之间的值</span></span><br><span class="line"><span class="built_in">clamp</span>(x,<span class="built_in">min</span>,<span class="built_in">max</span>);<span class="comment">//把x限制在[min,max]范围内，</span></span><br><span class="line">fmord(x,y);<span class="comment">//返回x对y取余的余数</span></span><br><span class="line">frac(x);<span class="comment">//返回x的小数部分</span></span><br><span class="line"><span class="built_in">modf</span>(x, <span class="keyword">out</span> ip);<span class="comment">//将x分为小数和整数部分（符号与x相同），ip返回整数部分，整体返回小数部分</span></span><br><span class="line">lerp(x,y,s);<span class="comment">//按照s在x到y之间插值（x*(1-s)+y*s）</span></span><br><span class="line"><span class="built_in">smoothstep</span>(<span class="built_in">min</span>,<span class="built_in">max</span>,x);<span class="comment">//如果x在min和max范围内，则返回01之间的平滑Hermite插值，使用smoothstep在两个值之间创建平滑过渡。例如平滑混合两种颜色</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/cSnp8bVk3apu9oljyC2FfA" alt="img" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/SYF5uMwuuk_PaEZ6aR3G_Q" alt="img" style="zoom:50%;" />

<h3 id="五、类型判断类"><a href="#五、类型判断类" class="headerlink" title="五、类型判断类"></a>五、类型判断类</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">all</span>(x);<span class="comment">//确定x所有分量是否均为非零，均非零则返回true，否则false（处理浮点型、整形、布尔型数据定义的标量、向量或矩阵）</span></span><br><span class="line">clip(x);<span class="comment">//如果x小于零，则丢弃当前像素，常用于判定范围（不仅针对0，返回值为void）。常用于测试alpha，如果每个分量代表到平面距离，还可用来模拟剪切平面</span></span><br><span class="line"><span class="built_in">sign</span>(x);<span class="comment">//返回x正负性，小于0为-1，大于0为1，0则返回0</span></span><br><span class="line"><span class="built_in">isinf</span>(x);<span class="comment">//x为+INF或-INF则为true，否则false</span></span><br><span class="line">isfinite(x);<span class="comment">//判断x是有限的，与isinf相反</span></span><br><span class="line"><span class="built_in">isnan</span>(x);<span class="comment">//如果x为NAN(非数字),返回true，否则false</span></span><br></pre></td></tr></table></figure>

<h3 id="六、向量与矩阵类"><a href="#六、向量与矩阵类" class="headerlink" title="六、向量与矩阵类"></a>六、向量与矩阵类</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">length</span>(v);<span class="comment">//向量模长</span></span><br><span class="line"><span class="built_in">normalize</span>(v);<span class="comment">//x/length(x)归一化</span></span><br><span class="line"><span class="built_in">distance</span>(a,b);<span class="comment">//向量之间的距离（表示的点的距离）</span></span><br><span class="line"><span class="built_in">dot</span>(a,b);<span class="comment">//点乘</span></span><br><span class="line"><span class="built_in">cross</span>(a,b);<span class="comment">//叉乘</span></span><br><span class="line"><span class="built_in">determinant</span>(m);<span class="comment">//矩阵m的行列式</span></span><br><span class="line"><span class="built_in">transpose</span>(m);<span class="comment">//m的转置矩阵</span></span><br></pre></td></tr></table></figure>

<h3 id="七、光线运算"><a href="#七、光线运算" class="headerlink" title="七、光线运算"></a>七、光线运算</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意所有的入射方向都表示入射方向的相反方向</span></span><br><span class="line"><span class="built_in">reflect</span>(i,n);<span class="comment">//计算入射方向i对于法线n的反射方向</span></span><br><span class="line">fefract(i,n,ri);<span class="comment">//入射方向i，法线n，ri折射率，计算折射方向</span></span><br><span class="line">lit(n_dot_l,n_dot_h,m);<span class="comment">//返回照明系数向量(ambient,diffuse,specular,1)</span></span><br><span class="line"><span class="comment">//ambient=1</span></span><br><span class="line"><span class="comment">//diffuse = ndotl&lt;0 ? 0 : ndotl</span></span><br><span class="line"><span class="comment">//specular = ndotl&lt;0 || ndoth &lt; 0 ? 0: ndoth^m</span></span><br><span class="line"><span class="built_in">faceforward</span>(n,i,ng);<span class="comment">//输出法线n，输入视线方向i，表面法线方向ng，反转表面法线（如有必要）以面向和i相反的方向，在n中返回结果</span></span><br><span class="line"><span class="comment">//返回-n*sign(dot(i,ng))</span></span><br></pre></td></tr></table></figure>

<h3 id="八、1D纹理查找（几乎不用）"><a href="#八、1D纹理查找（几乎不用）" class="headerlink" title="八、1D纹理查找（几乎不用）"></a>八、1D纹理查找（几乎不用）</h3><p>函数ddx，ddy用于求取相邻像素间某属性的差值；输入参数通常是纹理坐标，返回相邻像素间的属性差值；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tex1D(s,t);<span class="comment">//一维纹理查找，返回纹理采样器s在标量t位置的color4</span></span><br><span class="line">tex1D(s,t,ddx,ddy);<span class="comment">//微分查询一维纹理ddx,ddy均为向量</span></span><br><span class="line">tex1Dlod(s,t);<span class="comment">//使用LOD查找纹理s在t.w位置的color4</span></span><br><span class="line">tex1Dbias(s,t);<span class="comment">//t.w决定的某个mip层偏置后的一维纹理查找</span></span><br><span class="line">tex1Dgrad(s,t,ddx,ddy);<span class="comment">//使用微分并指定mip层的一维纹理查找</span></span><br><span class="line">tex1Dproj(s,t);<span class="comment">//把纹理当作一张幻灯片投影到场景中，计算出投影纹理坐标t(t.w除以透视值),然后使用投影纹理坐标查询</span></span><br></pre></td></tr></table></figure>

<h3 id="九、2D纹理查找"><a href="#九、2D纹理查找" class="headerlink" title="九、2D纹理查找"></a>九、2D纹理查找</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tex2D(s,t);<span class="comment">//二维纹理查找，返回纹理采样器s在t(x,y)位置的color4</span></span><br><span class="line">tex2D(s,t,ddx,ddy);<span class="comment">//微分查询二维纹理t,ddx,ddy均为向量</span></span><br><span class="line">tex2Dlod(s,t);<span class="comment">//使用LOD查找纹理s在t.w位置的color4</span></span><br><span class="line">tex2Dbias(s,t);<span class="comment">//t.w决定的某个mip层偏置后的二维纹理查找</span></span><br><span class="line">tex2Dgrad(s,t,ddx,ddy);<span class="comment">//使用微分并指定mip层的二维纹理查找</span></span><br><span class="line">tex2Dproj(s,t);<span class="comment">//把纹理当作一张幻灯片投影到场景中，计算出投影纹理坐标t(t.w除以透视值),然后使用投影纹理坐标查询</span></span><br></pre></td></tr></table></figure>

<h3 id="十、3D纹理查找"><a href="#十、3D纹理查找" class="headerlink" title="十、3D纹理查找"></a>十、3D纹理查找</h3><p>3D纹理资源（体积纹理），包含3D体积的纹理像素</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tex3D(s,t);<span class="comment">//三维纹理查找，返回纹理采样器s在vec t位置的color4</span></span><br><span class="line">tex3D(s,t,ddx,ddy);<span class="comment">//微分查询三维纹理t,ddx,ddy均为向量</span></span><br><span class="line">tex3Dlod(s,t);<span class="comment">//使用LOD查找纹理s在t.w位置的color4</span></span><br><span class="line">tex3Dbias(s,t);<span class="comment">//t.w决定的某个mip层偏置后的立方体纹理查找</span></span><br><span class="line">tex3Dgrad(s,t,ddx,ddy);<span class="comment">//使用微分并指定mip层的立方体纹理查找</span></span><br><span class="line">tex3Dproj(s,t);<span class="comment">//使用投影方式的立方体文里查找</span></span><br></pre></td></tr></table></figure>

<h3 id="十一、立体纹理查找"><a href="#十一、立体纹理查找" class="headerlink" title="十一、立体纹理查找"></a>十一、立体纹理查找</h3><p>指CubeMap</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">texCUBE(s,t);<span class="comment">//返回纹理采样器s在vec t位置的color4</span></span><br><span class="line">texCUBE(s,t,ddx,ddy);<span class="comment">//微分查询立方体纹理t,ddx,ddy均为向量</span></span><br><span class="line">texCUBElod(s,t);<span class="comment">//使用LOD查找纹理s在t.w位置的color4</span></span><br><span class="line">texCUBEbias(s,t);<span class="comment">//t.w决定的某个mip层偏置后的三维纹理查找</span></span><br><span class="line">texCUBEgrad(s,t,ddx,ddy);<span class="comment">//使用微分并指定mip层的三维纹理查找</span></span><br><span class="line">texCUBEproj(s,t);<span class="comment">//把纹理当作一张幻灯片投影到场景中，计算出投影纹理坐标t(t.w除以透视值),然后使用投影纹理坐标查询</span></span><br></pre></td></tr></table></figure>

<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><ul>
<li>写出最常用的5个函数<ul>
<li>dot，mul，normalize，tex2d，pow</li>
</ul>
</li>
<li>这是我当前感觉最常用的，dot和mul不必说，向量矩阵运算必备；而由于光照计算中使用方向，常常需要对向量归一化；有贴图就有纹理采样；最后这个pow方法，看看各种光照模型的公式里，就有很多地方出现幂运算了。</li>
<li>ddx ddy的实际使用测试</li>
</ul>
<h4 id="ddx-ddy与法线贴图"><a href="#ddx-ddy与法线贴图" class="headerlink" title="ddx&#x2F;ddy与法线贴图"></a><strong>ddx&#x2F;ddy与法线贴图</strong></h4><h5 id="ddx-ddy计算法线"><a href="#ddx-ddy计算法线" class="headerlink" title="ddx&#x2F;ddy计算法线"></a><strong>ddx&#x2F;ddy计算法线</strong></h5><p>首先ddx与ddy是两个函数，完整的表达是ddx(m),ddy(m)。</p>
<p>在glsl中，它相当于dFdx(m),dFdy(m)。</p>
<p>这两个函数只能作用于片元着色器中，根据他们的作用也很好理解这一点。</p>
<p>我们需要提供一个属性，然后这个函数会计算当前片元在屏幕空间中，沿x或y方向关于这个属性的偏导，因为片元是离散的，当然是以差分形式。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/6271001-7e5f13306d7c9131.png" alt="img" style="zoom: 33%;" />

<p>如果是考虑<strong>世界空间位置</strong>这一属性，我的理解是，对于当前着色点，计算的是这两个方向的切线方向。</p>
<p>于是有一个通常的法线计算方法</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normal = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(ddx(pos),ddy(pos)));</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220728230748527.png" alt="image-20220728230748527"></p>
<p>左边是ddx，ddy计算出的法线，右边是顶点法线在fs中插值的法线。</p>
<p>很明显，这两者就好像flat shading和phong shading的关系。仔细想想确实如此。不考虑着色，只考虑几何信息，这个球体本来就是三角网格</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220728230953252.png" alt="image-20220728230953252"></p>
<p>对于三角形上的一个点的法线，使用切线叉乘计算的法线当然是原原本本的网格法线。而右边的法线是顶点法线插值。</p>
<p>在unity中还原flat shading或是low poly风格的渲染，确实会采用ddx和ddy的方法。</p>
<h5 id="ddx-ddy与法线贴图-1"><a href="#ddx-ddy与法线贴图-1" class="headerlink" title="ddx&#x2F;ddy与法线贴图"></a><strong>ddx&#x2F;ddy与法线贴图</strong></h5><p>learnopengl中这一段代码给我留下了深刻印象。当时用的时候完全不知道dFdx是做什么的，只能硬着头皮用了。现在我们已经了解了ddx函数，再回过头来看一下它对发现贴图的处理。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Easy trick to get tangent-normals to world-space to keep PBR code simplified.</span></span><br><span class="line"><span class="comment">// Don&#x27;t worry if you don&#x27;t get what&#x27;s going on; you generally want to do normal </span></span><br><span class="line"><span class="comment">// mapping the usual way for performance anways; I do plan make a note of this </span></span><br><span class="line"><span class="comment">// technique somewhere later in the normal mapping tutorial.</span></span><br><span class="line"><span class="type">vec3</span> getNormalFromMap()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> tangentNormal = <span class="built_in">texture</span>(normalMap, TexCoords).xyz * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> Q1  = <span class="built_in">dFdx</span>(WorldPos);</span><br><span class="line">    <span class="type">vec3</span> Q2  = <span class="built_in">dFdy</span>(WorldPos);</span><br><span class="line">    <span class="type">vec2</span> st1 = <span class="built_in">dFdx</span>(TexCoords);</span><br><span class="line">    <span class="type">vec2</span> st2 = <span class="built_in">dFdy</span>(TexCoords);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> N   = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> T  = <span class="built_in">normalize</span>(Q1*st2.t - Q2*st1.t);</span><br><span class="line">    <span class="type">vec3</span> B  = -<span class="built_in">normalize</span>(<span class="built_in">cross</span>(N, T));</span><br><span class="line">    <span class="type">mat3</span> TBN = <span class="type">mat3</span>(T, B, N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>(TBN * tangentNormal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心就是求TBN矩阵嘛。N向量和B向量都很好理解，一个直接就是模型法线，一个就是由叉乘计算的副切线。</p>
<p>问题就在于切线的计算。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> T  = <span class="built_in">normalize</span>(Q1*st2.t - Q2*st1.t);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/normal_mapping_surface_edges.png" alt="img"></p>
<p>（这里把E1看作Q1，E2看作Q2）</p>
<p>$E_1&#x3D;ΔU_1T+ΔV_1B$</p>
<p>$E_2&#x3D;ΔU_2T+ΔV_2B$</p>
<p>这样再结合cpu计算TBN的方法，就很好理解了。</p>
<p>似乎后面的课程马上就会到法线贴图的部分，到时候再详述好了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1q64y1m7Ev">https://www.bilibili.com/video/BV1q64y1m7Ev</a> 【技术美术百人计划】图形 2.3 常用函数介绍</p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7fc6a2fef29d">https://www.jianshu.com/p/7fc6a2fef29d</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/1.2.lighting_textured/1.2.pbr.fs">https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/1.2.lighting_textured/1.2.pbr.fs</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/">https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484182779">https://zhuanlan.zhihu.com/p/484182779</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.3%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/" data-id="cmfe1u6pe001vscuh7mao9yie" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形2.4 传统经验光照模型" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.4%20%E4%BC%A0%E7%BB%9F%E7%BB%8F%E9%AA%8C%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2025-09-10T13:18:14.022Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形2-4-传统经验光照模型"><a href="#图形2-4-传统经验光照模型" class="headerlink" title="图形2.4 传统经验光照模型"></a>图形2.4 传统经验光照模型</h2><ul>
<li>经验模型</li>
</ul>
<p>对真实光照的模拟，简化了真实光照的计算，并且有不错的效果</p>
<ul>
<li>基于物理理论的光照模型</li>
</ul>
<p>使用物理的度量和统计方法，效果非常真实，但是计算困难，实现也较困难</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220727115123646.png" alt="image-20220727120611504"></p>
<h3 id="一、局部光照模型"><a href="#一、局部光照模型" class="headerlink" title="一、局部光照模型"></a><strong>一、局部光照模型</strong></h3><p>只关心直接光照部分</p>
<h4 id="1-1-Lambert余弦定律"><a href="#1-1-Lambert余弦定律" class="headerlink" title="1.1 Lambert余弦定律"></a><strong>1.1 Lambert余弦定律</strong></h4><p>光源每秒发出的能量为辐射通量$P$</p>
<p>单位面积接受的光照为辐射通量密度（辐照度）$P&#x2F;A$</p>
<p>当光源垂直照射的单位面积的辐照度为$E_1 &#x3D; P&#x2F;A_1$</p>
<p>当光束以某个角度照射到面积更大的平面上的辐射度为$E_2&#x3D;P&#x2F;A_2&#x3D;P\cos\theta&#x2F;A_1&#x3D;E_1\cos\theta$</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220727120541155.png" alt="image-20220727120541155"></p>
<h4 id="1-2-漫反射"><a href="#1-2-漫反射" class="headerlink" title="1.2 漫反射"></a><strong>1.2 漫反射</strong></h4><p>光线照射到模型表面时被均匀反射到各个方向<br>$$<br>C_{diffuse} &#x3D; C_{light}<em>albedo</em>ndotL<br>$$</p>
<h4 id="1-3-镜面反射-高光反射"><a href="#1-3-镜面反射-高光反射" class="headerlink" title="1.3 镜面反射(高光反射)"></a><strong>1.3 镜面反射(高光反射)</strong></h4><p>光线到达物体表面发生镜面反射，观察视线在反射光线的附近便能够观察到镜面反射。</p>
<p>镜面反射的反射率是根据菲涅尔效应决定的。</p>
<p>通常使用对应的反射贴图描述物体表面的反射率，并使用光泽度（粗糙度，反光度）描述高光范围的大小<br>$$<br>C_{specular}&#x3D;C_{lgiht}*m_{specular}<em>dot(v,r)^m<br>\r&#x3D;1-2ndotL</em>n<br>$$</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220727120611504.png" alt="image-20220727120611504"></p>
<h4 id="1-4-环境光"><a href="#1-4-环境光" class="headerlink" title="1.4 环境光"></a><strong>1.4 环境光</strong></h4><p>在局部光照模型中，没有考虑间接光照的影响，为了处理间接光照，引入Ambient环境光<br>$$<br>C_{ambient}&#x3D;Albedo*Ambient<br>$$<br>通常使用漫反射的反照率来指示环境光照的反射光量。（只计算了环境光照的漫反射）</p>
<h4 id="1-5-自发光"><a href="#1-5-自发光" class="headerlink" title="1.5 自发光"></a><strong>1.5 自发光</strong></h4><p>通常作为单独的一项加入光照模型，一般使用一张发光贴图描述物体自发光</p>
<h3 id="二、经典光照模型"><a href="#二、经典光照模型" class="headerlink" title="二、经典光照模型"></a>二、经典光照模型</h3><h4 id="2-1-Lambert光照模型"><a href="#2-1-Lambert光照模型" class="headerlink" title="2.1 Lambert光照模型"></a><strong>2.1 Lambert光照模型</strong></h4><p>理想漫反射<br>$$<br>L_o &#x3D; C_{diffuse}&#x3D;  C_{light}<em>albedo</em>ndotL<br>$$</p>
<h4 id="2-2-Phong光照模型"><a href="#2-2-Phong光照模型" class="headerlink" title="2.2  Phong光照模型"></a><strong>2.2  Phong光照模型</strong></h4><p>ambient环境光+lambert漫反射+高光<br>$$<br>L_o&#x3D;C_{ambient}+C_{diffuse}+C_{specular}\&#x3D;albedo<em>Ambient + C_{light}</em>(albedo*ndotL+m_{specular}*dot(v,r)^m )<br>$$</p>
<h4 id="2-3-Blinn-Phong光照模型"><a href="#2-3-Blinn-Phong光照模型" class="headerlink" title="2.3 Blinn-Phong光照模型"></a><strong>2.3 Blinn-Phong光照模型</strong></h4><p>在phong光照模型的基础上，使用ndotH代替vdotR<br>$$<br>h&#x3D;normalize(l+r)\<br>L_o&#x3D;C_{ambient}+C_{diffuse}+C_{specular}\&#x3D;albedo<em>Ambient + C_{light}</em>(albedo*ndotL+m_{specular}*dot(n,h)^m )<br>$$</p>
<h3 id="三、着色方法"><a href="#三、着色方法" class="headerlink" title="三、着色方法"></a><strong>三、着色方法</strong></h3><p>着色方法，或者说着色模型，跟光照模型没有任何关系</p>
<h4 id="3-1-Flat着色方法"><a href="#3-1-Flat着色方法" class="headerlink" title="3.1 Flat着色方法"></a><strong>3.1 Flat着色方法</strong></h4><p>面着色，顾名思义以每一个面作为一个着色单位。模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/Flat%20Shading.png" alt="Flat Shading"></p>
<p>改进方法：改进方法就是对三角形面的每个顶点进行着色，再对三角形面内的颜色插值，即Gouraud Shading。</p>
<h4 id="3-2-Gouraud着色方法-几乎不用"><a href="#3-2-Gouraud着色方法-几乎不用" class="headerlink" title="3.2 Gouraud着色方法(几乎不用  )"></a><strong>3.2 Gouraud着色方法(几乎不用  )</strong></h4><p>顶点着色，片元着色通过顶点颜色插值</p>
<h4 id="3-3-Phong着色方法"><a href="#3-3-Phong着色方法" class="headerlink" title="3.3 Phong着色方法"></a><strong>3.3 Phong着色方法</strong></h4><p>求出三角形顶点法向，法向插值得到三角形内部每个片元的法向，精确计算着色。</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a><strong>作业</strong></h3><h4 id="1-学习先行版-基础渲染光照介绍（一），并说出能量守恒的理念在基础光照模型中的作用。"><a href="#1-学习先行版-基础渲染光照介绍（一），并说出能量守恒的理念在基础光照模型中的作用。" class="headerlink" title="1.学习先行版 基础渲染光照介绍（一），并说出能量守恒的理念在基础光照模型中的作用。"></a>1.学习先行版 基础渲染光照介绍（一），并说出能量守恒的理念在基础光照模型中的作用。</h4><p>在光照模型当中，我们考虑不同的光源类型：环境光照（间接光照）与直接光照，将它们分开看待。实际上它们都是全局光照的一部分，我愿称之为“全局能量守恒 ”。</p>
<p>而对于某种光源，也有对于其本身的能量守恒，我愿称之为“局部能量守恒”。</p>
<p>那么局部能量守恒在光照模型中的表现其实就是<br>$$<br>入射光能量&#x3D;反射光能量 + 表面吸收能量<br>$$</p>
<h4 id="2-基于能量守恒的理念，自己写一套完整的光照模型，需要包含环境光照。"><a href="#2-基于能量守恒的理念，自己写一套完整的光照模型，需要包含环境光照。" class="headerlink" title="2.基于能量守恒的理念，自己写一套完整的光照模型，需要包含环境光照。"></a>2.基于能量守恒的理念，自己写一套完整的光照模型，需要包含环境光照。</h4><p>对于这个作业我的理解是，使用能量守恒的思想去改进传统光照模型 ，而不是直接实现一个cook-torrance模型。</p>
<h5 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a><strong>环境光照</strong></h5><p>那么首先来做一下环境光照，不妨来试一下cubeMap做的环境光。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texCUBElod(_CubeMap, float4(normal,<span class="number">0.0</span>));</span><br></pre></td></tr></table></figure>

<p> 严格上的IBL，也是要分成漫反射和镜面反射两部分</p>
<p>但是为了简化，就只取漫反射好了，</p>
<p>因为是第一次使用这个功能，在cubemap这里卡了一会儿。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729233520909.png" alt="image-20220729233520909" style="zoom:50%;" />

<p>这里对于卷积方式很自然地选择漫反射，并且按理来说，漫反射也不需要mip，于是我就关掉了生成Mip贴图选项，但是这样得到的贴图是错误的。只能把这个选项开启才是正常的。下面同样是第一级的mipmap，可以观察到漫反射和镜面反射的卷积结果还是有所区别的。</p>
<center>
    <figure>
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729233752792.png" alt="image-20220729233752792" style="width:40%;display:inline" />
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729233806108.png" alt="image-20220729233806108" style="width:40%;display:inline" />
    </figure>
</center>







<p>但是漫反射的卷积为什么要做mipmap呢？（不做的话结果是错的，不管什么卷积类型，除非是None）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729234005976.png" alt="image-20220729234005976" style="zoom:50%;" />

<p>以及这个mipmap的生成方式是什么呢？</p>
<p>查了下文档</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220729235546954.png" alt="image-20220729235546954"></p>
<p>也就是说，Convolution的结果是 储存在mipmap里的，所以不开mipmap就会出错。</p>
<p>但是依然没有解决的问题是，&#x3D;&#x3D;对于diffuse来说，mipmap是怎么生成的？&#x3D;&#x3D;</p>
<p>这个问题，只能暂时先放一放了，当前的猜想是，这个diffuse并非理想漫反射，而是按照采样的区域去控制mipmap，0层级当然就只有法线方向，最高层级就是理想漫反射。</p>
<p>对于作业来说，就取一个层级的漫反射卷积环境光照好了</p>
<p>但是值得注意的是，在漫反射部分有一个小细节，无论是环境光还是直接光照。<br>$$<br>L_o(v) &#x3D; f_d\int_{l\in\Omega}L_i(l)\cos\theta dl<br>\ &#x3D; f_dL_i\int_{i\in\Omega}\cos\theta dl<br>\ &#x3D; \pi f_dL_i ,\pi f_d\in[0,1]<br>\f_d &#x3D; \frac{albedo}{\pi},albedo \in[0,1]<br>$$<br>这需要区别开albedo和漫反射的brdf，有这个pi的区别，因此我们才能直接用albedo*L_i</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 indirect_irradiance = texCUBElod(_CubeMap, float4(normal,<span class="number">1.0</span>));</span><br><span class="line">float3 indirect_diffuse = indirect_irradiance * albedo;</span><br></pre></td></tr></table></figure>

<h5 id="直接光照"><a href="#直接光照" class="headerlink" title="直接光照"></a><strong>直接光照</strong></h5><p>这部分就要考虑blinn-phong模型的改进了。</p>
<p>我们还是直接看渲染方程<br>$$<br>\int_{\Omega^+}f_rL_i\cos\theta d\theta\<br>&#x3D;\int_{\Omega^+}(f_d+f_s)L_i\cos\theta d\theta\<br>&#x3D;\int_{\Omega^+}f_dL_i\cos\theta d\theta+\int_{\Omega^+}f_sL_i\cos\theta d\theta<br>$$<br>这样将brdf拆开了两部分。</p>
<p>在这个过程中，看起来好像没有什么问题，但是这需要关系到如何定义这个f_d，f_s。问题的本质还是漫反射光和镜面反射光的关系，更深入的数学推导也许应该回归到BRDF的函数本质，或者说散射函数，暂时就不去研究了。总之，在这里的表达中，就是反射的光一部分进行了漫反射，一部分进行了高光反射。但是它们的总能量，等于反射光的能量。</p>
<p>在learnopengl中的表达，就是</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> kS = calculateSpecularComponent(...); <span class="comment">// 反射/镜面 部分</span></span><br><span class="line"><span class="type">float</span> kD = <span class="number">1.0</span> - ks;                        <span class="comment">// 折射/漫反射 部分</span></span><br></pre></td></tr></table></figure>

<p>我们可以理解为把这两个比例分配给了光的能量，也可以直接认为 这是属于BRDF的一部分。</p>
<p>就不说cook-torrance了，总之我们先人为提供一个因子。glossy好像是个不错的选择。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 kd = (<span class="number">255.0</span> - _Gloss)/<span class="number">255.0</span>;</span><br><span class="line">fixed3 color = indirect_diffuse * _EnvScale + diffuse * kd  + specular * (<span class="number">1</span>-kd);</span><br></pre></td></tr></table></figure>

<p>漫反射的部分依然和上面一样</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>((<span class="built_in">dot</span>(normal, LightDir)),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>而对于高光部分。要说它能量守不守恒，也不太好衡量，毕竟能量小于入射能量就行了。无论小多少，它都是一种材质。所以就放在这里不管了。<br>$$<br>C_{light}*m_{specular}*ndotH^m<br>$$</p>
<center>
<figure>
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730013111824.png" alt="image-20220730013111824" style="width:28.9%;display:inline" />
    <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730013248302.png" alt="image-20220730013248302" style="width:30%;display:inline" />
    </figure>
</center>







<p>但是这个模型的缺陷在于可以调整的参数太少了，不能表达足够多的材质，最直接的改进部分是对于kd的选择，</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> kd = (<span class="number">255.0</span> - _Gloss)/<span class="number">255.0</span>;</span><br><span class="line">kd = <span class="built_in">pow</span>(kd,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>我们对kd做一些映射，就能够使得在同样的光滑度下，高光的能量占比更大（降低增加gloss减少高光范围的趋势），或者其实就干脆换一个参数来控制kd</p>
<center>
    <figure>
    	<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730014709778.png" alt="image-20220730014709778" style="width:40%;display:inline" />
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220730014811460.png" alt="image-20220730014811460" style="width:38.2%;display:inline" />
    </figure>
</center>





<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>调参差不多就玩到这里了，整个光照模型就大概如此。</p>
<p>至于能量守恒的部分，首先是环境光照和直接光照的区分。</p>
<p>剩下的最主要的就是漫反射和镜面反射的能量分配，最后就是考虑光照计算的正确性。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line"></span><br><span class="line">	fixed3 normal = <span class="built_in">normalize</span>(i.normal);</span><br><span class="line">    fixed3 LightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">    fixed3 ViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">    float3 h = <span class="built_in">normalize</span>(LightDir + ViewDir);</span><br><span class="line">    <span class="type">float</span> ndotL = <span class="built_in">dot</span>(normal, LightDir);</span><br><span class="line">    <span class="type">float</span> ndotH = <span class="built_in">dot</span>(normal,h);</span><br><span class="line">    fixed3 albedo = tex2D(_Albedo, i.uv).rgb * _Diffuse.rgb;</span><br><span class="line">    <span class="comment">//ambient</span></span><br><span class="line">    <span class="comment">//fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span></span><br><span class="line"></span><br><span class="line">    float4 indirect_irradiance = texCUBElod(_CubeMap, float4(normal,_CubeMapLod));</span><br><span class="line">    float3 indirect_diffuse = indirect_irradiance * albedo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//diffuse</span></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(ndotL,<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">    <span class="comment">//specular         </span></span><br><span class="line">    fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(ndotH,<span class="number">0</span>), _Gloss) ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> kd = (<span class="number">255.0</span> - _Spec)/<span class="number">255.0</span>;<span class="comment">//float kd = (255.0 - _Gloss)/255.0;</span></span><br><span class="line">    fixed3 color = indirect_diffuse * _EnvScale + diffuse * kd  + specular * (<span class="number">1.0</span>-kd);<span class="comment">//ambient + diffuse + specular;</span></span><br><span class="line">    <span class="keyword">return</span> fixed4(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1B54y1j7zE">https://www.bilibili.com/video/BV1B54y1j7zE</a> 【技术美术百人计划】图形 2.4 传统经验光照模型详解</p>
<p>[2] Unity Shader入门精要</p>
<p>[3]<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2021.3/Manual/class-TextureImporter.html#GenerateMipMaps">https://docs.unity3d.com/cn/2021.3/Manual/class-TextureImporter.html#GenerateMipMaps</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A22.4%20%E4%BC%A0%E7%BB%9F%E7%BB%8F%E9%AA%8C%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/" data-id="cmfe1u6pf001xscuh5fsed2qu" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形1.1渲染流水线" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" class="article-date">
  <time datetime="2025-09-10T13:18:14.021Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形1-1-渲染流水线"><a href="#图形1-1-渲染流水线" class="headerlink" title="图形1.1 渲染流水线"></a>图形1.1 渲染流水线</h2><h3 id="一、概念流程"><a href="#一、概念流程" class="headerlink" title="一、概念流程"></a><strong>一、概念流程</strong></h3><ul>
<li><p>应用程序阶段</p>
<ul>
<li>粗粒度剔除</li>
<li>渲染设置</li>
<li>准备基本数据</li>
<li>输出到几何阶段（<strong>渲染图元</strong>）</li>
</ul>
</li>
<li><p>几何阶段</p>
<ul>
<li>顶点着色器</li>
<li>曲面细分</li>
<li>几何着色器</li>
<li>顶点裁剪（屏幕空间裁剪）</li>
<li>屏幕映射（<strong>屏幕空间顶点信息</strong>）</li>
</ul>
</li>
<li><p>光栅化阶段</p>
<ul>
<li>三角形（图元：点&#x2F;线）设置，三角形（图元）遍历，片元着色器</li>
</ul>
</li>
<li><p>逐片元操作（合并）</p>
<ul>
<li>裁剪测试</li>
<li>透明度测试</li>
<li>模板测试</li>
<li>混合</li>
</ul>
</li>
<li><p>后处理（图像空间的处理）</p>
</li>
</ul>
<h3 id="二、细节"><a href="#二、细节" class="headerlink" title="二、细节"></a><strong>二、细节</strong></h3><h4 id="1-应用阶段（CPU）"><a href="#1-应用阶段（CPU）" class="headerlink" title="1.应用阶段（CPU）"></a><strong>1.应用阶段（CPU）</strong></h4><ul>
<li>准备基本场景数据（硬盘-&gt;内存）<ul>
<li>场景物体数据<ul>
<li>物体Transform：位置、旋转、缩放等</li>
<li>物体网格数据：顶点位置，UV贴图</li>
<li>这里的分类是不是有点像Maya的两种Dag类型Transform和Shape</li>
</ul>
</li>
<li>摄像机数据<ul>
<li>位置、方向、远近裁剪平面</li>
<li>正交&#x2F;透视（fov）</li>
<li>视口比例&#x2F;尺寸等</li>
</ul>
</li>
<li>光源及阴影<ul>
<li>光源类型：方向光、点光、聚光</li>
<li>颜色、位置、方向、范围、角度等</li>
<li>阴影设置<ul>
<li>是否需要阴影，判断该光源可见范围内是否有可投射阴影的物体</li>
<li>阴影参数：对应光源序号、阴影强度、级联参数、深度偏移、近平面偏移</li>
</ul>
</li>
<li>逐光源绘制阴影贴图<ul>
<li>近平面偏移</li>
<li>逐级联<ul>
<li>计算当前光源+级联对应的观察矩阵、投影矩阵、对应到阴影贴图里的视口区域</li>
</ul>
</li>
<li>绘制到阴影贴图</li>
</ul>
</li>
</ul>
</li>
<li>其他全局数据</li>
</ul>
</li>
<li>加速算法&#x2F;粗粒度剔除<ul>
<li>碰撞检测</li>
<li>加速算法</li>
<li>剔除<ul>
<li>可见光裁剪</li>
<li>视锥剔除</li>
<li>如CPU阶段的可见性（遮挡）剔除<ul>
<li>Octree</li>
<li>BSP tree</li>
<li>K-D tree</li>
<li>BVH tree</li>
</ul>
</li>
</ul>
</li>
<li>其他</li>
</ul>
</li>
<li>设置渲染状态，准备渲染参数（以unity为例）<ul>
<li>渲染设置<ul>
<li>使用着色器</li>
<li>合批方式</li>
</ul>
</li>
<li>渲染顺序<ul>
<li>相对摄像机的距离</li>
<li>材质Render Queue</li>
<li>UI Canvas</li>
<li>其他</li>
</ul>
</li>
<li>渲染目标<ul>
<li>Render Texture</li>
<li>Frame Buffer</li>
<li>多个目标</li>
</ul>
</li>
<li>渲染模式<ul>
<li>Forward</li>
<li>Deferred</li>
</ul>
</li>
</ul>
</li>
<li>调用Draw Call，输出渲染图元到显存<ul>
<li>顶点数据<ul>
<li>位置</li>
<li>颜色</li>
<li>法线</li>
<li>UV texcoord</li>
<li>其他</li>
</ul>
</li>
<li>其他数据<ul>
<li>MVP</li>
<li>纹理贴图</li>
<li>其他</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-几何阶段"><a href="#2-几何阶段" class="headerlink" title="2.几何阶段"></a><strong>2.几何阶段</strong></h4><h5 id="2-1顶点着色器"><a href="#2-1顶点着色器" class="headerlink" title="2.1顶点着色器"></a><strong>2.1顶点着色器</strong></h5><p>视图变换、顶点着色等<br>输出到Clip Space</p>
<h5 id="2-2曲面细分着色器（可选）"><a href="#2-2曲面细分着色器（可选）" class="headerlink" title="2.2曲面细分着色器（可选）"></a><strong>2.2曲面细分着色器（可选）</strong></h5><p>网格、图元细分</p>
<h5 id="2-3几何着色器（可选）"><a href="#2-3几何着色器（可选）" class="headerlink" title="2.3几何着色器（可选）"></a><strong>2.3几何着色器（可选）</strong></h5><p>逐图元着色或者产生更多图元</p>
<h5 id="2-4裁剪（不可编程）"><a href="#2-4裁剪（不可编程）" class="headerlink" title="2.4裁剪（不可编程）"></a><strong>2.4裁剪（不可编程）</strong></h5><p>正面或背面剔除（可配置）</p>
<h6 id="裁剪的顺序"><a href="#裁剪的顺序" class="headerlink" title="裁剪的顺序"></a>裁剪的顺序</h6><p>关于裁剪和透视除法的顺序，看到很多争议，包括参考图也有画在2D空间和3D空间的</p>
<p>在虎书4th的描述里，裁剪可能完成的地方有2种</p>
<ol>
<li>使用6个平面围成的观察金字塔（view pyramid）的世界坐标系中</li>
<li>齐次坐标除法之前的4D变换空间</li>
</ol>
<p>无论哪种都可以实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> each of six planes <span class="keyword">do</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(triangle entirely outside of plane)</span> then</span></span><br><span class="line"><span class="function">        <span class="title">break</span> <span class="params">(triangle is <span class="keyword">not</span> visible)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">else</span> <span class="keyword">if</span> triangle spans plane then</span></span><br><span class="line"><span class="function">		clip triangle</span></span><br><span class="line"><span class="function">		<span class="title">if</span> <span class="params">(quadrilateral is left)</span> then</span></span><br><span class="line"><span class="function">			<span class="keyword">break</span> into two triangles</span></span><br></pre></td></tr></table></figure>

<p>而如果先做透视除法再做裁剪，透视变换保持了深度顺序，但是在0处不连续</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220720181336331.png" alt="image-20220720181336331"></p>
<p>这样会把裁剪变得复杂，可能出现错误结果。</p>
<p>这部分的数学推导在后面整理到模型空间变换再研究好了。</p>
<p>总得来说，现代图形渲染管线，就是在齐次裁剪坐标下进行裁剪，然后由硬件完成透视除法。</p>
<p>至于书中提到的第一种裁剪位置在什么地方会用到就不知道了。实际上很多管线中的顺序也取决于硬件设计。</p>
<h5 id="2-5透视除法"><a href="#2-5透视除法" class="headerlink" title="2.5透视除法"></a><strong>2.5透视除法</strong></h5><p>齐次裁剪坐标Clip Space下，硬件完成透视除法xyz&#x2F;w，得到归一化的设备坐标NDC</p>
<p>Opengl和Unity的NDC的z分量范围在[-1,1]</p>
<p>DirectX中NDC的z分量范围是[0,1]</p>
<h5 id="2-6屏幕映射（不可编程）"><a href="#2-6屏幕映射（不可编程）" class="headerlink" title="2.6屏幕映射（不可编程）"></a><strong>2.6屏幕映射（不可编程）</strong></h5><p>从连续到离散</p>
<p>坐标系差异（Opengl&#x2F;D3D）</p>
<p>Opengl左下角为最小窗口坐标</p>
<p>Dx定义左上角为最小窗口坐标</p>
<h4 id="3-光栅化阶段"><a href="#3-光栅化阶段" class="headerlink" title="3.光栅化阶段"></a><strong>3.光栅化阶段</strong></h4><h5 id="3-1三角形设置Triangle-Setup-图元装配Primitive-Assembly"><a href="#3-1三角形设置Triangle-Setup-图元装配Primitive-Assembly" class="headerlink" title="3.1三角形设置Triangle Setup&#x2F;图元装配Primitive Assembly"></a><strong>3.1三角形设置Triangle Setup&#x2F;图元装配Primitive Assembly</strong></h5><p>根据输入的网格顶点来计算三角形边界</p>
<h5 id="3-2三角形遍历"><a href="#3-2三角形遍历" class="headerlink" title="3.2三角形遍历"></a><strong>3.2三角形遍历</strong></h5><p>（直线绘制算法与扫描线填充算法）扫描变换，检查像素是否被三角形覆盖，覆盖则生成一个片元</p>
<p>每个片元计算根据三角形顶点插值后的数据</p>
<p><em>因此片元和像素区别的意义不仅在于SSAA，还有合并操作当中，对同一像素对应片元进行合并才输出像素。</em></p>
<h6 id="MSAA"><a href="#MSAA" class="headerlink" title="MSAA"></a><strong>MSAA</strong></h6><p>对每个像素设置多个采样点，对每个子采样点进行覆盖测试和遮挡测试，每个子采样点都需要维护深度</p>
<h5 id="3-3片元着色器"><a href="#3-3片元着色器" class="headerlink" title="3.3片元着色器"></a><strong>3.3片元着色器</strong></h5><p>对于插值得到的片元执行片元着色器程序，输出一个或多个颜色值</p>
<h4 id="4-逐片元操作（输出合并阶段）"><a href="#4-逐片元操作（输出合并阶段）" class="headerlink" title="4.逐片元操作（输出合并阶段）"></a><strong>4.逐片元操作（输出合并阶段）</strong></h4><p>决定每个片元的可见性</p>
<ul>
<li><p>Stencil Test</p>
</li>
<li><p>Alpha Test</p>
<ul>
<li>透明度小于阈值的片元就被舍弃</li>
</ul>
</li>
<li><p>Depth Buffer Test</p>
</li>
</ul>
<p>如果通过测试，则把该片元颜色值和颜色缓冲区中的颜色进行合并&#x2F;混合</p>
<ul>
<li>Color Buffer Blending<ul>
<li>Alpha Blend</li>
</ul>
</li>
</ul>
<p>输出到目标缓冲区（RT&#x2F;FB）</p>
<h4 id="5-后处理"><a href="#5-后处理" class="headerlink" title="5.后处理"></a><strong>5.后处理</strong></h4><ul>
<li><p>HDR</p>
</li>
<li><p>Bloom</p>
</li>
<li><p>FXAA</p>
</li>
<li><p>Depth of View景深</p>
</li>
<li><p>边缘检测</p>
</li>
<li><p>径向模糊</p>
</li>
<li><p>。。。</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1L54y1s7xw?p=2&vd_source=7ec8021691d266bb655a835d37f89e13%E3%80%90%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92%E3%80%91%E5%9B%BE%E5%BD%A2">https://www.bilibili.com/video/BV1L54y1s7xw?p=2&amp;vd_source=7ec8021691d266bb655a835d37f89e13【技术美术百人计划】图形</a> 1.1 渲染流水线</p>
<p>[2] <a target="_blank" rel="noopener" href="https://jishuin.proginn.com/p/763bfbd6e54f">https://jishuin.proginn.com/p/763bfbd6e54f</a></p>
<p>[3] Unity Shader入门精要</p>
<p>[4] Fundamentals of Computer Graphics,4th</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" data-id="cmfe1u6pb001jscuhhb5q2gpe" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>