<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">XZYW7&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="XZYW7&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-TA/百人计划/图形1.2MVP矩阵运算" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.2MVP%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/" class="article-date">
  <time datetime="2025-09-10T13:18:14.021Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形1-2MVP矩阵运算"><a href="#图形1-2MVP矩阵运算" class="headerlink" title="图形1.2MVP矩阵运算"></a>图形1.2MVP矩阵运算</h2><ul>
<li><p>MVP矩阵</p>
<ul>
<li>Model模型，View观察，Projection投影矩阵</li>
</ul>
</li>
<li><p>空间</p>
<ul>
<li>Local Space(Local Coordinate)</li>
<li>World Space(World Coordinate)</li>
<li>View&#x2F;Camera Space(View&#x2F;Camera Coordinate)</li>
<li>Clip Space(Clip Coordinate)</li>
<li>Screen Space(Screen Coordinate)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220721144144034.png" alt="image-20220721144144034"></p>
<h3 id="M-模型空间-世界空间"><a href="#M-模型空间-世界空间" class="headerlink" title="M:模型空间-&gt;世界空间"></a><strong>M:模型空间-&gt;世界空间</strong></h3><p>对于模型本身来说，有自身的Local Space，当把模型放入世界空间场景去描述时，就需要把模型的局部坐标变换到世界坐标，这个变换用矩阵描述，就是Model矩阵</p>
<p>$M_{Model} &#x3D; M_TM_RM_S$</p>
<h4 id="平移Translation"><a href="#平移Translation" class="headerlink" title="平移Translation"></a><strong>平移Translation</strong></h4><p>Translation变换不是线性变换<br>$$<br>\begin{bmatrix}x’\y’ \end{bmatrix} &#x3D;\begin{bmatrix}a&amp;b\c&amp;d \end{bmatrix} \begin{bmatrix}x\y \end{bmatrix}+\begin{bmatrix}t_x\t_y \end{bmatrix}<br>$$</p>
<h5 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a><strong>齐次坐标</strong></h5><p>$2D point &#x3D; (x,y,1)^T$</p>
<p>$2Dvector &#x3D; (x,y,0)^T$ （向量的平移不变性）<br>$$<br>\begin{bmatrix}{}x’\y’\1’ \end{bmatrix}{} &#x3D; \begin{bmatrix}{}1&amp;0&amp;t_x\0&amp;1&amp;t_y\0&amp;0&amp;1 \end{bmatrix}{}\cdot\begin{bmatrix}{}x\y\1 \end{bmatrix}{} &#x3D; \begin{bmatrix}{}x+t_x\y+t_y\1 \end{bmatrix}{}<br>$$<br>对于点 $(x,y,w)^T$ 的表达，与 $(x&#x2F;w,y&#x2F;w,1)^T,w\neq 0$  等价</p>
<h5 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a><strong>仿射变换</strong></h5><p>对于任何一种变换能够写成</p>
<p>Affine map &#x3D; linear map + translation<br>$$<br>\begin{bmatrix}x’\y’ \end{bmatrix} &#x3D;\begin{bmatrix}a&amp;b\c&amp;d \end{bmatrix} \begin{bmatrix}x\y \end{bmatrix}+\begin{bmatrix}t_x\t_y \end{bmatrix}<br>$$<br>表示仿射变换，使用齐次坐标可以表示成矩阵乘法<br>$$<br>\begin{bmatrix}{}x’\y’\1’ \end{bmatrix}{} &#x3D; \begin{bmatrix}{}a&amp;b&amp;t_x\c&amp;d&amp;t_y\0&amp;0&amp;1 \end{bmatrix}{}\cdot\begin{bmatrix}{}x\y\1 \end{bmatrix}{}<br>$$</p>
<h5 id="3维的平移矩阵"><a href="#3维的平移矩阵" class="headerlink" title="3维的平移矩阵"></a><strong>3维的平移矩阵</strong></h5><p>$$<br>T(t_x,t_y,t_z) &#x3D; \begin{bmatrix}1&amp;0&amp;0&amp;t_x\0&amp;1&amp;0&amp;t_y\0&amp;0&amp;1&amp;t_z\0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$</p>
<h4 id="旋转Rotation"><a href="#旋转Rotation" class="headerlink" title="旋转Rotation"></a><strong>旋转Rotation</strong></h4><p>$$<br>R_x(\theta) &#x3D;\begin{bmatrix}1&amp;0&amp;0&amp;0<br>\0&amp;\cos\theta&amp;-\sin\theta&amp;0<br>\0&amp;\sin\theta&amp;\cos\theta&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix},<br>R_y(\theta) &#x3D;\begin{bmatrix}\cos\theta&amp;0&amp;\sin\theta&amp;0<br>\0&amp;1&amp;0&amp;0<br>\-\sin\theta&amp;0&amp;\cos\theta&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix},<br>R_z(\theta) &#x3D;\begin{bmatrix}\cos\theta&amp;0&amp;-\sin\theta&amp;0<br>\\sin\theta&amp;0&amp;\cos\theta&amp;0<br>\0&amp;0&amp;1&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<p>旋转矩阵是正交的</p>
<p>接下来我们来说一说为什么绕y轴的旋转矩阵长得有点不一样。</p>
<p>这里是同一个右手坐标系，分别从x,z,y的方向来观察。</p>
<p>我们绕哪个轴旋转，哪个轴上的坐标就不变，这很明显，因此只需要观察剩下的两个轴所构成的平面。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220721180506988.png" alt="image-20220721180506988"></p>
<p>如ZOY,YOX平面，在右手坐标系下，和二维的YOX旋转是一样的。从Y到Z，从X到Y的顺序是一致的。</p>
<p>但是在以Y轴作为旋转轴的XOZ平面上，是相反的，因此旋转的角度也变成了相反数。</p>
<h5 id="任意旋转"><a href="#任意旋转" class="headerlink" title="任意旋转"></a>任意旋转</h5><p>对于任意一种旋转状态<br>$$<br>R_{xyz}(\alpha,\beta,\gamma)&#x3D;R_x(\alpha)R_y(\beta)R_z(\gamma)<br>$$<br>这就也就是欧拉角</p>
<p><strong>Rodrigues’ Rotation Formula罗德里格斯旋转公式</strong></p>
<p>给定任意旋转轴和旋转角度转化为对应的旋转矩阵。<br>$$<br>R(n,\alpha) &#x3D; \cos(\alpha)I+(1-\cos(\alpha))nn^T+\sin(\alpha)\begin{bmatrix}0&amp;-n_z&amp;n_y\n_z&amp;0&amp;-n_x\-n_y&amp;n_x&amp;0\end{bmatrix}<br>$$<br>如果想绕任意起点的轴，则与2D一样，先平移至原点，绕原点轴旋转，再平移回去。</p>
<h5 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h5><p>放一放吧</p>
<p>但是可以先放个参考资料</p>
<p><a target="_blank" rel="noopener" href="https://krasjet.github.io/quaternion/quaternion.pdf">quaternion.pdf (krasjet.github.io)</a></p>
<h4 id="缩放Scale"><a href="#缩放Scale" class="headerlink" title="缩放Scale"></a><strong>缩放Scale</strong></h4><p>$$<br>S &#x3D;\begin{bmatrix}s_x&amp;0&amp;0&amp;0<br>\0&amp;s_y&amp;0&amp;0<br>\0&amp;0&amp;s_z&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<h4 id="Model变换顺序"><a href="#Model变换顺序" class="headerlink" title="Model变换顺序"></a><strong>Model变换顺序</strong></h4><center>
    <figure>
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220721163348382.png" alt="image-20220721163348382"  style = "width:40%;display:inline;margin:0" />
        <img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220721163401296.png" alt="image-20220721163401296" style = "width:40%;display:inline;margin:0" />
    </figure>
</center>



<p>3维的仿射变换齐次坐标表示<br>$$<br>\begin{bmatrix}x’\y’\z’\1 \end{bmatrix} &#x3D;<br>\begin{bmatrix}a&amp;b&amp;c&amp;t_x<br>\d&amp;e&amp;f&amp;t_y<br>\g&amp;h&amp;i&amp;t_z<br>\0&amp;0&amp;0&amp;1 \end{bmatrix} \cdot\begin{bmatrix}x\y\z\1\end{bmatrix}<br>$$<br>对应的Affine map &#x3D; linear map + translation，<br>$$<br>\begin{bmatrix}x’\y’ \end{bmatrix} &#x3D;\begin{bmatrix}a&amp;b\c&amp;d \end{bmatrix} \begin{bmatrix}x\y \end{bmatrix}+\begin{bmatrix}t_x\t_y \end{bmatrix}<br>$$<br>translation的顺序是在最后的，因此一定要先进行线性变换，再进行平移</p>
<p>因此<br>$$<br>M_{model} &#x3D;M_{T}M_{R}M_{S}&#x3D;<br>\begin{bmatrix}1&amp;0&amp;0&amp;t_x\0&amp;1&amp;0&amp;t_y\0&amp;0&amp;1&amp;t_z\0&amp;0&amp;0&amp;1\end{bmatrix}<br>\begin{bmatrix}a&amp;b&amp;c&amp;0<br>\d&amp;e&amp;f&amp;0<br>\g&amp;h&amp;i&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}s_x&amp;0&amp;0&amp;0<br>\0&amp;s_y&amp;0&amp;0<br>\0&amp;0&amp;s_z&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>其中旋转矩阵是任意旋转矩阵的组合</p>
<h3 id="V-世界空间-相机空间"><a href="#V-世界空间-相机空间" class="headerlink" title="V:世界空间-&gt;相机空间"></a><strong>V:世界空间-&gt;相机空间</strong></h3><p>经过Model矩阵的变换后，物体从模型空间变换到了世界空间的某个状态。在世界空间里的物体被人眼&#x2F;相机看到，相机要渲染出这张图像，就要以相机为中心来描述，那么就需要把世界空间的模型再变换到相机空间&#x2F;观察空间。这就是View矩阵。</p>
<p>变换过程：将摄像机和世界坐标重合（相机在世界空间的变换是先旋转，再平移）</p>
<ol>
<li>平移</li>
<li>旋转</li>
<li>（反转左右手坐标系：z分量取反）</li>
</ol>
<p>首先定义一个相机</p>
<ul>
<li>位置</li>
<li>观察方向Look-at&#x2F;gaze direction</li>
<li>向上方向Up direction</li>
</ul>
<p>让相机和物体保持相对位置，一起移动——与世界坐标重合，再旋转</p>
<p>这里的重合，我们需要让g(gaze)和Y（深度）轴重合，t(up)和Y重合，另一个方向和x轴重合。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220721190933162.png" alt="image-20220721190933162" style="zoom:50%;" />

<p>对于相机位置$(x_e,y_e,z_e)$<br>$$<br>M_{view}&#x3D;R_{view}T_{view}\<br>T_{view}&#x3D;\begin{bmatrix}1&amp;0&amp;0&amp;-x_e\<br>0&amp;1&amp;0&amp;-y_e\<br>0&amp;0&amp;1&amp;-z_e\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>而该如何旋转？直接求是不好求的，但是根据相机的坐标系我们可以知道<br>$$<br>R^{-1}<em>{view}&#x3D;\begin{bmatrix}<br>x</em>{g\times t} &amp;x_t&amp;x_{-g}&amp;0<br>\y_{g\times t}&amp;y_t&amp;y_{-g}&amp;0<br>\z_{g\times t}&amp;z_t&amp;z_{-g}&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\<br>R_{view}&#x3D;(R^{-1}<em>{view})^T&#x3D;\begin{bmatrix}<br>x</em>{g\times t}&amp;y_{g\times t} &amp;z_{g\times t}&amp;0<br>\x_t&amp;y_t&amp;z_t&amp;0<br>\x_{-g}&amp;y_{-g}&amp;z_{-g}&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\<br>$$<br>而这里对于g轴和z轴的方向统一问题，也就是左右手坐标系统一的问题，从上图可以看到，世界坐标仍然是右手系，但是相机空间定义的是左手系，指向世界空间z轴负方向。</p>
<p>Unity Shader入门精要中，世界空间是左手系，观察空间是右手系（Opengl）给出的解决方法是，最后再乘上一个negate z矩阵<br>$$<br>M_{view}&#x3D;M_{negate\ z}M_{view}\<br>M_{negate\ z}&#x3D;\begin{bmatrix}1&amp;0&amp;0&amp;0<br>\0&amp;1&amp;0&amp;0<br>\0&amp;0&amp;-1&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>就是其实就是把z坐标取反，这也是101作业当中的处理方法，其实也就是上面为什么写-g。这种细节问题，使用引擎什么的一般不会用到，但是在自己写引擎的时候，就是必须需要注意的细节了。</p>
<h3 id="P-相机空间-齐次裁剪空间"><a href="#P-相机空间-齐次裁剪空间" class="headerlink" title="P:相机空间-&gt;齐次裁剪空间"></a><strong>P:相机空间-&gt;齐次裁剪空间</strong></h3><ol>
<li>不是真正的投影，为投影做准备</li>
<li>目的：判断定点是否在可见范围内</li>
<li>P矩阵：对xyz分量进行缩放，用w分量做范围值，如果x，y，z都在w范围内，那么该点在裁剪空间内</li>
</ol>
<ul>
<li>投影类型<ul>
<li>透视投影</li>
<li>正交投影</li>
</ul>
</li>
</ul>
<p>其实在这次回顾101的时候发现，闫老师早就把View Transformation和Projection Transformation放到一起，统称为Viewing（观测）Transformation（这是很有道理的，因为这个阶段并没有进行透视除法，还在三维空间当中，透视除法才是把三维“投影“到二维当中的过程）。</p>
<p>投影矩阵只是把View frustum（视锥体）中的六面体空间变换为一个单位立方体空间(Canonical Cube) $[-1,1]^3$。</p>
<ul>
<li>Viewing（观测） transformation<ul>
<li>View&#x2F;Camera（视图） transformation</li>
<li>Projection（投影） transformation<ul>
<li>Orthographic projection</li>
<li>Perspective projection</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="正交投影Orthographic-Projection"><a href="#正交投影Orthographic-Projection" class="headerlink" title="正交投影Orthographic Projection"></a>正交投影Orthographic Projection</h4><p>正交投影中的视锥变换定义$[l,r]\times[b,t]\times[f,n]-&gt;[-1,1]^3$</p>
<p>正交投影的变换形式可想而知，在x和y轴上需要进行缩放，在z轴上除了缩放还要进行一定的平移，使立方体中心移动到坐标原点。</p>
<p>101在这里的讲述更复杂也更通用的一步，是定义了视锥体和观察坐标系之间的关系</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220721200902778.png" alt="image-20220721200902778"></p>
<p>视锥近平面中心不在观察中心。目前我还没接触到过使用这种特性。但其实都是一样的</p>
<p>这样的话，我们需要先平移再缩放，很明显<br>$$<br>M_{ortho}&#x3D;\begin{bmatrix}<br>\frac{2}{r-l}&amp;0&amp;0&amp;0<br>\0&amp;\frac{2}{t-b}&amp;0&amp;0<br>\0&amp;0&amp;\frac{2}{n-f}&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;-\frac{r+l}{2}<br>\0&amp;1&amp;0&amp;-\frac{t+b}{2}<br>\0&amp;0&amp;1&amp;-\frac{n+f}{2}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>\frac{2}{r-l}&amp;0&amp;0&amp;\frac{r+l}{l-r}<br>\0&amp;\frac{2}{t-b}&amp;0&amp;\frac{t+b}{b-t}<br>\0&amp;0&amp;\frac{2}{n-f}&amp;\frac{n+f}{f-n}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>那其实我们令相机在视锥体近平面中心轴线上，t&#x3D;-b&#x3D;size，r&#x3D;-l &#x3D;Aspect*size<br>$$<br>M_{ortho}&#x3D;\begin{bmatrix}<br>\frac{1}{Aspect\cdot Size}&amp;0&amp;0&amp;0<br>\0&amp;\frac{1}{size}&amp;0&amp;0<br>\0&amp;0&amp;\frac{2}{n-f}&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}\begin{bmatrix}<br>1&amp;0&amp;0&amp;0<br>\0&amp;1&amp;0&amp;0<br>\0&amp;0&amp;1&amp;-\frac{n+f}{2}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}\&#x3D;\begin{bmatrix}<br>\frac{1}{Aspect\cdot Size}&amp;0&amp;0&amp;0<br>\0&amp;\frac{1}{size}&amp;0&amp;0<br>\0&amp;0&amp;\frac{2}{n-f}&amp;-\frac{n+f}{n-f}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>也就是入门精要里的结果</p>
<h4 id="透视投影Perspective-Projection"><a href="#透视投影Perspective-Projection" class="headerlink" title="透视投影Perspective Projection"></a>透视投影Perspective Projection</h4><p>思路是先将透视投影的Frustum挤压成长方体，然后进行正交投影</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220721232039529.png" alt="image-20220721232039529" style="zoom:80%;" />

<p>$M_{persp} &#x3D; M_{ortho}M_{persp\to ortho}$</p>
<p>对于Frustum中间一点(x,y,z)</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220721232239730.png" alt="image-20220721232239730" style="zoom:67%;" />




<p>$$<br>M_{p\to o}\begin{bmatrix}x\y\z\1\end{bmatrix}&#x3D;\begin{bmatrix}nx&#x2F;z\ny&#x2F;z\unknown\1\end{bmatrix}&#x3D;&gt;\begin{bmatrix}nx\ny\unknown\z\end{bmatrix}\<br>M_{p\to o}&#x3D;\begin{bmatrix}n&amp;0&amp;0&amp;0\0&amp;n&amp;0&amp;0\?&amp;?&amp;?&amp;?\0&amp;0&amp;1&amp;0\end{bmatrix}<br>$$<br>考虑</p>
<ul>
<li>近平面的点不会改变</li>
</ul>
<p>$$<br>M_{p\to o}\begin{bmatrix}x\y\n\1\end{bmatrix}&#x3D;<br>\begin{bmatrix}nx&#x2F;n\ny&#x2F;n\n\1\end{bmatrix}&#x3D;&gt;\begin{bmatrix}nx\ny\n^2\n\end{bmatrix}\<br>$$</p>
<p>对于第三行的计算<br>$$<br>[a,b,c,d][x,y,n,1]^T &#x3D; n^2\a&#x3D;b&#x3D;0<br>\cn+d&#x3D;n^2<br>$$</p>
<ul>
<li>远平面点的z值不变</li>
</ul>
<p>$$<br>[0,0,c,d][0,0,f,1]^T&#x3D;f^2<br>\cf+d &#x3D; f^2<br>$$</p>
<p>可以解得<br>$$<br>c&#x3D;n+f\d&#x3D;-nf<br>$$<br>即<br>$$<br>M_{p\to o}&#x3D;\begin{bmatrix}n&amp;0&amp;0&amp;0\0&amp;n&amp;0&amp;0\0&amp;0&amp;n+f&amp;-nf\0&amp;0&amp;1&amp;0\end{bmatrix}<br>\<br>M_p&#x3D;\begin{bmatrix}<br>\frac{2}{r-l}&amp;0&amp;0&amp;\frac{r+l}{l-r}<br>\0&amp;\frac{2}{t-b}&amp;0&amp;\frac{t+b}{b-t}<br>\0&amp;0&amp;\frac{2}{n-f}&amp;\frac{n+f}{f-n}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}\begin{bmatrix}n&amp;0&amp;0&amp;0\0&amp;n&amp;0&amp;0\0&amp;0&amp;n+f&amp;-nf\0&amp;0&amp;1&amp;0\end{bmatrix}<br>&#x3D;\begin{bmatrix}<br>\frac{2n}{r-l}&amp;0&amp;\frac{r+l}{l-r}&amp;0<br>\0&amp;\frac{2n}{t-b}&amp;\frac{t+b}{b-t}&amp;0<br>\0&amp;0&amp;\frac{n+f}{n-f}&amp;\frac{2nf}{f-n}<br>\0&amp;0&amp;1&amp;0<br>\end{bmatrix}<br>$$<br>这个结果也正如虎书上的结果。</p>
<h4 id="对比与思考"><a href="#对比与思考" class="headerlink" title="对比与思考"></a>对比与思考</h4><p>但是这个时候问题来了，这个结果和Unity Shader入门精要上不一样……和一些其他地方的结果也不太一样……</p>
<p>最大的问题，都是出在四行三列和三行四列的符号上。</p>
<p>我们先继续考虑 $t&#x3D;-b&#x3D;size，r&#x3D;-l &#x3D;Aspect*size,\tan\frac{\theta}{2}&#x3D;\frac{t}{n}$，</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722005643105.png" alt="image-20220722005643105" style="zoom:67%;" />




<p>$$<br>M_p&#x3D;\begin{bmatrix}<br>\frac{2n}{r-l}&amp;0&amp;\frac{r+l}{l-r}&amp;0<br>\0&amp;\frac{2n}{t-b}&amp;\frac{t+b}{b-t}&amp;0<br>\0&amp;0&amp;\frac{n+f}{n-f}&amp;\frac{2nf}{f-n}<br>\0&amp;0&amp;1&amp;0<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>\frac{n}{r}&amp;0&amp;0&amp;0<br>\0&amp;\frac{n}{t}&amp;0&amp;0<br>\0&amp;0&amp;\frac{n+f}{n-f}&amp;\frac{2nf}{f-n}<br>\0&amp;0&amp;1&amp;0<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>-\frac{\cot\frac{\theta}{2}}{Aspect}&amp;0&amp;0&amp;0<br>\0&amp;-\cot\frac{\theta}{2}&amp;0&amp;0<br>\0&amp;0&amp;\frac{n+f}{n-f}&amp;\frac{2nf}{f-n}<br>\0&amp;0&amp;1&amp;0<br>\end{bmatrix}<br>$$<br>入门精要里和其它一些地方的结果是：<br>$$<br>\begin{bmatrix}<br>\frac{\cot\frac{\theta}{2}}{Aspect}&amp;0&amp;0&amp;0<br>\0&amp;\cot\frac{\theta}{2}&amp;0&amp;0<br>\0&amp;0&amp;\frac{near+far}{near-far}&amp;\frac{2nearfar}{near-far}<br>\0&amp;0&amp;-1&amp;0<br>\end{bmatrix}<br>$$<br>事实上，这和虎书后面给出的Opengl的投影矩阵结果是一样的。</p>
<p>那么造成差别的是在哪一步呢？</p>
<p>首先来看正交投影部分</p>
<ul>
<li>Result1</li>
</ul>
<p>$$<br>M_{ortho}&#x3D;\begin{bmatrix}<br>\frac{1}{Aspect\cdot Size}&amp;0&amp;0&amp;0<br>\0&amp;\frac{1}{size}&amp;0&amp;0<br>\0&amp;0&amp;\frac{2}{n-f}&amp;-\frac{n+f}{n-f}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<ul>
<li>Result2</li>
</ul>
<p>$$<br>M_{ortho}&#x3D;\begin{bmatrix}<br>\frac{1}{Aspect\cdot Size}&amp;0&amp;0&amp;0<br>\0&amp;\frac{1}{size}&amp;0&amp;0<br>\0&amp;0&amp;\frac{2}{near-far}&amp;-\frac{near+far}{far-near}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<p>一个比较坑的点是near&#x2F;far表示正值,n&#x2F;f表示坐标（负值），但是这不影响符号的相对差别。</p>
<p>即便把near&#x2F;far反过来，第三行整体就是反的了。</p>
<p>后来发现，unity&#x2F;opengl中希望这个frustum的近平面能够对应到立方体的-1，远平面对应到立方体的1。</p>
<p>但是虎书推到和闫老师的平移做法当中，是直接平移中点然后缩放，<strong>这就导致即便都是立方体，但是这里近平面对应的是1，远平面对应-1</strong></p>
<p>所以这里就出现了矛盾。</p>
<p>给第一个结果做一个z值矫正<br>$$<br>M_{ortho}&#x3D;\begin{bmatrix}<br>1&amp;0&amp;0&amp;0<br>\0&amp;1&amp;0&amp;0<br>\0&amp;0&amp;-1&amp;0<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}\begin{bmatrix}<br>\frac{1}{Aspect\cdot Size}&amp;0&amp;0&amp;0<br>\0&amp;\frac{1}{size}&amp;0&amp;0<br>\0&amp;0&amp;\frac{2}{n-f}&amp;-\frac{n+f}{n-f}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>\frac{1}{Aspect\cdot Size}&amp;0&amp;0&amp;0<br>\0&amp;\frac{1}{size}&amp;0&amp;0<br>\0&amp;0&amp;\frac{2}{f-n}&amp;\frac{n+f}{n-f}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>再考虑n和f的绝对值，就能得到unity&#x2F;opengl的正交投影结果了</p>
<p>我们带着这个结果往下看<br>$$<br>M_p&#x3D;\begin{bmatrix}<br>\frac{2}{r-l}&amp;0&amp;0&amp;\frac{r+l}{l-r}<br>\0&amp;\frac{2}{t-b}&amp;0&amp;\frac{t+b}{b-t}<br>\0&amp;0&amp;\frac{2}{f-n}&amp;\frac{n+f}{n-f}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}\begin{bmatrix}n&amp;0&amp;0&amp;0\0&amp;n&amp;0&amp;0\0&amp;0&amp;n+f&amp;-nf\0&amp;0&amp;1&amp;0\end{bmatrix}<br>&#x3D;\begin{bmatrix}<br>\frac{2n}{r-l}&amp;0&amp;\frac{r+l}{l-r}&amp;0<br>\0&amp;\frac{2n}{t-b}&amp;\frac{t+b}{b-t}&amp;0<br>\0&amp;0&amp;\frac{n+f}{f-n}&amp;\frac{2nf}{n-f}<br>\0&amp;0&amp;1&amp;0<br>\end{bmatrix}<br>$$<br>和这篇文章的结果是一样的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/463027517">https://zhuanlan.zhihu.com/p/463027517</a></p>
<p>$M_{p\to o}$计算中考虑n和f的绝对值也就是Unity&#x2F;opengl的结果。<br>$$<br>M_{p\to o}\begin{bmatrix}x\y\z\1\end{bmatrix}&#x3D;\begin{bmatrix}-|n|x&#x2F;z\-|n|y&#x2F;z\unknown\1\end{bmatrix}&#x3D;&gt;\begin{bmatrix}|n|x\|n|y\unknown\-z\end{bmatrix}\<br>M_{p\to o}&#x3D;\begin{bmatrix}|n|&amp;0&amp;0&amp;0\0&amp;|n|&amp;0&amp;0\?&amp;?&amp;?&amp;?\0&amp;0&amp;-1&amp;0\end{bmatrix}<br>$$<br>这样就构造出了-1</p>
<p>然后后面的计算就自然而然了。<br>$$<br>M_{p\to o}\begin{bmatrix}x\y\z\1\end{bmatrix}&#x3D;\begin{bmatrix}-|n|x&#x2F;z\-|n|y&#x2F;z\unknown\1\end{bmatrix}&#x3D;&gt;\begin{bmatrix}|n|x\|n|y\unknown\-z\end{bmatrix}\<br>M_{p\to o}&#x3D;\begin{bmatrix}|n|&amp;0&amp;0&amp;0\0&amp;|n|&amp;0&amp;0\0&amp;0&amp;|n|+|f|&amp;|n||f|\0&amp;0&amp;-1&amp;0\end{bmatrix}\<br>M_p&#x3D;\begin{bmatrix}<br>\frac{1}{Aspect\cdot Size}&amp;0&amp;0&amp;0<br>\0&amp;\frac{1}{size}&amp;0&amp;0<br>\0&amp;0&amp;\frac{2}{near-far}&amp;\frac{near+far}{near-far}<br>\0&amp;0&amp;0&amp;1<br>\end{bmatrix}\begin{bmatrix}near&amp;0&amp;0&amp;0\0&amp;near&amp;0&amp;0\0&amp;0&amp;near+far&amp;nearfar\0&amp;0&amp;-1&amp;0\end{bmatrix}<br>&#x3D;\begin{bmatrix}<br>\frac{\cot\frac{\theta}{2}}{Aspect}&amp;0&amp;0&amp;0<br>\0&amp;\cot\frac{\theta}{2}&amp;0&amp;0<br>\0&amp;0&amp;\frac{near+far}{near-far}&amp;\frac{2nearfar}{near-far}<br>\0&amp;0&amp;-1&amp;0<br>\end{bmatrix}<br>$$<br>终于和入门精要的结果一致了。。。</p>
<p>总结一下，影响这些透视投影矩阵符号的两个因素</p>
<ul>
<li>near&#x2F;far是正值，n&#x2F;f是坐标</li>
<li>一部分将frustum近平面映射到-1，远平面映射到1；一部分则相反</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1M5411P7d3">https://www.bilibili.com/video/BV1M5411P7d3</a> 【技术美术百人计划】图形 1.2.3 MVP矩阵运算</p>
<p>[2]<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a> GAMES101-现代计算机图形学入门-闫令琪</p>
<p>[3] Unity Shader 入门精要</p>
<p>[4] Fundamentals of Computer Graphics,4th</p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/463027517">https://zhuanlan.zhihu.com/p/463027517</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.2MVP%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/" data-id="cmfe1u6pb001lscuh7z0yc48w" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/百人计划/图形1.3纹理的秘密" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.3%E7%BA%B9%E7%90%86%E7%9A%84%E7%A7%98%E5%AF%86/" class="article-date">
  <time datetime="2025-09-10T13:18:14.021Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="图形1-3纹理"><a href="#图形1-3纹理" class="headerlink" title="图形1.3纹理"></a>图形1.3纹理</h2><h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a><strong>纹理</strong></h3><p>纹理–贴图</p>
<p>一种可供着色器读写的结构化存储形式</p>
<ul>
<li>纹理的出现<ul>
<li>牺牲几何细节<ul>
<li>降低建模工作量</li>
<li>减少储存空间</li>
<li>增加读取速度</li>
</ul>
</li>
<li>（使用图像数据源来修正或模拟物体表面）</li>
</ul>
</li>
</ul>
<h3 id="纹理管线"><a href="#纹理管线" class="headerlink" title="纹理管线"></a><strong>纹理管线</strong></h3><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722170359786.png" alt="image-20220722170359786"></p>
<p>模型空间位置-(投影函数-纹理映射)-纹理坐标（UV）-通讯函数-新纹理坐标-纹理采样（避免依赖纹理读取）-纹理值</p>
<ul>
<li><p>投影函数</p>
<ul>
<li>uv值的计算，就是texture mapping的投影方式(展UV)</li>
<li>特殊情况<ul>
<li>环境贴图的采样</li>
</ul>
</li>
</ul>
</li>
<li><p>通讯函数</p>
<ul>
<li>对纹理坐标进行扩展。例如平移、缩放、旋转或控制图像的应用方式</li>
</ul>
</li>
<li><p>依赖纹理读取</p>
</li>
</ul>
<p><em>有两个定义。其一是移动设备上，当PS中手动计算了纹理坐标而不是用VS中传入的值时会变成依赖纹理读取，在老的移动GPU（不支持GLES3.0）上，没有依赖纹理读取的shader会跑的更高效，因为纹素数据可以被提前获取。另一个定义则更早，在早期的桌面GPU上，当一个纹理的坐标基于另一个纹理的结果时。例如用法线贴图中获取的法线来访问一张立方体贴图，这样的功能是受限制的，如今虽可以使用但是也是有一定的性能影响的。</em></p>
<h4 id="纹理采样设置"><a href="#纹理采样设置" class="headerlink" title="纹理采样设置"></a><strong>纹理采样设置</strong></h4><h5 id="Warp-Mode"><a href="#Warp-Mode" class="headerlink" title="Warp Mode"></a><strong>Warp Mode</strong></h5><ul>
<li>决定UV在[0,1]之外的表现形式<ul>
<li>Repeat，Mirror，Clamp，Border</li>
</ul>
</li>
<li>GL-Warpping Model包装模式</li>
<li>DX-Texture Addressing Mode纹理寻址模式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722170720962.png" alt="image-20220722170720962"></p>
<h5 id="Filter-Mode"><a href="#Filter-Mode" class="headerlink" title="Filter Mode"></a><strong>Filter Mode</strong></h5><ul>
<li><strong>最近邻Nearest</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722172111472.png" alt="image-20220722172111472"></p>
<p>顾名思义，就是找到最接近的像素颜色</p>
<ul>
<li><strong>双线性插值Bilinear</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722172531595.png" alt="image-20220722172531595"></p>
<ul>
<li><strong>双三次插值Bicubic（立方卷积）</strong></li>
</ul>
<p>取周围临近16个像素——除了周围四个直接相邻像素点的影响，同时考虑临近像素的变化率的影响</p>
<ul>
<li><strong>兰索斯插值</strong></li>
</ul>
<p>取64个像素</p>
<ul>
<li><strong>Quilez光滑曲线插值</strong></li>
</ul>
<p>2x2纹理组，使用smoothstep和quintic曲线</p>
<p>用这两种曲线对纹理坐标进行处理后进行双线性插值</p>
<p>但是我怀疑是否是用曲线插值直接代替线性插值</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722173955476.png" alt="image-20220722173955476"></p>
<h4 id="Texture-Magnification-Minification"><a href="#Texture-Magnification-Minification" class="headerlink" title="Texture Magnification&#x2F;Minification"></a><strong>Texture Magnification&#x2F;Minification</strong></h4><p>其实对于纹理放大对应的还有纹理缩小，但是本质是一样的，都是纹理像素和屏幕对纹理采样的频率差别太大导致的。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722174926271.png" alt="image-20220722174926271" style="zoom:50%;" />

<ul>
<li><p>纹理太大，会出现颜色丢失与闪烁、摩尔纹</p>
</li>
<li><p>纹理太小，则出现走样</p>
</li>
<li><p>解决方法</p>
<ul>
<li>Supersampling（点查询）<ul>
<li>消耗大</li>
</ul>
</li>
<li>Mipmap（范围查询：快速、&#x3D;&#x3D;近似、方形范围&#x3D;&#x3D;）<ul>
<li>消耗的内存比原先多1&#x2F;3</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722180359176.png" alt="image-20220722180359176" style="zoom:67%;" />

<p>假如L是4个像素，那么D&#x3D;2，也就是说，在第2层的mipmap上，这个区域会对应一个像素</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722190424580.png" alt="image-20220722190424580"></p>
<ul>
<li>mip之间的过渡——场景中的mip层级是不连续的<ul>
<li>Trilinear interpolation</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722181227045.png" alt="image-20220722181227045" style="zoom:67%;" />

<ul>
<li>Mipmap的限制<ul>
<li>Overblur</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722181812718.png" alt="image-20220722181812718" style="zoom:50%;" />



<p>屏幕映射到纹理上的形状并不是标准的正方形</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722182042045.png" alt="image-20220722182042045" style="zoom:50%;" />

<ul>
<li>解决方法：各向异性过滤Anisotropic Filtering</li>
<li>Ripmaps<ul>
<li>对于矩形的查询有更好的结果</li>
<li>但是对于倾斜的形状仍然无法解决</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722181954884.png" alt="image-20220722181954884" style="zoom:50%;" />

<ul>
<li>EWA filtering<ul>
<li>多次查询会更消耗</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722182224011.png" alt="image-20220722182224011"></p>
<ul>
<li>Summed-Area Table积分图<ul>
<li>前缀和算法<a target="_blank" rel="noopener" href="https://xzyw7.github.io/post/real-time-shadows/#mipmap-and-summed-area-variance-shadow-maps">【笔记】Real-time Shadows实时阴影 | XZYW (xzyw7.github.io)</a></li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722192532542.png" alt="image-20220722192532542" style="zoom: 50%;" />

<ul>
<li>Unity&#x2F;Ue4中的各向异性过滤<ul>
<li>并不总是使用Ripmap</li>
<li>重用已有的Mipmap，屏幕像素反向投影到纹理空间，通过覆盖方块&#x3D;&#x3D;最短边&#x3D;&#x3D;来确定level</li>
<li>较长的边创建一条各向异性线，按照过滤等级沿着这条线多次采样并合成。（过滤等级越高，采样次数越多，消耗越大）</li>
</ul>
</li>
</ul>
<h3 id="优化与纹理应用"><a href="#优化与纹理应用" class="headerlink" title="优化与纹理应用"></a><strong>优化与纹理应用</strong></h3><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h4><ul>
<li>CPU优化——降低DrawCall——减少命令缓冲区的命令</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722193601854.png" alt="image-20220722193601854" style="zoom:50%;" />

<p>纹理图集、纹理数组、无约束纹理——避免渲染时频繁改变纹理带来的消耗</p>
<ul>
<li>纹理图集<ul>
<li>把若干小纹理合并成大纹理</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722193710685.png" alt="image-20220722193710685" style="zoom:50%;" />

<ul>
<li>GPU渲染优化——纹理压缩<ul>
<li>减少资源在CPU中解压缩的过程</li>
<li>减小包体，减轻数量级、带宽计算压力</li>
<li>提高内存使用效率</li>
</ul>
</li>
</ul>
<h4 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a><strong>其他应用</strong></h4><ul>
<li>CubeMap立方体贴图<ul>
<li>使用从原点出发的方向向量进行采样</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220722194124743.png" alt="image-20220722194124743" style="zoom:50%;" />

<ul>
<li>Bump Mapping凹凸贴图<ul>
<li>不增加顶点的情况下改变几何表面法线</li>
</ul>
</li>
<li>Displacement Mapping位移&#x2F;置换贴图<ul>
<li>曲面细分、对顶点进行位置移动</li>
</ul>
</li>
<li>Environment Lighting</li>
<li>Store microgeometry</li>
<li>Procedural textures</li>
<li>Solid modeling</li>
<li>Volume rendering</li>
<li>。。。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sA411N7z3">https://www.bilibili.com/video/BV1sA411N7z3</a> 【技术美术百人计划】图形 1.3 纹理的秘密</p>
<p>[2]<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a> GAMES101-现代计算机图形学入门-闫令琪</p>
<p>[2]<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365518995">https://zhuanlan.zhihu.com/p/365518995</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A21.3%E7%BA%B9%E7%90%86%E7%9A%84%E7%A7%98%E5%AF%86/" data-id="cmfe1u6pb001nscuhhcflfp3w" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/Opengl learning_02" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/OpenGL/Opengl%20learning_02/" class="article-date">
  <time datetime="2025-09-10T13:18:14.020Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="08-How-I-Deal-with-Shaders"><a href="#08-How-I-Deal-with-Shaders" class="headerlink" title="08 How I Deal with Shaders"></a><strong>08 How I Deal with Shaders</strong></h2><p>在之前的着色器编写中，对于每个字符串都要加引号和换行符，这是非常不方便的。</p>
<p>因此我们需要从文件读取shader。</p>
<p>一般来说会把vs和fs分成两个文件。但作者认为两个文件也很不方便，而是把vs和fs合并在一起（shaderlab就是这样做的）。并且在文件中对两部分进行区别。</p>
<p>在项目文件夹中新建resource文件夹，包含shaders文件夹，（以后也可能添加纹理、模型等资源），创建一个后缀为shader的文件</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824221249780.png" alt="image-20220824221249780"></p>
<p>将着色器的代码粘贴到文件中，并分别加上指定vs和fs编译的宏（可以用替换的功能去掉引号和换行符）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec4 position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color = <span class="built_in">vec4</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们要做的是把这个文件转换成std字符串。读文件采用fstream设置文件流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span>&#123;</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FrgmentSource;</span><br><span class="line">&#125;;<span class="comment">// 为了返回多重数据而制作一个结构体</span></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span> &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">	std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(stream, line)) &#123;<span class="comment">//string头文件中的getline方法</span></span><br><span class="line">    	<span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>)!=std::string::npos)&#123;</span><br><span class="line">            <span class="comment">//std::string::npos,表示字符串末尾（无效字符串）</span></span><br><span class="line">            <span class="keyword">if</span>(line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>)!=std::string::npos)&#123;</span><br><span class="line">                <span class="comment">// set mode to vertex</span></span><br><span class="line">            	type = ShaderType::VERTEX;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>)!=std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把代码添加到vs或fs的字符串流中</span></span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt;line&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  &#123;ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ShaderProgramSource source= <span class="built_in">ParseShader</span>(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line"><span class="comment">//我们这里使用相对路径，可执行文件的默认工作目录是可执行文件的目录，而visual studio调试器运行，工作目录是可设置的</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824224240477.png" alt="image-20220824224240477" style="zoom:50%;" />

<p>将解析的着色器代码输出出来，一切正常</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824224450410.png" alt="image-20220824224450410"></p>
<p>那么我们实现了从一个文件里读取vs和fs，这部分修改就完成了</p>
<h2 id="09-Index-Buffers"><a href="#09-Index-Buffers" class="headerlink" title="09 Index Buffers"></a><strong>09 Index Buffers</strong></h2><ul>
<li>Index Buffer是什么</li>
</ul>
<p>我们已经画好了一个三角形。我们如果想画一个正方形呢？实际上，也是由三角形组成的。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824230232057.png" alt="image-20220824230232057" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="comment">// 第二个三角形</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相应地，顶点缓冲区大小也增大了，绘制方法也需要改成6个顶点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>我们成功地 绘制出了想要的正方形&#x2F;长方形</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220824230651997.png" alt="image-20220824230651997" style="zoom:50%;" />

<p>但是实际上顶点数组发生了大量重复，这也浪费了内存，尤其是顶点储存属性很多时。</p>
<p>因此我们使用索引缓冲Index Buffer，使顶点能够重复使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">&#125;;<span class="comment">//01230</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">	<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line">&#125;;<span class="comment">//必须使用无符号类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点缓冲</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;<span class="comment">//index buffer object</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//drawcall的变化</span></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);<span class="comment">//GL_INT就出现了问题，无法渲染出画面，而index  buffer是无符号的</span></span><br></pre></td></tr></table></figure>

<p>也非常顺利</p>
<h2 id="10-Dealing-with-Errors"><a href="#10-Dealing-with-Errors" class="headerlink" title="10 Dealing with Errors"></a><strong>10 Dealing with Errors</strong></h2><p>这里讨论的是Opengl提供的检查错误的方法，不会用到外部工具</p>
<p>主要有两种方法</p>
<p>glGetError</p>
<p>使用glGetError的工作流程是首先在opengl的每个函数调用前，&#x3D;&#x3D;在循环中调用&#x3D;&#x3D;，直到清除所有错误。</p>
<p>glMessageCallBack是opengl4.3添加的功能，允许我们指定一个指向Opengl函数的指针，比glGetError更方便。这一集教程中只关注glGetError。</p>
<ul>
<li>返回值flag</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825000148080.png" alt="image-20220825000148080"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">glGetError</span>()!=GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLCheckError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;[OpenGL Error] (&quot;</span>&lt;&lt; error &lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="built_in">GLClearError</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>);<span class="comment">//前面的符号类型错误</span></span><br><span class="line"><span class="built_in">GLCheckError</span>();</span><br></pre></td></tr></table></figure>

<p>控制台打印出1280的错误</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825000933480.png" alt="image-20220825000933480"></p>
<p>在glew.h中 ，会发现各种宏的定义都是16进制的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825001114710.png" alt="image-20220825001114710"></p>
<p>因此我们把1280转换成16进制，如果懒得搜的话，在断点 中定位到变量，右键可以选择16进制显示，这里结果是0x00000500，</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825001334790.png" alt="image-20220825001334790" style="zoom:50%;" />

<p>在glew.h中搜索，我们可以找到是GL_INVALID_ENUM的错误，也就是说，在我们检查的glDrawElements函数中，传递了一个无效的枚举类型参数。也就是GL_INT</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825001532054.png" alt="image-20220825001532054"></p>
<p>那么，最终的问题是，对于每个函数都做这样的处理太过麻烦，也会污染代码。所以我们最好知道错误发生在哪里 。</p>
<p>在这里我们已经设置了断点，当然我们在堆栈中可以找到具体的出现问题的函数。我们也可以用ASSERT来做这件事，如果条件不成立，通常发送一个消息到控制台，或是停止程序的执行 。这相当于用代码来设置断点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">glGetError</span>()!=GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;[OpenGL Error] (&quot;</span>&lt;&lt; error &lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">GLClearError</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(<span class="built_in">GLLogCall</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后自动触发了断点</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825003024764.png" alt="image-20220825003024764"></p>
<p>我们还可以再设置一宏命令来简化这个过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">		x;\</span></span><br><span class="line"><span class="meta">		ASSERT(GLLogCall())</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">GLCALL</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>

<p>非常好用。</p>
<p>还要解决的问题是，我们的错误消息并不能指定实际错误发生在哪个文件或行上，甚至函数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt; </span><br><span class="line">            <span class="string">&quot; &quot;</span>&lt;&lt; file&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;line&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更好用了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220825004247444.png" alt="image-20220825004247444"></p>
<p>接下来我们要做的就是把每个opengl方法用GLCall包装起来。</p>
<p>有一些情况会为GLCall添加if、while等作用域，但是这样就无法使用于赋值的构造函数语句等，因为这会让创建的变量无法被调用，因为超出了作用域（相当于封装在了一个{}scope中）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreaateProgram</span>());</span><br><span class="line"><span class="comment">//这是可以使用的，但是添加作用域后不能使用，相当于把它放进了大括号</span></span><br></pre></td></tr></table></figure>



<h2 id="11-Uniforms"><a href="#11-Uniforms" class="headerlink" title="11 Uniforms"></a><strong>11 Uniforms</strong></h2><p>Uniform是一种从CPU获取数据的方式。</p>
<p>在交互时着色器变量有可能需要更新， 因此C++的变量通过Uniform传递到着色器。</p>
<p>我们在每次绘制前设置uniform</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Basic.shader</span></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"></span><br><span class="line">uniform vec4 u_Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color = u_Color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建着色器后，每个uniform都会被分配一个ID，并通过ID检索该变量的位置</span></span><br><span class="line"><span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>);</span><br><span class="line"><span class="comment">//如果在着色器中声明了但没有使用uniform变量，那么opengl编译时会舍弃该变量</span></span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">glUniform4f</span>(location, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<p>通过Uniform来对变量进行变化控制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>);</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">glUniform4f</span>(location, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">if</span> (r&gt;<span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span> (r&lt;<span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line">    r += increment;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(有可能会出现变化太快的问题，可以把双缓冲交换间隔设置为1。虽然我好像没有这个问题)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="12-Vertex-Arrays"><a href="#12-Vertex-Arrays" class="headerlink" title="12 Vertex Arrays"></a><strong>12 Vertex Arrays</strong></h2><ul>
<li>绑定vertex buffer</li>
<li>指定vertex layout</li>
<li>绑定index buffer</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解除绑定</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在每一帧重新绑定，结果是一样的。事实上由于每一帧绘制数据可能发生变化，正需要在这里进行绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));<span class="comment">//前面的符号类型错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们需要正确使用顶点数组，为每个几何体设置不同的顶点数组对象，然后只需要在drawcall前进行绑定。这就是VAO。</p>
<p>绘制过程</p>
<ul>
<li>绑定着色器</li>
<li>绑定顶点缓冲区</li>
<li>设置顶点布局</li>
<li>绑定index缓冲区</li>
<li>drawcall</li>
</ul>
<p>-》使用VAO</p>
<ul>
<li>绑定着色器</li>
<li>绑定顶点数组</li>
<li>绑定index缓冲</li>
<li>drawcall</li>
</ul>
<p>使用core profile</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//使用opengl最高版本或最低版本为3（3.3）</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//使用Core Profile</span></span><br><span class="line"><span class="comment">//可兼容性的opengl profile（compatbility Opengl profile）有VAO默认对象是0.但core profile没有默认对象，必须绑定VAO</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int vao;</span><br><span class="line">glGenVertexArrays(1, &amp;vao);</span><br><span class="line">glBindVertexArray(vao);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这些都绑定好后，由于Opengl的状态机属性，我们可以解除绑定。然后在drawcall前再绑定vao（把vertex buffer链接到VAO），就可以正常绘制。</p>
<ul>
<li>绑定VAO</li>
<li>绑定顶点缓冲</li>
<li>指定顶点属性指针，这时将会把顶点缓冲和VAO绑定在一起</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定VAO</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点缓冲</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;<span class="comment">//index buffer object</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定</span></span><br><span class="line"><span class="comment">//glUseProgram(0);</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);<span class="comment">//反正不要在VAO激活时解绑EBO/IBO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);</span></span><br><span class="line">	<span class="comment">//同样重要的是要注意，索引缓冲区/ELEMENT_ARRAY_BUFFER也包含在VAO状态中。它不需要按帧重新定义...因此，您也可以删除该行。  GL_ELEMENT_ARRAY_BUFFER必须在绑定顶点数组对象（glBindVertex 数组）之后绑定。GL_ELEMENT_ARRAY_BUFFER对象存储在顶点数组对象状态向量中。 如果顶点数组对象已解绑并再次绑定，则GL_ELEMENT_ARRAY_BUFFER也已知并再次绑定。但是，如果在绑定顶点数组对象时元素数组缓冲区显式解除绑定，则会从状态向量中删除该缓冲区。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));<span class="comment">//前面的符号类型错误</span></span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来的做法：</p>
<p>每次需要绘制时，绑定顶点缓冲区，指定顶点属性指针，绑定顶点索引缓冲，然后渲染。</p>
<p>VAO的方法：</p>
<p>为每个几何对象创建VAO，绑定顶点缓冲区，指定顶点属性指针，绑定顶点索引缓冲，解绑</p>
<p>在渲染该对象前绑定对应的VAO</p>
<p>LearnOpengl对此操作的描述</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#x27;s bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.</span></span><br><span class="line"><span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can unbind the VAO afterwards so other VAO calls won&#x27;t accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line"><span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在之后我们可以用class来做这件事，会方便很多。</p>
<p>每次绑定vertex buffer和VAO的方式哪种更快呢？</p>
<ul>
<li>实际上在过去使用一个VAO，每次绑定其他东西更快。</li>
<li>NVIDIA提出不建议使用VAO</li>
<li>但其实在不同环境下也可能出现不同的结果</li>
<li>如果一定特别需要压榨性能，可以看情况使用</li>
</ul>
<h2 id="13-Abstracting-Opengl-into-Class"><a href="#13-Abstracting-Opengl-into-Class" class="headerlink" title="13 Abstracting Opengl into Class"></a><strong>13 Abstracting Opengl into Class</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span> &#123;</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FrgmentSource;</span><br><span class="line">&#125;;<span class="comment">// 为了返回多重数据而制作一个结构体</span></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span> &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line)) &#123;<span class="comment">//string头文件中的getline方法</span></span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">            <span class="comment">//std::string::npos,表示字符串末尾（无效字符串）</span></span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to vertex</span></span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把代码添加到vs或fs的字符串流中</span></span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  &#123; ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">ComplieShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fail to complie &quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex &quot;</span> : <span class="string">&quot;fragment &quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">ComplieShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">ComplieShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;GlewInit fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">12</span>] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">    &#125;;<span class="comment">//01230</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">        <span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line">    &#125;;<span class="comment">//必须使用无符号类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定VAO</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点缓冲</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ibo;<span class="comment">//index buffer object</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::string vertexShader =</span></span><br><span class="line"><span class="comment">        &quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;layout(location = 0) in vec4 position;\n&quot;</span></span><br><span class="line"><span class="comment">        //和顶点属性的laout一致。</span></span><br><span class="line"><span class="comment">        //注意这里是vec4，而我们实际只有vec2，剩余的部分Opengl会默认转换z0w1</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;void main()&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#123;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;	gl_Position = position;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#125;\n&quot;;</span></span><br><span class="line"><span class="comment">    std::string fragmentShader =</span></span><br><span class="line"><span class="comment">        &quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;layout(location = 0) out vec4 color;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;void main()&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#123;\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;	color = vec4(1.0,0.0,0.0,1.0);\n&quot;</span></span><br><span class="line"><span class="comment">        &quot;&#125;\n&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FrgmentSource);</span><br><span class="line">    <span class="comment">//glUseProgram(shader);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建着色器后，每个uniform都会被分配一个ID</span></span><br><span class="line">    <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>);</span><br><span class="line">    <span class="comment">//如果在着色器中声明了但没有使用uniform变量，那么opengl编译时会舍弃该变量</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解除绑定</span></span><br><span class="line">    <span class="comment">//glUseProgram(0);</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line">        <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));<span class="comment">//前面的符号类型错误</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">            increment = <span class="number">-0.05f</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">            increment = <span class="number">0.05f</span>;</span><br><span class="line">        r += increment;</span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//glDeleteProgram(shader);</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里先放一放整体的代码，然后我们将要进行大的修改。</p>
<h3 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a><strong>Renderer</strong></h3><p>首先创建Renderer.h 和cpp文件。并且把错误处理的部分挪到头文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Renderer.h#################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Renderer.cpp###############</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VertexBuffer"><a href="#VertexBuffer" class="headerlink" title="VertexBuffer"></a><strong>VertexBuffer</strong></h3><p>我们再创建VertexBuffer的头文件和cpp文件,用来定义顶点缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexBuffer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBuffer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	<span class="comment">// 在其他API中，也表示是一个ID，因此用这种命名来通用地表达</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> <span class="type">int</span> size);</span><br><span class="line">	~<span class="built_in">VertexBuffer</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以右键类名后选择“快速操作和重构”，然后创建函数定义，这样IDE自动在cpp中为我们创建了各个方法的定义框架（但实际上我操作失败了，提示说所选的文本不包含任何函数签名，我只能全选下面的方法，然后再右键快速操作）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220910170329326.png" alt="image-20220910170329326"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexBuffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line">VertexBuffer::<span class="built_in">VertexBuffer</span>(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">unsigned</span> <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VertexBuffer::~<span class="built_in">VertexBuffer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="IndexBuffer"><a href="#IndexBuffer" class="headerlink" title="IndexBuffer"></a><strong>IndexBuffer</strong></h3><p>对indexBuffer也可以用同样的做法.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#########IndexBuffer.h##############</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexBuffer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count);</span><br><span class="line">	~<span class="built_in">IndexBuffer</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//##########IndexBuffer.cpp#############</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IndexBuffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line">IndexBuffer::<span class="built_in">IndexBuffer</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>* data, <span class="type">unsigned</span> <span class="type">int</span> count)</span><br><span class="line">    : <span class="built_in">m_Count</span>(count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="built_in">sizeof</span>(GLuint));</span><br><span class="line">    <span class="comment">//count*sizeof(GLuint)即使可能不会，但仍可能出现平台差异</span></span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, count * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), data, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IndexBuffer::~<span class="built_in">IndexBuffer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a><strong>Application</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span>*<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 顶点缓冲</span></span><br><span class="line"><span class="comment">    unsigned int buffer;</span></span><br><span class="line"><span class="comment">    glGenBuffers(1, &amp;buffer);</span></span><br><span class="line"><span class="comment">    glBindBuffer(GL_ARRAY_BUFFER, buffer);</span></span><br><span class="line"><span class="comment">    glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0);</span></span><br><span class="line"><span class="comment">    glEnableVertexAttribArray(0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 制作索引缓冲区和顶点缓冲区相似</span></span><br><span class="line"><span class="comment">    unsigned int ibo;//index buffer object</span></span><br><span class="line"><span class="comment">    glGenBuffers(1, &amp;ibo);</span></span><br><span class="line"><span class="comment">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);</span></span><br><span class="line"><span class="comment">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="14-Buffer-Layout-Abstraction"><a href="#14-Buffer-Layout-Abstraction" class="headerlink" title="14 Buffer Layout Abstraction"></a><strong>14 Buffer Layout Abstraction</strong></h2><p>我们希望用如下的结构来组织vao</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VertexArray va;</span><br><span class="line"><span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span>*<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line">va.<span class="built_in">AddBuffer</span>(vb);</span><br><span class="line"></span><br><span class="line">BufferLayout layout;</span><br><span class="line">layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>);</span><br><span class="line">va.<span class="built_in">AddLayout</span>(layout);</span><br><span class="line">....</span><br><span class="line">va.<span class="built_in">Bind</span>();</span><br></pre></td></tr></table></figure>



<h3 id="VertexArray"><a href="#VertexArray" class="headerlink" title="VertexArray"></a><strong>VertexArray</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexArray.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBufferLayout.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VertexArray</span>();</span><br><span class="line">	~<span class="built_in">VertexArray</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//VertexArray.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexArray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line">VertexArray::<span class="built_in">VertexArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VertexArray::~<span class="built_in">VertexArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::AddBuffer</span><span class="params">(<span class="type">const</span> VertexBuffer&amp; vb, <span class="type">const</span> VertexBufferLayout&amp; layout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    <span class="built_in">Bind</span>();</span><br><span class="line">    <span class="comment">// 绑定VBO</span></span><br><span class="line">	vb.<span class="built_in">Bind</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 顶点属性Layout</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; elements = layout.<span class="built_in">GetElements</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; elements.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; element = elements[i];</span><br><span class="line">        <span class="built_in">glVertexAttribPointer</span>(i, element.count,element.type,</span><br><span class="line">            element.normalized, layout.<span class="built_in">GetStride</span>(), (<span class="type">const</span> <span class="type">void</span>*) offset);</span><br><span class="line">        <span class="built_in">glEnableVertexAttribArray</span>(i);</span><br><span class="line">        offset += element.count * VertexBufferElement::<span class="built_in">GetSizeOfType</span>(element.type);</span><br><span class="line">        <span class="comment">//glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexArray::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="VertexArrayLayout"><a href="#VertexArrayLayout" class="headerlink" title="VertexArrayLayout"></a><strong>VertexArrayLayout</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VertexArrayLayout.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexBufferElement</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> normalized;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetSizeOfType</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">			<span class="keyword">case</span> GL_FLOAT:			<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">			<span class="keyword">case</span> GL_UNSIGNED_INT:	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">			<span class="keyword">case</span> GL_UNSIGNED_BYTE:	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ASSERT</span>(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBufferLayout</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;VertexBufferElement&gt; m_Elements;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Stride;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">VertexBufferLayout</span>()</span><br><span class="line">		: <span class="built_in">m_Stride</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">static_assert</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count) &#123;</span><br><span class="line">		m_Elements.<span class="built_in">push_back</span>(&#123; GL_FLOAT, count, GL_FALSE&#125;);</span><br><span class="line">		m_Stride += VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_FLOAT) * count;<span class="comment">//4 * 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用模板来完成不同类型顶点属性的添加，也方便进行其他类型的扩展</span></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count) &#123;</span><br><span class="line">		m_Elements.<span class="built_in">push_back</span>(&#123; GL_UNSIGNED_INT, count, GL_FALSE &#125;);</span><br><span class="line">		m_Stride += VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_INT) * count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">Push</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(<span class="type">unsigned</span> <span class="type">int</span> count) &#123;</span><br><span class="line">		m_Elements.<span class="built_in">push_back</span>(&#123; GL_UNSIGNED_BYTE, count, GL_TRUE &#125;);</span><br><span class="line">		m_Stride += VertexBufferElement::<span class="built_in">GetSizeOfType</span>(GL_UNSIGNED_BYTE) * count;<span class="comment">//GLbyte </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">const</span> std::vector&lt;VertexBufferElement&gt; <span class="title">GetElements</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Elements; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetStride</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Stride; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>作者在Bind和Unbind的地方其实处理得不是很舒服，受之前学长的影响，个人喜欢在添加完顶点属性后直接解绑，也就是AddBuffer函数之后，把va和vb解绑直接做掉。并且elementarray也就是IBO（EBO）Learnopengl中说过是绑定在VAO中的，可以不管。</p>
<h2 id="15-Shader-Abstraction"><a href="#15-Shader-Abstraction" class="headerlink" title="15 Shader Abstraction"></a><strong>15 Shader Abstraction</strong></h2><p>游戏和引擎中，通常有一种自定义着色语言，然后编译成每种api或平台适合的语言。并且是可控和可扩展的（着色器动态创建）。</p>
<p>我们在这里shader abstraction要完成的：</p>
<ol>
<li>能够使用文件和字符串编译shader</li>
<li>绑定和取消绑定</li>
<li>设置uniform</li>
</ol>
<h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a><strong>Shader</strong></h3><p>shader.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shader.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span><span class="comment">//hash table</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span> &#123;</span><br><span class="line">	std::string VertexSource;</span><br><span class="line">	std::string FrgmentSource;</span><br><span class="line">&#125;;<span class="comment">// 为了返回多重数据而制作一个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_FilePath;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m_UniformLocationCache;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath);</span><br><span class="line">	~<span class="built_in">Shader</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//set uniforms</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span>;</span><br><span class="line">	<span class="function">ShaderProgramSource <span class="title">ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Shader.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shader.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line">Shader::<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; filepath)</span><br><span class="line">    : <span class="built_in">m_FilePath</span>(filepath), <span class="built_in">m_RendererID</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ShaderProgramSource source = <span class="built_in">ParseShader</span>(filepath);</span><br><span class="line">    m_RendererID = <span class="built_in">CreateShader</span>(source.VertexSource, source.FrgmentSource);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shader::~<span class="built_in">Shader</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fail to complie &quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex &quot;</span> : <span class="string">&quot;fragment &quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ShaderProgramSource <span class="title">Shader::ParseShader</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span> &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line)) &#123;<span class="comment">//string头文件中的getline方法</span></span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">            <span class="comment">//std::string::npos,表示字符串末尾（无效字符串）</span></span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to vertex</span></span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="comment">// set mode to fragment</span></span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把代码添加到vs或fs的字符串流中</span></span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  &#123; ss[<span class="number">0</span>].<span class="built_in">str</span>(),ss[<span class="number">1</span>].<span class="built_in">str</span>() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Shader::CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glUseProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::SetUniform4f</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> v0, <span class="type">float</span> v1, <span class="type">float</span> v2, <span class="type">float</span> v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUniform4f</span>(<span class="built_in">GetUniformLocation</span>(name), v0, v1, v2, v3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Shader::GetUniformLocation</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//优化：我们每次setUniform的时候，都需要重新GetUniformLocation，找到属性在Layout中的位置</span></span><br><span class="line">    <span class="comment">//这是多余的消耗，我们可以用hash table 把它储存起来。</span></span><br><span class="line">    <span class="keyword">if</span> (m_UniformLocationCache.<span class="built_in">find</span>(name) != m_UniformLocationCache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> m_UniformLocationCache[name];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(m_RendererID, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">-1</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Warning: uniform &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#x27; dosen&#x27;t exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_UniformLocationCache[name] = location;</span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/OpenGL/Opengl%20learning_02/" data-id="cmfe1u6p9001bscuh4qvz0g1c" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/Opengl learning_03" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/OpenGL/Opengl%20learning_03/" class="article-date">
  <time datetime="2025-09-10T13:18:14.020Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="16-Writing-a-Basic-Renderer"><a href="#16-Writing-a-Basic-Renderer" class="headerlink" title="16 Writing a Basic Renderer"></a><strong>16 Writing a Basic Renderer</strong></h2><p>目前为止，如果我们每次想要绘制东西，都需要完成所有步骤-绑定-drawcall</p>
<p>希望能够提供</p>
<p>Renderer</p>
<p>unbind不是绝对的，但在debug中很有用，也许也能减少一些错误。但是实际上没有必要要，因为绑定下一个对象，就等于解绑了。</p>
<h3 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a><strong>Renderer</strong></h3><p>要注意Renderer.h这里有一些小坑，就是作者include了VertexArray.h，其中又include了VertexBufferLayout。但是之前为了方便把debug的函数写在了Renderer当中，导致这里出现了相互include。解决方法就是把VertexArray.h中对VertexBufferLayout的include去掉，改成对这个class的声明，然后因为VertexArray.h还是需要使用其内部方法，在VertexArray.cpp 中再include VertexBufferLayout。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Renderer.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexArray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IndexBuffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(x) <span class="keyword">if</span> (!(x)) __debugbreak();<span class="comment">//MSVC function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">	ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#把x转换成字符串 </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">const</span> VertexArray&amp; va, <span class="type">const</span> IndexBuffer&amp; ib, <span class="type">const</span> Shader&amp; shader)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">//vertex array, index buffer, shader</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Renderer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);<span class="comment">//!glGetError()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;<span class="comment">//提供函数名与文件名以及行数</span></span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL Error] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Clear</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Draw</span><span class="params">(<span class="type">const</span> VertexArray&amp; va, <span class="type">const</span> IndexBuffer&amp; ib, <span class="type">const</span> Shader&amp; shader)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    va.<span class="built_in">Bind</span>();</span><br><span class="line">    ib.<span class="built_in">Bind</span>();</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, ib.<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>drawcall</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    renderer.<span class="built_in">Clear</span>();</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line">    shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line">    r += increment;</span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在renderer当中有顶点数组和索引缓冲区以及一个shader。</p>
<p>但是相比于shader，在传统的渲染器中采用的是材质material。材质就是shader加上一组数据（uniforms）。</p>
<p>这样将material传递给renderer，它将直接把shader和uniform绑定，然后再进行drawcall。。。</p>
<p>在本教程中也许不会涉及，但是在Game Engine中一定需要做。</p>
<h2 id="17-Textures"><a href="#17-Textures" class="headerlink" title="17 Textures"></a><strong>17 Textures</strong></h2><p>我们会忽略游戏中使用的纹理格式，但反正肯定不是png</p>
<ul>
<li>将图片加载到cpu memory</li>
<li>将pixel array 传递到GPU</li>
<li>使用shader读取到texture</li>
</ul>
<p>我们这里将会使用#include &lt;stb_image.h&gt;来处理png图片</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h">stb&#x2F;stb_image.h at master · nothings&#x2F;stb (github.com)</a></p>
<p>(直接拿图形学课的框架里的用了)，我们实际上只需要使用stb_image.h</p>
<p>在项目中新建stb_image.h和stb_image.cpp文件，把头文件直接复制进去，并且根据注释说明，在cpp文件中添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>这样就可以使用了。</p>
<p>然后我们要添加texture类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Texture.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	std::string m_FilePath;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* m_LocalBuffer;</span><br><span class="line">	<span class="type">int</span> m_Width, m_Height, m_BPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path);</span><br><span class="line">	~<span class="built_in">Texture</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// windows有32个 slot，移动平台如iphone有8个slot，这取决于GPU</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Width; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Height; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Texture.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Texture.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vendor/stb_image/stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Texture::<span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path)</span><br><span class="line">	: <span class="built_in">m_RendererID</span>(<span class="number">0</span>),	<span class="built_in">m_FilePath</span>(path), 	<span class="built_in">m_LocalBuffer</span>(<span class="literal">nullptr</span>), </span><br><span class="line">	<span class="built_in">m_Width</span>(<span class="number">0</span>),	<span class="built_in">m_Height</span>(<span class="number">0</span>), <span class="built_in">m_BPP</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//opengl希望pixel坐标从bottom-left开始</span></span><br><span class="line">	<span class="comment">//通常以扫描线的方式加载图片，左上角是起始点</span></span><br><span class="line"></span><br><span class="line">	m_LocalBuffer = <span class="built_in">stbi_load</span>(path.<span class="built_in">c_str</span>(), &amp;m_Width, &amp;m_Height, &amp;m_BPP, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;m_RendererID));</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_RendererID));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, m_Width, m_Height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">GLCall</span>(<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_LocalBuffer)</span><br><span class="line">		<span class="built_in">stbi_image_free</span>(m_LocalBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Texture::~<span class="built_in">Texture</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">glDeleteTextures</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Texture::Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glActiveTexture</span>( GL_TEXTURE0 + slot);</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Texture::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这中间还有一些需要修改的，比如uniform、shader中的varying变量(in、out)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::SetUniform1i</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUniform1i</span>(<span class="built_in">GetUniformLocation</span>(name), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当画出来的屏幕是黑的时候，加上GLCall()来debug就显得非常好用了</p>
<p>直接提示到我们</p>
<p>是这句发生了错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, m_Width, m_Height, <span class="number">0</span>, GL_RGBA8, GL_UNSIGNED_BYTE, m_LocalBuffer);</span><br><span class="line"><span class="comment">//对照教程，需要改成</span></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, m_Width, m_Height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer);</span><br></pre></td></tr></table></figure>

<p>根据文档，这里两个format分别是internal format和format。internal format是opengl储存纹理的方法。format是提供的纹理的格式。所以我们提供GL_RGBA8告诉opengl储存单通道8位。而我们提供的纹理则是GL_RGBA格式的。</p>
<p>这样就非常完美地画出了薰。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911011136266.png" alt="image-20220911011136266"></p>
<p>(作者由于透明度混合设置的问题，图片出现了失真。)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br></pre></td></tr></table></figure>



<h2 id="18-Blending"><a href="#18-Blending" class="headerlink" title="18 Blending"></a><strong>18 Blending</strong></h2><p>Blending determines how we combine our output color with what is already in our target buffer.</p>
<ul>
<li>output<ul>
<li>the color we output from our fragment shader</li>
</ul>
</li>
<li>Target buffer<ul>
<li>the buffer our fs is drawing to (destination)</li>
</ul>
</li>
</ul>
<p>如何控制Blending</p>
<ul>
<li>glEnable(GL_BLEND)-glDisable(GL_BLEND)</li>
<li>glBlendFunc(src, dest)<ul>
<li>src &#x3D; how the src RGBA factor is computed(default is GL_ONE)</li>
<li>dest &#x3D; how the dest RGBA factor is computed(default is GL_ZERO)</li>
</ul>
</li>
<li>glBlendEquation(mode)（BlendOp）<ul>
<li>mode &#x3D; how we combine the src and dest colors</li>
<li>Defualt value is GL_FUNC_ADD</li>
</ul>
</li>
</ul>
<h2 id="19-Maths"><a href="#19-Maths" class="headerlink" title="19 Maths"></a><strong>19 Maths</strong></h2><p>ignored</p>
<p>在该教程中会使用glm（适用于opengl的数学库）。并且适配与opengl列主序的矩阵。</p>
<p>通常在我们自己写跨平台的引擎时，也会自己写数学库。可以是行主序的。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/g-truc/glm/releases">Releases · g-truc&#x2F;glm (github.com)</a></p>
<p>我们可以在glm的git上下到release版，这里还是就直接把之前的复制到Dependencies里了。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911170351237.png" alt="image-20220911170351237"></p>
<p>实际上我们只需要glm文件夹里的东西。</p>
<p>作者把它也放进了vendor文件夹里。</p>
<p>（其实我也更倾向放到Dependencie里作为附加包含目录）</p>
<p>GLM也是一个只包含头文件的库，没有cpp文件，不需要编译</p>
<p>事实上，作者随后就把vendor文件夹放到了附加包含目录里。。。</p>
<h2 id="20-Projection-Matrices"><a href="#20-Projection-Matrices" class="headerlink" title="20 Projection Matrices"></a><strong>20 Projection Matrices</strong></h2><p>在projection中我们完成了归一化齐次坐标[-1,1]^3</p>
<p>略了</p>
<h2 id="21-Model-View-Projection-Matrices"><a href="#21-Model-View-Projection-Matrices" class="headerlink" title="21 Model View Projection Matrices"></a><strong>21 Model View Projection Matrices</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">-1.5f</span>, <span class="number">1.5f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">glm::mat4 mvp = proj * view * model;</span><br></pre></td></tr></table></figure>

<p>在这里对view的处理很简单，就是我们向右移动相机，等同于向左移动物体。</p>
<h2 id="22-ImGui"><a href="#22-ImGui" class="headerlink" title="22 ImGui"></a><strong>22 ImGui</strong></h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><strong>环境配置</strong></h3><p>这里只是简单地将imgui移植到我们的opengl中，</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui">ocornut&#x2F;imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a></p>
<p>下载到release的source code</p>
<p>它提供了我们一个vs工程文件和一大堆各种平台的项目，我们也可以在这里面找到关于glfw_opengl3的example</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911224925272.png" alt="image-20220911224925272" style="zoom:50%;" />

<p>而我们实际需要的是根目录下的那些头文件和cpp文件。总之我们把他们复制到vendor中的imgui文件夹，就可以用了。</p>
<p>我对比了一下这里的以及图形学课用的框架里的，多了这四个文件</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911225155782.png" alt="image-20220911225155782"></p>
<p>可以看到这是imgui对glfw和opengl的实现（implementation）。在作者下载的imgui版本中，它们存在于examples当中（opengl3_example），但是我这里下载的版本已经更新了。</p>
<p>找了一下，它们已经更换了目录结构，现在这些impl文件都在backends文件夹中</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911230018016.png" alt="image-20220911230018016"></p>
<p>所以我们还是得把这四个文件复制过去。</p>
<p>作者的版本当中的imgl_glfw使用了gl3w，有提示需要改成glew，但在我们这里没有这个问题。</p>
<p>但我们编译时会发现它新增了一个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modern desktop OpenGL doesn&#x27;t have a standard portable header file to load OpenGL function pointers.</span></span><br><span class="line"><span class="comment">// Helper libraries are often used for this purpose! Here we are using our own minimal custom loader based on gl3w.</span></span><br><span class="line"><span class="comment">// In the rest of your app/engine, you can use another loader of your choice (gl3w, glew, glad, glbinding, glext, glLoadGen, etc.).</span></span><br><span class="line"><span class="comment">// If you happen to be developing a new feature for this backend (imgui_impl_opengl3.cpp):</span></span><br><span class="line"><span class="comment">// - You may need to regenerate imgui_impl_opengl3_loader.h to add new symbols. See https://github.com/dearimgui/gl3w_stripped</span></span><br><span class="line"><span class="comment">// - You can temporarily use an unstripped version. See https://github.com/dearimgui/gl3w_stripped/releases</span></span><br><span class="line"><span class="comment">// Changes to this backend using new APIs should be accompanied by a regenerated stripped loader version.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMGL3W_IMPL</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui_impl_opengl3_loader.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>意思就是。。。他们还是自己搞了一个gl3w，并且封装在这个loader头文件中了。。。我们直接删掉这是两行换成glew，看看理解对不对</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GL/glew.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>如下</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911234624507.png" alt="image-20220911234624507"></p>
<p>然而不对，这里后面会用到gl3w的api</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/issues/4445">OpenGL 后端现在嵌入了自己的 GL 加载程序 （imgui_impl_opengl3_loader.h） ·问题 #4445 ·ocornut&#x2F;imgui (github.com)</a></p>
<p>后来感觉这样还是不行，loader里面就是对gl3w的实现了，我们应该直接换glew。因此注释掉上面两行以后，定位到接下来的问题</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220911233503486.png" alt="image-20220911233503486"></p>
<p>对于这里的初始化，我们直接给换成glewInit。这样就顺利运行了。</p>
<p>还是踩了些小坑，麻烦的话就直接跟着教程版本一致就好了。</p>
<h3 id="使用imgui"><a href="#使用imgui" class="headerlink" title="使用imgui"></a><strong>使用imgui</strong></h3><p>我们还是可以参考example中main里面的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup Dear ImGui context</span></span><br><span class="line"><span class="built_in">IMGUI_CHECKVERSION</span>();</span><br><span class="line">ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>(); (<span class="type">void</span>)io;</span><br><span class="line"><span class="comment">//io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls</span></span><br><span class="line"><span class="comment">//io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup Dear ImGui style</span></span><br><span class="line">ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"><span class="comment">//ImGui::StyleColorsClassic();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup Platform/Renderer backends</span></span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(window, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_Init</span>(glsl_version);</span><br></pre></td></tr></table></figure>

<p>和教程里面稍有变化（瑟瑟发抖，感觉坑会越来越多了，有点后悔），幸好和图形学课里的框架还是比较接近的，还算能参考一下。</p>
<p>助教的框架向上再封装了一层。这个教程这里大概是为了简单，直接写在了main函数里。</p>
<p>直接把上面的初始化复制上去，然后回头添加头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;imgui/imgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;imgui/imgui_impl_glfw.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;imgui/imgui_impl_opengl3.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>还有个glsl_version变量，在example里面是定义的。但是我们去这个函数里看一看，其实如果直接给NULL的话，是有默认值的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Store GLSL version string so we can refer to it later in case we recreate shaders.</span></span><br><span class="line">    <span class="comment">// Note: GLSL version is NOT the same as GL version. Leave this to NULL if unsure.</span></span><br><span class="line">    <span class="keyword">if</span> (glsl_version == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(IMGUI_IMPL_OPENGL_ES2)</span></span><br><span class="line">        glsl_version = <span class="string">&quot;#version 100&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(IMGUI_IMPL_OPENGL_ES3)</span></span><br><span class="line">        glsl_version = <span class="string">&quot;#version 300 es&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__APPLE__)</span></span><br><span class="line">        glsl_version = <span class="string">&quot;#version 150&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        glsl_version = <span class="string">&quot;#version 130&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>并且注释很贴心地告诉我们，如果不确定glsl的版本，就直接留空</p>
<p>所以这个glsl_version变量我们直接删掉。</p>
<p>虽然和教程里面不一样，会多一些步骤，但像这样自己解决掉问题还是会很有成就感的吧，其实也不难对吧。</p>
<p>（实际上作者也跳过了里面io的初始化，这个我们也可以删掉）</p>
<p>然后是循环中的newframe步骤（作者仅需一行，我们这里变成了三行）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the Dear ImGui frame</span></span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">ImGui::<span class="built_in">NewFrame</span>();</span><br></pre></td></tr></table></figure>

<p>关于位置，助教框架的做法是——先渲染画面，再渲染gui。这一部分放在一个renderframe函数中，向上封装的流程是——输入输出处理-renderframe-swapbuffer-pollEvent</p>
<p>这也很符合逻辑，我们就也把这部分放在交换缓冲之前好了。（其实作者提出放哪里都行，只要Imgui的代码是放在这里面end之前就好了）</p>
<p>然后我们添加render命令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">Render</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在循环结束后，我们还要shutdown</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ImGui_ImplOpenGL3_Shutdown</span>();</span><br><span class="line"><span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">ImGui::<span class="built_in">DestroyContext</span>();</span><br></pre></td></tr></table></figure>

<p>然后关于gui里的具体内容我们就复制一下example的就好了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Hello, world!&quot;</span>);                          <span class="comment">// Create a window called &quot;Hello, world!&quot; and append into it.</span></span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;This is some useful text.&quot;</span>);               <span class="comment">// Display some text (you can use a format strings too)</span></span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Demo Window&quot;</span>, &amp;show_demo_window);      <span class="comment">// Edit bools storing our window open/close state</span></span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Another Window&quot;</span>, &amp;show_another_window);</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;float&quot;</span>, &amp;f, <span class="number">0.0f</span>, <span class="number">1.0f</span>);            <span class="comment">// Edit 1 float using a slider from 0.0f to 1.0f</span></span><br><span class="line">    ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;clear color&quot;</span>, (<span class="type">float</span>*)&amp;clear_color); <span class="comment">// Edit 3 floats representing a color</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>))                            <span class="comment">// Buttons return true when clicked (most widgets return true when edited/activated)</span></span><br><span class="line">        counter++;</span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;counter = %d&quot;</span>, counter);</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（还有三个小变量，直接复制一下就好了）</p>
<p>非常好用。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220912001607129.png" alt="image-20220912001607129" style="zoom:50%;" />



<p>然后我们要开始改造自己需要的gui了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translation);</span><br><span class="line">glm::mat4 mvp = proj * view * model;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#123;</span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">&quot;Translation&quot;</span>, &amp;translation.x, <span class="number">-2.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们把model的修改移动到主循环当中，也非常好用。</p>
<p>这里我们使用的Float3，只提供了第一个translation.x 的指针。在使用的时候我们也要注意，glm::vec3这种结构储存的数据在内存上是不是连续的。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220912003032134.png" alt="image-20220912003032134" style="zoom:50%;" />



<h2 id="23-Rendering-Multiple-Objects"><a href="#23-Rendering-Multiple-Objects" class="headerlink" title="23 Rendering Multiple Objects"></a><strong>23 Rendering Multiple Objects</strong></h2><p>回顾我们之前的drawcall的部分，主要是这几个步骤</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shader.<span class="built_in">Bind</span>();</span><br><span class="line">va.<span class="built_in">Bind</span>();</span><br><span class="line">ib.<span class="built_in">Bind</span>();</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, ib.<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>

<p>分析shader当中，我们想要画出另一个位置的物体，我们可以提供一个不同的vertex buffer</p>
<p>那么当然也可以使用另一个mvp（这当然也更快）。</p>
<p> 当我们要绘制同一个物体很多次时（如tile类型的这种东西）我们没有必要用for loop像这样去绘制很多次，而是可以用&#x3D;&#x3D;batching&#x3D;&#x3D; 合批的方法，只调用一次drawcall，把所有的东西放到一个vertex buffer里。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/OpenGL/Opengl%20learning_03/" data-id="cmfe1u6p9001dscuh6a5khrgx" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/Opengl learning_04" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/OpenGL/Opengl%20learning_04/" class="article-date">
  <time datetime="2025-09-10T13:18:14.020Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="24-Setting-up-a-Test-Framework"><a href="#24-Setting-up-a-Test-Framework" class="headerlink" title="24 Setting up a Test Framework"></a><strong>24 Setting up a Test Framework</strong></h2><p>  这次我们要对代码进行一些整理，为之后做好铺垫。</p>
<p>因为如果我们想让系统变得更复杂的话，像这样做是不行的。</p>
<p>首先清理下代码的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;GlewInit fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line"></span><br><span class="line">    Renderer renderer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup Dear ImGui context</span></span><br><span class="line">    <span class="built_in">IMGUI_CHECKVERSION</span>();</span><br><span class="line">    ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">    ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup Platform/Renderer backends</span></span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(window, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        renderer.<span class="built_in">Clear</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">        ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">Render</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//glDeleteProgram(shader);//有析构函数</span></span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_Shutdown</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">    ImGui::<span class="built_in">DestroyContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后添加test</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test::TestClearColor test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">OnUpdate</span>(<span class="number">0.0f</span>);</span><br><span class="line">    test.<span class="built_in">OnRender</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">    ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">OnImGuiRender</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以看到如下结果</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917153535589.png" alt="image-20220917153535589" style="zoom:50%;" />

<p>test的部分结构如下</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917153643711.png" alt="image-20220917153643711"></p>
<p>Test.h</p>
<p>作为Test的父类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Test</span>() &#123;&#125;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Test</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TestClearColor.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">TestClearColor</span> : <span class="keyword">public</span> Test &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">TestClearColor</span>();</span><br><span class="line">		~<span class="built_in">TestClearColor</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">float</span> m_ClearColor[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//TestClearColor.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestClearColor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">	TestClearColor::<span class="built_in">TestClearColor</span>() </span><br><span class="line">		: m_ClearColor &#123;<span class="number">0.2f</span>,<span class="number">0.3f</span>,<span class="number">0.8f</span>,<span class="number">1.0f</span>&#125; &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TestClearColor::~<span class="built_in">TestClearColor</span>() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(m_ClearColor[<span class="number">0</span>],</span><br><span class="line">                            m_ClearColor[<span class="number">1</span>],m_ClearColor[<span class="number">2</span>],m_ClearColor[<span class="number">3</span>]));</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestClearColor::OnImGuiRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Clear Color&quot;</span>, m_ClearColor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就建立好了test的架构。</p>
<p>其实基于这个架构，我们可以做很多事了，例如在imgui上用菜单控制各种变量、贴图。。。</p>
<p>接下来我们要建立一个test的菜单，而不是直接打开test</p>
<h2 id="25-Creating-Tests"><a href="#25-Creating-Tests" class="headerlink" title="25 Creating Tests"></a><strong>25 Creating Tests</strong></h2><p>Test.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>&#123;&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">TestMenu</span> : <span class="keyword">public</span> Test &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//void OnUpdate(float deltaTime) override;</span></span><br><span class="line">		<span class="comment">//void OnRender() override;</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">		<span class="comment">// 构造一个pari传入m_Tests中，分别是我们获得的名称和lambda，lambda的类型来自模板类型</span></span><br><span class="line">		<span class="comment">// lambda这里C++还没看过，以及function的标准函数也不太了解，到时候要去补一下C++这部分</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">RegisterTest</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Registering test &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">			m_Tests.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(name, []() &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;));</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Test*&amp; m_CurrentTest;<span class="comment">//我们的按钮会控制当前的Test, 把当前Test的引用传递到这里的成员指针</span></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 我们并不想直接要一个test的指针，这样就代表这个实例已经被创建了</span></span><br><span class="line">		<span class="comment">// 而我们希望的是按下按钮，才创建和构造一个test的实例</span></span><br><span class="line">		<span class="comment">// 因此我们提供一个lambda的function，来构造一个test</span></span><br><span class="line">		<span class="comment">//vector储存一个pari，每个pari里有一个string表示Test的名称，function返回一个test的指针</span></span><br><span class="line"></span><br><span class="line">		std::vector&lt;std::pair&lt;std::string, std::function&lt;Test* ()&gt;&gt;&gt; m_Tests;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">    TestMenu::<span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer) </span><br><span class="line">        : <span class="built_in">m_CurrentTest</span>(currentTestPointer) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestMenu::OnImGuiRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; test : m_Tests) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(test.first.<span class="built_in">c_str</span>()))</span><br><span class="line">                m_CurrentTest = test.<span class="built_in">second</span>();<span class="comment">//按下按钮，则自动构造一个test实例，并把指针传递给m_CurrentTest</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">test::Test* currentTest = <span class="literal">nullptr</span>;</span><br><span class="line">test::TestMenu* testMenu = <span class="keyword">new</span> test::<span class="built_in">TestMenu</span>(currentTest);</span><br><span class="line">currentTest = testMenu;</span><br><span class="line"><span class="comment">//这样做的结果是，menu里的m_CurrentTest当前就储存的自己。</span></span><br><span class="line"><span class="comment">//因为我们没有必要每次都要设置一个初始的Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望这样来设置Test，传入模板参数提供类型，以及对应的名称</span></span><br><span class="line"><span class="comment">//作者提出一种模块化coding的方式，就是先假装以及有这个功能，然后去使用，再回来实现</span></span><br><span class="line">testMenu-&gt;<span class="built_in">RegisterTest</span>&lt;test::TestClearColor&gt;(<span class="string">&quot;Clear Color&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">    ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTest) &#123;</span><br><span class="line">        currentTest-&gt;<span class="built_in">OnUpdate</span>(<span class="number">0.0f</span>);</span><br><span class="line">        currentTest-&gt;<span class="built_in">OnRender</span>();</span><br><span class="line">        ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (currentTest != testMenu &amp;&amp; ImGui::<span class="built_in">Button</span>(<span class="string">&quot;&lt;-&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> currentTest;</span><br><span class="line">            currentTest = testMenu;</span><br><span class="line">        &#125;<span class="comment">//删除当前Test后，回到testMenu</span></span><br><span class="line">        currentTest-&gt;<span class="built_in">OnImGuiRender</span>();</span><br><span class="line">        ImGui::<span class="built_in">End</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> currentTest;<span class="comment">//currentTest 的实例创建是模板的lambda里做的</span></span><br><span class="line"><span class="keyword">if</span> (currentTest != testMenu)</span><br><span class="line">    <span class="keyword">delete</span> testMenu;</span><br></pre></td></tr></table></figure>

<p>我们运行后，啥都没有</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917170520171.png" alt="image-20220917170520171" style="zoom:50%;" />



<p>但是点击Clear Color的button以后，就获得了前面的Clear Color的功能，并且包含一个回退按钮，再点击这个回退按钮</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917170553457.png" alt="image-20220917170553457" style="zoom:50%;" />

<p>再点击这个回退按钮，这个Test实例就被注销了，并且UI也回到原来的界面，但由于Opengl是状态机修改，所以背景色的状态没有变回去</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220917170625931.png" alt="image-20220917170625931" style="zoom:50%;" />

<p>作者在循环开始时加上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure>

<p>这样就能保证不存在TestClearColor实例时，有一个固定的背景色。（即注销实例后，背景色会清空）</p>
<p>为了防止内存溢出，在循环结束后，我们还要把new出来的test删掉</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> currentTest;</span><br><span class="line"><span class="keyword">if</span> (currentTest != testMenu)</span><br><span class="line">    <span class="keyword">delete</span> testMenu;</span><br></pre></td></tr></table></figure>





<h2 id="26-Creating-a-Texture-Test"><a href="#26-Creating-a-Texture-Test" class="headerlink" title="26 Creating a Texture Test"></a><strong>26 Creating a Texture Test</strong></h2><p>以上搭建的框架，其实就是建立了一个类似于沙盒，我们可以在里面设置各种测试Test</p>
<p>在之后的工作会进行Batch Rendering</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBufferLayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">TestTexture2D</span> : <span class="keyword">public</span> Test &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">TestTexture2D</span>();</span><br><span class="line">		~<span class="built_in">TestTexture2D</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::unique_ptr&lt;VertexArray&gt; m_VAO;</span><br><span class="line">		std::unique_ptr&lt;IndexBuffer&gt; m_IndexBuffer;</span><br><span class="line">		std::unique_ptr&lt;Shader&gt; m_Shader;</span><br><span class="line">		std::unique_ptr&lt;Texture&gt; m_Texture;</span><br><span class="line">		std::unique_ptr&lt;VertexBuffer&gt; m_VertexBuffer;</span><br><span class="line">		glm::mat4 m_Proj, m_View;</span><br><span class="line">		glm::vec3 m_TranslationA, m_TranslationB;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TestTexture2D.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestTexture2D.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glm/glm.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glm/gtc/matrix_transform.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">	TestTexture2D::<span class="built_in">TestTexture2D</span>() </span><br><span class="line">		: <span class="built_in">m_Proj</span>(glm::<span class="built_in">ortho</span>(<span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">-1.5f</span>, <span class="number">1.5f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)),</span><br><span class="line">		  <span class="built_in">m_View</span>(glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))),</span><br><span class="line">		<span class="built_in">m_TranslationA</span>((<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>)), <span class="built_in">m_TranslationB</span>((<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">		 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="type">float</span> positions[<span class="number">16</span>] = &#123;</span><br><span class="line">			<span class="number">-2.0f</span>, <span class="number">-1.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">			 <span class="number">2.0f</span>, <span class="number">-1.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">			 <span class="number">2.0f</span>,  <span class="number">1.5f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">			<span class="number">-2.0f</span>,  <span class="number">1.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">				&#125;;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">			<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">			<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">		<span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		m_VAO = std::<span class="built_in">make_unique</span>&lt;VertexArray&gt;();</span><br><span class="line">		m_VertexBuffer = std::<span class="built_in">make_unique</span>&lt;VertexBuffer&gt;(positions, <span class="number">4</span> * <span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">		VertexBufferLayout layout;</span><br><span class="line">		layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">		layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">		m_VAO-&gt;<span class="built_in">AddBuffer</span>(*m_VertexBuffer, layout);</span><br><span class="line">		m_IndexBuffer = std::<span class="built_in">make_unique</span>&lt;IndexBuffer&gt;(indices, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		m_Shader = std::<span class="built_in">make_unique</span>&lt;Shader&gt;(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line">		m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">		m_Shader-&gt;<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		m_Texture = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">&quot;res/textures/2.png&quot;</span>);</span><br><span class="line">		m_Texture-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">		m_Shader-&gt;<span class="built_in">SetUniform1i</span>(<span class="string">&quot;u_Texture&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TestTexture2D::~<span class="built_in">TestTexture2D</span>() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnUpdate</span><span class="params">(<span class="type">float</span> deltaTime)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>));</span><br><span class="line">		<span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">		Renderer renderer;</span><br><span class="line"></span><br><span class="line">		m_Texture-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationA);</span><br><span class="line">			glm::mat4 mvp =m_Proj * m_View * model;</span><br><span class="line">			m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">			m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">			renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationB);</span><br><span class="line">			glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line">			m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">			m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">			renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestTexture2D::OnImGuiRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">&quot;Translation A&quot;</span>, &amp;m_TranslationA.x, <span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">		ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">&quot;Translation B&quot;</span>, &amp;m_TranslationB.x, <span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">		ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里完成后，只需在main中注册。</p>
<h2 id="Batch-Rendering"><a href="#Batch-Rendering" class="headerlink" title="Batch Rendering"></a><strong>Batch Rendering</strong></h2><ul>
<li><p>在处理Texture的时候要注意，由于最大的Texture slot数量的限制（比如上一章节讲texture里提过当前windows最大的数量32），同一个batch往往不能容纳足够的Texture，那么只能把多余的texture对应的网格渲染放到下一个batch，以此类推。</p>
</li>
<li><p>假如100个submesh，对应100个texture，每32个texture对应的mesh合批，这样也只需要4个drawcall</p>
</li>
<li><p>静态合批大抵就是如此（把不同mesh的vertex组合起来）</p>
</li>
</ul>
<h3 id="Dynamic-Geometry"><a href="#Dynamic-Geometry" class="headerlink" title="Dynamic Geometry"></a><strong>Dynamic Geometry</strong></h3><p>这一段就是讲动态合批。</p>
<ul>
<li><p>静态合批是我们一开始就设定好了合批的数据，每一帧只需要渲染这些已经传递到GPU的数据。</p>
</li>
<li><p>而我们希望对于动态的物体也能进行合批。</p>
</li>
<li><p>重要的依然是这两部分：vertex buffer和index buffer</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220924145750783.png" alt="image-20220924145750783" style="zoom: 67%;" />

<p>除了提前准备了这一部分数据，我们还使用</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFER,<span class="built_in">sizeof</span>(vertices),vertices,GL_STATIC_DRAW)</span><br></pre></td></tr></table></figure>

<p>在update前将数据储存到GPU。</p>
<p>而为了动态改变数据，我们可以只创建buffer，但是先不传递数据，即传递一个空指针。</p>
<p>我们也可以根据我们的顶点结构和需要的顶点数量来决定buffer的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span>&#123;</span><br><span class="line">	<span class="type">float</span> Position[<span class="number">3</span>];</span><br><span class="line">    <span class="type">float</span> Color[<span class="number">4</span>];</span><br><span class="line">    <span class="type">float</span> TexCoords[<span class="number">2</span>];</span><br><span class="line">    <span class="type">float</span> TexID;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后就是绘制方式，不再是Static，我们要换成dynamic</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFER,<span class="number">1000</span>*<span class="built_in">sizeof</span>(Vertex),<span class="literal">nullptr</span>,GL_DYNAMIC_DRAW)</span><br></pre></td></tr></table></figure>

<p>其他关于顶点属性绑定之类都是一样的，只不过可以利用Vertex的结构来让它变得更通用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexArrayAttrib</span>(m_QuadVB,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>,<span class="number">3</span>,GL_FLOAT,GL_FALSE,<span class="built_in">sizeof</span>(Vertex), (<span class="type">const</span> <span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, Position));</span><br><span class="line"><span class="built_in">glEnableVertexArrayAttrib</span>(m_QuadVB,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>,<span class="number">4</span>,GL_FLOAT,GL_FALSE,<span class="built_in">sizeof</span>(Vertex), (<span class="type">const</span> <span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, Color));</span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<p>IB在合批中也不应该被改变。虽然我们动态地改变了顶点的属性，但是这些跟IB有什么关系。</p>
<p>在数量庞大的vertices当中，往往也需要用for loop来构建indices。（去年可视化的性能优化工作就是手动做了静态合批这件事……虽然当时并不知道合批这个概念）</p>
<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a><strong>Update</strong></h4><p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220924153010284.png" alt="image-20220924153010284"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set dynamic buffer</span></span><br><span class="line"><span class="comment">//OnUpdate</span></span><br><span class="line"><span class="comment">//float vertices[] =&#123;....&#125;;之后在这里我们每一帧都可能对顶点数据做出改变</span></span><br><span class="line"><span class="comment">//也可以用一些封装的方法</span></span><br><span class="line"><span class="comment">//这里作者也出现一个问题，就是前面Vertex的结构里定义的是数组，不能直接赋值一个结构，因此他改成了vec的结构</span></span><br><span class="line"><span class="keyword">auto</span> q0 = <span class="built_in">CreateQuad</span>(<span class="number">-1.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>);<span class="comment">//x,y,texID</span></span><br><span class="line"><span class="keyword">auto</span> q1 = <span class="built_in">CreateQuad</span>(<span class="number">0.5f</span>,<span class="number">-0.5f</span>,<span class="number">1.0f</span>);</span><br><span class="line">Vertex vertices[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(vertices,q<span class="number">0.</span><span class="built_in">data</span>(), q<span class="number">0.</span><span class="built_in">size</span>()*<span class="built_in">sizeof</span>(Vertex));</span><br><span class="line"><span class="built_in">memcpy</span>(vertices+q<span class="number">0.</span><span class="built_in">size</span>(),q<span class="number">1.</span><span class="built_in">data</span>(), q<span class="number">1.</span><span class="built_in">size</span>()*<span class="built_in">sizeof</span>(Vertex));</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_QuadVB);</span><br><span class="line"><span class="comment">//glMapBuffer()我们可以用这个方法直接将数据写入缓冲</span></span><br><span class="line"><span class="comment">//也有glUnmapBuffer，把buffer从GPU上卸载下来</span></span><br><span class="line"><span class="comment">//但是这个方法会慢一点</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER,<span class="number">0</span>,<span class="built_in">sizeof</span>(vertices),vertices);</span><br><span class="line"><span class="comment">//这个方法和glBufferData很像，但它不分配缓冲，仅仅是将数据放进去</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们就可以通过各种方式来改变绘制的顶点数据</p>
<p>比如通过gui来控制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OnImGuiRender</span></span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Controls&quot;</span>);</span><br><span class="line">ImGui::<span class="built_in">DragFloat2</span>(<span class="string">&quot;Quad Pos&quot;</span>,m_QuadPosition, <span class="number">0.1f</span>);</span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//OnUpdate</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//q0 = Create(m_QuadPosition[0],m_QuadPosition[1],0.0f);</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>这样就完成了动态的vertex buffer绘制，以及动态合批，我们只创建了一个vertex buffer，调用了一次drawcall。</p>
<h4 id="Indices"><a href="#Indices" class="headerlink" title="Indices"></a><strong>Indices</strong></h4><p>对于两个quad，我们很简单地就可以直接写出合批的indices</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是对于数量更多的mesh，我们也可以有一定的规律来写出。</p>
<p>首先依然要决定我们要绘制多少个四边形，以1000个为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> MaxQuadCount = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//这既决定Vertex的数量，也决定indices的数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> MaxVertexCount = MaxQuadCount * <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> MaxIndexCount = MaxQuadCount * <span class="number">6</span>;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER,<span class="built_in">sizeof</span>(Vertex) * MaxVertexCount,<span class="literal">nullptr</span>,GL_DYNAMIC_DRAW);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="type">uint32_t</span> indices[MaxIndexCount];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;MaxIndexCount;i+=<span class="number">6</span>)&#123;</span><br><span class="line">    indices[i<span class="number">+0</span>]=<span class="number">0</span>+offset;</span><br><span class="line">    indices[i<span class="number">+1</span>]=<span class="number">1</span>+offset;</span><br><span class="line">    indices[i<span class="number">+2</span>]=<span class="number">2</span>+offset;</span><br><span class="line">    indices[i<span class="number">+3</span>]=<span class="number">2</span>+offset;</span><br><span class="line">    indices[i<span class="number">+4</span>]=<span class="number">3</span>+offset;</span><br><span class="line">    indices[i<span class="number">+5</span>]=<span class="number">0</span>+offset;</span><br><span class="line">    </span><br><span class="line">    offset += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/OpenGL/Opengl%20learning_04/" data-id="cmfe1u6pa001fscuh7d4kd0jz" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/C++ learning_04" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/OpenGL/C++%20learning_04/" class="article-date">
  <time datetime="2025-09-10T13:18:14.019Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h3><h3 id="Virtual-Destructors"><a href="#Virtual-Destructors" class="headerlink" title="Virtual Destructors"></a>Virtual Destructors</h3><h3 id="Casting"><a href="#Casting" class="headerlink" title="Casting"></a>Casting</h3><h3 id="Conditional-and-Action-Breakpoints"><a href="#Conditional-and-Action-Breakpoints" class="headerlink" title="Conditional and Action Breakpoints"></a>Conditional and Action Breakpoints</h3><h3 id="Safety-in-modern-C-and-how-to-teach-it"><a href="#Safety-in-modern-C-and-how-to-teach-it" class="headerlink" title="Safety in modern C++ and how to teach it"></a>Safety in modern C++ and how to teach it</h3><h3 id="Precompiled-Headers-in-C"><a href="#Precompiled-Headers-in-C" class="headerlink" title="Precompiled Headers in C++"></a>Precompiled Headers in C++</h3><p>在大型项目中预编译头（PCH）可能更常用。</p>
<p>获取头文件并转换到一种编译后的格式，这一编译器就可以直接使用，而不需要每次编译都读取</p>
<p>如STL，每次<code>#include&lt;vector&gt;</code>都需要读取整个头文件，vector的头文件也需要读取。</p>
<p>这样编译时间就会很长。并且每次都要重复编译。</p>
<p>因此预编译头就把一大堆头文件编译一次，处理成二进制格式，这样编译器就可以很快处理。</p>
<h4 id="Not-to-do"><a href="#Not-to-do" class="headerlink" title="Not to do"></a>Not to do</h4><p>预编译头重新构建也需要花时间，因此不要把经常改动的文件放进去，</p>
<p>因此预编译头常用于外部库。如STL，glfw</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pch.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;funcitonal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Data Stuctures</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows API</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>那么如果不用预编译头的话，每次编译的中间文件都会把这一大堆头文件里的代码复制进去。（实测有接近4w行，就为了一个hello world）</p>
<p>所以只需要在做一个cpp文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pch.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>在这个文件的C++属性中开启创建预编译头属性</p>
<p><img src="/C++%20learning_04/image-20230409164925404.png" alt="image-20230409164925404"></p>
<p>并在项目设置中同样位置设置成使用预编译头，并选择对应的头文件。</p>
<p><img src="/C++%20learning_04/image-20230409165118838.png" alt="image-20230409165118838"></p>
<p>那么就会在对应位置生成一个预编译头的输出文件</p>
<p>Cherno也演示了用g++如何使用预编译头。直接编译pch.h，会出现一个gch文件，这也就是预编译头的输出文件了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/OpenGL/C++%20learning_04/" data-id="cmfe1u6p80015scuhapn06nfn" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/C++ learning_03" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/OpenGL/C++%20learning_03/" class="article-date">
  <time datetime="2025-09-10T13:18:14.019Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="Templates模板"><a href="#Templates模板" class="headerlink" title="Templates模板"></a><strong>Templates模板</strong></h3><p>模板就像一个蓝图</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">	std::cout&lt;&lt;value&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(std::string value)</span> </span>&#123;</span><br><span class="line">	std::cout&lt;&lt;value&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">5</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hellow&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5.0f</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种不断重复重载的函数可以用一个函数包裹，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">	std::cout&lt;&lt;value&lt;&lt;std::endl;</span><br><span class="line">&#125;<span class="comment">//这个函数是一个模板，只有当调用时，它才创建一个对应的函数</span></span><br><span class="line"><span class="comment">//它不参与编译，只有它创建的函数才参与编译</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hellow&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5.0f</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++的标准模板库STL就是templates</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> N;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stack-vs-Heap-Memory堆内存与栈内存"><a href="#Stack-vs-Heap-Memory堆内存与栈内存" class="headerlink" title="Stack vs Heap Memory堆内存与栈内存"></a><strong>Stack vs Heap Memory堆内存与栈内存</strong></h3><p>stack和heap地址都是RAM上的两部分区域</p>
<p>stack定好了区域大小 2MegaBytes</p>
<p>heap的大小是动态改变的</p>
<p>区别在于他们如何分配内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">    <span class="built_in">Vector3</span>()</span><br><span class="line">        : <span class="built_in">x</span>(<span class="number">10</span>),<span class="built_in">y</span>(<span class="number">5</span>),<span class="built_in">z</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//stack分配</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">5</span>];</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    array[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    array[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    array[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">    array[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">    Vector3 vector;</span><br><span class="line">    <span class="comment">//观察内存可以发现，stack所有的分配，都在stack的指针位置进行，分配出多少，stack指针就往后移多少，并返回这个指针</span></span><br><span class="line">    <span class="comment">//scope结束，栈内存销毁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//heap分配</span></span><br><span class="line">    <span class="type">int</span>* hvalue = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *hvalue = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span>* harray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    harray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    harray[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    harray[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    harray[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">    harray[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">    Vector3* hvector = <span class="keyword">new</span> <span class="built_in">Vector3</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> havlue;</span><br><span class="line">    <span class="keyword">delete</span>[] harray;</span><br><span class="line">    <span class="keyword">delete</span> hvector;</span><br><span class="line">    <span class="comment">//heap分配</span></span><br><span class="line">    <span class="comment">//new其实就是调用malloc</span></span><br><span class="line">    <span class="comment">//当malloc分配内存时，会根据所需要的内存大小，在内存上寻找足够的一块大小的位置分配，并提供这个地址的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用堆分配可能造成Cache Miss缓存丢失，少数的缓存丢失没有影响</p>
<p>堆栈分配最大的区别就是在分配方式上。</p>
<p>堆分配会更慢。</p>
<p>只有无法在栈上分配，如需要更多的生命周期、更大的数据，再使用堆分配，一般没事最好栈分配，毕竟快很多。</p>
<p>（所以内存碎片大概就是指堆上各个内存之间存在的小间隙？）</p>
<h3 id="Macros宏指令"><a href="#Macros宏指令" class="headerlink" title="Macros宏指令"></a><strong>Macros宏指令</strong></h3><p>预处理过程的宏</p>
<p>编译C++时</p>
<ul>
<li>首先是预处理pass<ul>
<li>带#符号的语句</li>
<li>实际是文本编辑阶段，进行文本替换</li>
<li>控制哪些程序语句进入编译器</li>
</ul>
</li>
</ul>
<p>并不是总是要用宏</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT std::cin.get()<span class="comment">//只在当前文档中生效</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    WAIT;<span class="comment">// 根据define进行文本替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在项目设置的预处理命令看到一些定义</p>
<p>Debug </p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701143548474.png" alt="image-20220701143548474"></p>
<p>Release</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701143602730.png" alt="image-20220701143602730"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT std::cin.get()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG<span class="comment">//也可以在预处理命令上赋值，#ifdef _DEBUG == 1,</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">//也有elif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN int main() \<span class="comment">//反斜杠可以在宏命令中换行</span></span></span><br><span class="line">&#123;\</span><br><span class="line">	std::cin.<span class="built_in">get</span>();\</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样只有debug模式才会log</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    WAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="待补充："><a href="#待补充：" class="headerlink" title="待补充："></a><strong>待补充：</strong></h3><h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><h3 id="Static-Arrays（std-array）静态数组"><a href="#Static-Arrays（std-array）静态数组" class="headerlink" title="Static Arrays（std::array）静态数组"></a>Static Arrays（std::array）静态数组</h3><h3 id="Functions-Pointers函数指针"><a href="#Functions-Pointers函数指针" class="headerlink" title="Functions Pointers函数指针"></a>Functions Pointers函数指针</h3><h3 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h3><h3 id="using-namespace-std"><a href="#using-namespace-std" class="headerlink" title="using namespace std"></a>using namespace std</h3><h3 id="Namespaces命名空间"><a href="#Namespaces命名空间" class="headerlink" title="Namespaces命名空间"></a>Namespaces命名空间</h3><h3 id="Threads线程"><a href="#Threads线程" class="headerlink" title="Threads线程"></a>Threads线程</h3><h3 id="Timing计时器"><a href="#Timing计时器" class="headerlink" title="Timing计时器"></a>Timing计时器</h3><h3 id="Multidimensional-Arrays（2D-arrays）多维数组"><a href="#Multidimensional-Arrays（2D-arrays）多维数组" class="headerlink" title="Multidimensional Arrays（2D arrays）多维数组"></a>Multidimensional Arrays（2D arrays）多维数组</h3><h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><h3 id="Type-Punning类型双关"><a href="#Type-Punning类型双关" class="headerlink" title="Type Punning类型双关"></a>Type Punning类型双关</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/OpenGL/C++%20learning_03/" data-id="cmfe1u6p80017scuhes0v426e" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/Opengl learning_01" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/OpenGL/Opengl%20learning_01/" class="article-date">
  <time datetime="2025-09-10T13:18:14.019Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="01-Introduction"><a href="#01-Introduction" class="headerlink" title="01 Introduction"></a><strong>01 Introduction</strong></h2><ul>
<li><p>Opengl不是一个库或者api，Opengl本身是一种规范</p>
</li>
<li><p>实现这种规范的是GPU厂商</p>
</li>
<li><p>这种实现是在显卡驱动程序上的</p>
</li>
<li><p>每个厂商对Opengl的实现都会有不同。</p>
</li>
<li><p>因此Opengl不可能是开源的，这取决于编写的厂商，Nvidia，AMD</p>
</li>
<li><p>Opengl是跨平台的。</p>
</li>
<li><p>着色器是运行在gpu上的一段程序</p>
</li>
</ul>
<h2 id="02-Setting-up-Opengl-and-Creating-a-Window-in-C"><a href="#02-Setting-up-Opengl-and-Creating-a-Window-in-C" class="headerlink" title="02 Setting up Opengl and Creating a Window in C++"></a><strong>02 Setting up Opengl and Creating a Window in C++</strong></h2><p>thecherno.com&#x2F;discord</p>
<ul>
<li>提供窗口的创建与管理——GLFW（多平台）</li>
<li>我们当然可以下载glfw源码作为静态库在项目中编译</li>
<li>为了方便选择预编译的二进制文件，配置环境这一部分在C++里已经做过了</li>
</ul>
<p>这个时候直接允许文档的参考代码，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以编译成功，但是链接出现了问题</p>
<p>无法解析的外部符号__imp__glClear@4</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818120630494.png" alt="image-20220818120630494"></p>
<p>我们知道这是链接的问题，我们需要找到一个glClear函数，在一个我们没有添加的库文件中。</p>
<p>这个库文件就是OpenGL32.lib</p>
<p>（<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41524721/article/details/104330656%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E4%B9%9F%E7%BB%99%E5%87%BA%E4%BA%86%E8%BF%99%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82%EF%BC%89">https://blog.csdn.net/qq_41524721/article/details/104330656这个博客也给出了这个解决方案。）</a></p>
<p>这样我们成功地允许了文档的参考代码，画出了一个窗口</p>
<p>(Cherno教程当中还有一些关于平台注册的函数的连接失败，User32.lib 、Gid32.lib、Shell32.lib，我之所以没有出现这个问题，发现在项目设置的连接器命令行里已经处理过了。。。从项目默认继承也不知道咋继承出来的，但是缺少库文件，就该这样链接)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line"></span><br><span class="line">glVertex2f(-0.5f,-0.5f)</span><br><span class="line">glVertex2f(0.0f,0.5f)</span><br><span class="line">glVertex2f(0.5f,-0.5f)</span><br><span class="line"></span><br><span class="line">glEnd();</span><br></pre></td></tr></table></figure>



<h2 id="03-Using-Modern-Opengl-in-C"><a href="#03-Using-Modern-Opengl-in-C" class="headerlink" title="03 Using Modern  Opengl in C++"></a><strong>03 Using Modern  Opengl in C++</strong></h2><p>如介绍中所说，Opengl的规范是显卡制造商实现的，因此我们需要做的是进入驱动程序，“获取”函数并调用（访问驱动程序dll文件并检索指向库中函数的指针）</p>
<p>理论上这是可以手动操作的，但无法跨平台。</p>
<p>而能够实现这些操作的库：</p>
<ul>
<li>glew(opengl extention wrangler)</li>
<li>glad</li>
</ul>
<p>教程将会使用Glew</p>
<p><a target="_blank" rel="noopener" href="http://glew.sourceforge.net/">http://glew.sourceforge.net/</a></p>
<p>我们同样只要关注include和lib文件夹（下载的压缩包里顺便有文档）</p>
<p>第一件事是创建一个有效的opengl渲染上下文（contex），然后使用glewInit()去初始化扩展入口点（initialize the extension entry points）</p>
<p>注意lib里面有两个文件</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818224754923.png" alt="image-20220818224754923"></p>
<p>技术上这两个链接库都是静态的，但是glew32.lib是链接到dll使用的。glew32s.lib(static)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">glewInit</span>();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果这样去include的话，会收获一个错误fatal error C1189: #error:  gl.h included before glew.h</p>
<p>双击这个错误我们可以在 glew.h中看到定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__gl_h_) || defined(__GL_H__) || defined(_GL_H) || defined(__X_GL_H)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> gl.h included before glew.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>所以我们应该把glew放到前面。</p>
<p>但是这部操作之后，我们发现了链接错误</p>
<p>error LNK2019: 无法解析的外部符号 __imp__glewInit@0，函数 _main 中引用了该符号</p>
<p>但是链接按理来说应该是正确的。在glew.h中搜索glewInit的定义，</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818230050838.png" alt="image-20220818230050838"></p>
<p>可以看到在实际返回类型前有一个GLEWAPI的宏定义</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818230652054.png" alt="image-20220818230652054"></p>
<p>我们没有定义GLEW_STATIC和 GLEW_BUILD，所以把GLEWAPI定义为了extern __declspec(dllimport)</p>
<p>这是一个 内置的msvc编译器，告诉链接器它来自于一个dll文件，所以需要dll引用，但是我们没有用dll版本的 glew。</p>
<p>所以我们要做的是——自己定义（其实这些文档里都有）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220818230543814.png" alt="image-20220818230543814"></p>
<p>这回又可以画好我们的三角形了。但是如果按照文档运行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line"><span class="built_in">glutCreateWindow</span>(<span class="string">&quot;GLEW Test&quot;</span>);</span><br><span class="line">GLenum err = <span class="built_in">glewInit</span>();</span><br><span class="line"><span class="keyword">if</span> (GLEW_OK != err)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Problem: glewInit failed, something is seriously wrong. */</span></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">glewGetErrorString</span>(err));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Status: Using GLEW %s\n&quot;</span>, <span class="built_in">glewGetString</span>(GLEW_VERSION));</span><br></pre></td></tr></table></figure>

<p>我们将会失败，因为glewInit是有返回值的，这个失败说明初始化并不成功。</p>
<p>因为我们需要先创建一个&#x3D;&#x3D;opengl渲染上下文&#x3D;&#x3D;。</p>
<p>而这个上下文就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure>

<p>把glew初始化放在这之后就成功了。</p>
<p>我们还可以输出我们的 opengl版本号（这与glew无关）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="built_in">glGetString</span>(GL_VERSION)&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<p>可以看到我的输出是：</p>
<p>4.6.0 NVIDIA 462.30</p>
<h2 id="04-Vertex-Buffers-and-Drawing-a-Triangle"><a href="#04-Vertex-Buffers-and-Drawing-a-Triangle" class="headerlink" title="04 Vertex Buffers and Drawing a Triangle"></a><strong>04 Vertex Buffers and Drawing a Triangle</strong></h2><p>Vertex Buffer顶点缓冲区就是一个（内存）缓冲区，实质是一个数组字节的内存。</p>
<p>区别是这是Opengl中的内存缓冲区，这表明它实际在我们的GPU中（显存VRAM）</p>
<p>当我们定义一组数据来表示三角形，将它存进GPU的VRAM中，然后我们需要调用DrawCall，让GPU从VRAM中读数据。</p>
<p>此外，我们还需要告诉GPU如何读取和解释数据，以及如何把它放到屏幕上。</p>
<p>关于渲染管线，就不赘述了。</p>
<p>还要记住 Opengl是一种状态机。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);<span class="comment">//生成一个缓冲区，而buffer就是生成的缓冲区的id</span></span><br><span class="line"><span class="comment">//通常是0，1，2，3...0一般表示无效值</span></span><br></pre></td></tr></table></figure>

<p>这就是实际对象的id，无论它储存顶点还是纹理…</p>
<p>那么我们就需要表示这块缓冲区如何使用 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);<span class="comment">//绑定缓冲区——表示我们如何使用它</span></span><br><span class="line"><span class="comment">//GL_ARRAY_BUFFER表示，这块缓冲区只是一个数组</span></span><br></pre></td></tr></table></figure>

<p>而下一步就应该向缓冲区里传入数据。</p>
<p>我们可以创建缓冲区时指定大小，然后直接给出数据；或者什么都不给，用数据来更新。</p>
<p>我们现在为它提供绘制三角形的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">	 <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;<span class="comment">//先准备好数据</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW)</span><br><span class="line"><span class="comment">//也可以6*sizeof(float)，这些都是我们知道的</span></span><br></pre></td></tr></table></figure>

<p>查文档啥都有 <a target="_blank" rel="noopener" href="https://docs.gl/">https://docs.gl/</a> ，这里包含了各种版本opengl的文档</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819000352210.png" alt="image-20220819000352210"></p>
<p>非常好用（刚才我们看过opengl版本了，所以是gl4）</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819000549306.png" alt="image-20220819000549306"></p>
<p>下面也有每个参数的含义</p>
<p>关于usage，是如何访问缓冲区对象的数据储存区的提示。包括访问频率（STREAM修改一次，最多使用几次,STATIC修改一次多次使用,DYNAMIC反复修改并多次使用）和访问性质(DRAW,READ,COPY)</p>
<p>静态和动态是最常用的。静态表示我们只创建一次缓冲区，不会每一帧都修改buffer，但是每一帧都绘制。</p>
<p>但要注意这只是一个Hint提示，即便声明静态，每一帧更新缓冲区仍然可以工作，只是会慢很多。</p>
<p>通常到这里我们还需要创建Index buffer，但是这里就先不用了</p>
<p>我们再来看这一串，就是在显存建立缓冲区，并指定缓冲区对象的名称（用途），最后把CPU内存的数据拿给显存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line"><span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"><span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;<span class="comment">//先准备好数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是我们依然不知道如何使用这6个浮点数据。</p>
<p>我们也没有着色器来指定如何绘制 这些数据。这是之后的内容</p>
<p>但是如果要绘制的话，可以这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES,0,3);//我们没有index buffer，可以这样做</span><br><span class="line">//Mode,First(starting index),Count(number of indices)</span><br></pre></td></tr></table></figure>

<p>另一种方式是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glDrawElements(GL_TRIANGLS,3,GL_UNSIGNED_INT,indices)//和idnex buffer一起使用</span><br><span class="line">//Mode</span><br><span class="line">//count</span><br><span class="line">//type:Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT</span><br><span class="line">//indices</span><br></pre></td></tr></table></figure>

<p>这就是DrawCall</p>
<p>注意Opengl的状态机性质，因为前面绑定了这个三角形的数据，所以drawcall就会绘制这个三角形</p>
<h2 id="05-Vertex-Attribute-and-Layouts-in-Opengl"><a href="#05-Vertex-Attribute-and-Layouts-in-Opengl" class="headerlink" title="05 Vertex Attribute and Layouts in Opengl"></a><strong>05 Vertex Attribute and Layouts in Opengl</strong></h2><p>总结一下，Opengl的管线工作流程就是为显卡提供数据，然后储存进GPU显存，包含了所有数据。我们会使用着色器程序在gpu上执行，去读取数据然后进行绘制。</p>
<p>当着色器读取数据时，顶点缓存需要知道缓存数据的布局&#x3D;&#x3D;Layout&#x3D;&#x3D;——这是一堆浮点数，包含每个顶点的位置、法线、纹理坐标。。。因此我们需要告诉Opengl内存的数据是如何布局的 。</p>
<p>顶点数据内储存了各种属性，而绑定属性的方式就是顶点属性指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glVertexAttribPointer</span><span class="params">(	GLuint	index,<span class="comment">//属性的索引，(第几个属性，而不是位置)</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLint	size, <span class="comment">//只接受1234</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="comment">//就像你不会见到float5</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLenum	type,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="comment">//初始为GL_FLOAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLboolean	normalized,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                            GLsizei	stride,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> GLvoid *	pointer)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>noramlized</p>
<ul>
<li>规范化设置</li>
<li>如果规范化设置为GL_TRUE ，则表示以整数格式存储的值在被访问并转换为浮点时将映射到范围 [-1，1]（对于有符号值）或 [0，1]（对于无符号值）。否则，值将直接转换为浮点数，而无需规范化。GL_FLOAT的设置已经规范了</li>
</ul>
</li>
<li><p>stride</p>
<ul>
<li>连续通用顶点属性之间的字节偏移量：每个顶点之间的字节数量</li>
<li>比如我们有一个位置3<em>float,uv坐标2</em>float,法线3*float 12bytes+8bytes+12bytes，stride &#x3D; 32bytes</li>
<li>可以想象Opengl从一个顶点属性跳到下一个顶点的属性，就直接根据步幅寻找</li>
</ul>
</li>
<li><p>point</p>
<ul>
<li>指定当前绑定到目标的缓冲区的数据存储区中数组中第一个通用顶点属性的第一个组件的偏移量。。。缩句，数组的第一个属性的第一个组件的偏移量</li>
<li>初始为0。</li>
<li>比如位置是0，uv是12bytes(12)，法线是20bytes(20)</li>
<li>C++有提供偏移类的宏</li>
<li>注意这里需要const void*，因此需要如转换(const void*) 8</li>
</ul>
</li>
</ul>
<p>我们还需要启用这个顶点属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexArrayAttrib</span>(<span class="number">0</span>);<span class="comment">//index of vertex attribute</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;<span class="comment">//先准备好数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>以上CPU阶段的准备工作就完成了，接下来调用drawcall，就开始执行着色器程序了。</p>
<h2 id="06-How-a-Shader-Work-in-Opengl"><a href="#06-How-a-Shader-Work-in-Opengl" class="headerlink" title="06 How a Shader Work in Opengl"></a><strong>06 How a Shader Work in Opengl</strong></h2><p>实际上这个时候我们不写着色器，屏幕上已经可以画出三角形了。这是因为如果我们没有写自己的着色器的话，一些GPU会提供默认着色器。</p>
<p>回顾vs和fs的区别，vs对于每个顶点运行，fs对于每个像素运行。假如三角形非常巨大，那么同样的运算，vs只需要执行3次，fs则需要执行像素数的次数。这个特性可以用于一些性能优化。</p>
<p>其他关于shader的内容就不赘述了。</p>
<h2 id="07-Writing-a-Shader-in-Opengl"><a href="#07-Writing-a-Shader-in-Opengl" class="headerlink" title="07 Writing a Shader in Opengl"></a><strong>07 Writing a Shader in Opengl</strong></h2><p>我们需要定义一个新的函数，并且是静态的。因为不希望它在其他cpp文件中使用。</p>
<p>它用来编译我们的着色器代码。</p>
<p>着色器代码可以来自不同地方 ，我们可以简单地只写一个字符串。也可以从文件读取。</p>
<p>我们需要让Opengl编译这个程序，把vs和fs连接到一个单独的着色器程序中，并返回某种唯一的标识符，所以我们可以绑定一个着色器，然后像使用顶点缓冲那样，生成一个缓冲并返回一个id去使用它。（生成缓冲区-绑定-传递）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">ComplieShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type); <span class="comment">//在gpu中创建（绑定）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();<span class="comment">//把std string转换为原生字符串；</span></span><br><span class="line">    <span class="comment">//或const char* src = &amp;source[0]</span></span><br><span class="line">    <span class="comment">//我们一直在使用引用，因为要保证编译时原来的字符串始终存在。</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="comment">//通过glGetShaderiv来查询它是否有错误</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result)&#123;<span class="comment">//GL_FALSE = 0</span></span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">    	<span class="comment">//char message[length];栈分配不能使用，因为length不是常量</span></span><br><span class="line">        <span class="comment">//大多数人会使用堆分配，记得删除。但还是在栈分配上，可以如下</span></span><br><span class="line">        <span class="type">char</span>* message =(<span class="type">char</span>*) <span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Fail to complie&quot;</span>&lt;&lt;(type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex&quot;</span> : <span class="string">&quot;fragment&quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;message&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在很多地方没有使用内置变量GLuint等，是因为作者趋向使用多种图形api</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="comment">//unsigned int vs = glCreateShader(GL_VERTEX_SHADER);</span></span><br><span class="line">    <span class="comment">//把这一步封装到了ComplieShader里，因为所有shader都是一样的步骤，只是类型不同 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">ComplieShader</span>(GL_VERTEX_SHADER,vertexShader);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">ComplieShader</span>(GL_FRAGMENT_SHADER,fragmentShader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这样我们就编译好了着色器，并且取得他们的id</span></span><br><span class="line">    <span class="comment">//就像编译C++一样，对于两份文件，我们需要链接到一个程序中</span></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//着色器已经链接到一个程序中了，我们可以删除掉了。就像我们可以删除obj中间文件</span></span><br><span class="line">    <span class="comment">//我们的实际程序已经在program里了</span></span><br><span class="line">    <span class="comment">//还有如glDetachShader之类的会删除源代码，但可以不用</span></span><br><span class="line">    <span class="comment">//它们占用内存很少，并且处理图像、调试等等保留着色器源代码是有用的</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glShaderSource</span><span class="params">(GLuint , shader</span></span></span><br><span class="line"><span class="params"><span class="function">					GLsizei , count</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">const</span> GLchar **, string</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">const</span> GLint *length)</span></span>;</span><br><span class="line"><span class="comment">//shader</span></span><br><span class="line"><span class="comment">//Specifies the handle of the shader object whose source code is to be replaced.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//count</span></span><br><span class="line"><span class="comment">//Specifies the number of elements in the string and length arrays.字符串的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string</span></span><br><span class="line"><span class="comment">//Specifies an array of pointers to strings containing the source code to be loaded into the shader.</span></span><br><span class="line"><span class="comment">//需要提供一个双指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//length</span></span><br><span class="line"><span class="comment">//Specifies an array of string lengths.</span></span><br><span class="line"><span class="comment">//null表示以null终止</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>着色器的编译和传递方法就完成了。</p>
<p>接下来我们编写着色器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">std::string vertexShader = </span><br><span class="line">    <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout(location = 0) in vec4 position;\n&quot;</span></span><br><span class="line">    <span class="comment">//和顶点属性的laout一致。</span></span><br><span class="line">    <span class="comment">//注意这里是vec4，而我们实际只有vec2，剩余的部分Opengl会默认转换z0w1</span></span><br><span class="line">	<span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;	gl_Position = position;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">std::string fragmentShader =</span><br><span class="line">    <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout(location = 0) out vec4 color;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;	color = vec4(1.0,0.0,0.0,1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader,fragmentShader);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非常顺利</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819124846651.png" alt="image-20220819124846651"></p>
<p>再检查着色器的错误处理</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220819125229576.png" alt="image-20220819125229576"></p>
<p>源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">ComplieShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//传递</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);					<span class="comment">//编译</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error handling</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);<span class="comment">//错误信息长度</span></span><br><span class="line">        <span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">//alloca可以在栈上动态分配</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Fail to complie&quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex&quot;</span> : <span class="string">&quot;fragment&quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">ComplieShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">ComplieShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);		<span class="comment">//链接</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);	<span class="comment">//验证程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;GlewInit fail!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">    &#125;;<span class="comment">//先准备好数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), positions, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::string vertexShader =</span><br><span class="line">        <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;layout(location = 0) in vec4 position;\n&quot;</span></span><br><span class="line">        <span class="comment">//和顶点属性的laout一致。</span></span><br><span class="line">        <span class="comment">//注意这里是vec4，而我们实际只有vec2，剩余的部分Opengl会默认转换z0w1</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;void main()&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;	gl_Position = position;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">    std::string fragmentShader =</span><br><span class="line">        <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;layout(location = 0) out vec4 color;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;void main()&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;	color = vec4(1.0,0.0,0.0,1.0);\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader, fragmentShader);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(shader);<span class="comment">//清理着色器</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/OpenGL/Opengl%20learning_01/" data-id="cmfe1u6p80019scuhenty50wk" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/C++ learning_01" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/OpenGL/C++%20learning_01/" class="article-date">
  <time datetime="2025-09-10T13:18:14.018Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>[TOC]</p>
<h3 id="指针Pointers"><a href="#指针Pointers" class="headerlink" title="指针Pointers"></a>指针Pointers</h3><p>指针是一个整数，储存一个内存地址。</p>
<p>类型没有意义，只是在这个地址的数据是这个类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">void</span>* ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;<span class="comment">// 指针解引用，访问对应地址储存的值</span></span><br><span class="line">=========================</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>]; </span><br><span class="line"><span class="comment">// 一个char占用1个字节，分配了8个字节的内存，并返回一个指向这块内存的开始地址的指针</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span> );<span class="comment">// 为指定地址填充值</span></span><br><span class="line"><span class="keyword">delete</span>[] buffer;<span class="comment">// 删除值</span></span><br><span class="line">buffer = <span class="literal">nullptr</span>;<span class="comment">// 回收指针</span></span><br></pre></td></tr></table></figure>

<p>指针本身也只是变量，这些变量也储存在内存中（double pointers，triple pointers-指针的指针）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>]; </span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span> );</span><br><span class="line"><span class="type">char</span>** ptr = &amp;buffer;<span class="comment">// 在32位程序里，一个内存地址是32位的</span></span><br></pre></td></tr></table></figure>

<h3 id="引用Reference"><a href="#引用Reference" class="headerlink" title="引用Reference"></a>引用Reference</h3><p>指针和引用基本是一回事，引用是对某个存在变量的引用。引用本身不是一个新的变量，并不真正占用内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* b = &amp;a;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;<span class="comment">//这里引用的&amp;符号不同于指针，它是变量类型的一部分，紧跟着变量类型</span></span><br><span class="line"><span class="comment">//在这里创建了一个a的别名，ref其实不是一个实际的变量，只是a所在地址的数据的别称</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; <span class="comment">// 在这里是传值调用（passing by value）</span></span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">increment</span>(a);<span class="comment">//将a拷贝到了函数中，创造一个全新的变量value,a并不会发生改变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>* value)</span> </span>&#123;<span class="comment">//传递地址，调用a的内存地址而不是a本身给函数</span></span><br><span class="line">    (*value)++;<span class="comment">//解引用，改变地址储存的数值而不是地址本身.</span></span><br><span class="line">    <span class="comment">//递增符号会优先执行，所以添括号保证先解引用再递增</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">increment</span>(&amp;a)<span class="comment">//传递变量地址</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;<span class="comment">//引用传递,passing by reference</span></span><br><span class="line">    <span class="comment">//和传递地址是一样的，但是看起来更简单了</span></span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">increment</span>(a)</span><br></pre></td></tr></table></figure>

<p>引用只是让代码更好看了，没有什么事情是引用能做但指针不能的</p>
<p>一旦声明一个引用，就不能更改它所引用的对象</p>
<h3 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h3><p>C++支持面向过程，基于对象，面向对象，泛型编程</p>
<p>类是一种将数据和函数组织在一起的方式</p>
<p>由类类型制成的变量叫对象，新创建对象的过程叫做实例化</p>
<p>默认情况下，类成员的访问控制都是私有的，只有类内部的函数才能访问——提供公有函数访问接口</p>
<p>类内的函数称为方法（method）</p>
<h4 id="与结构体的区别"><a href="#与结构体的区别" class="headerlink" title="与结构体的区别"></a>与结构体的区别</h4><p>默认情况下，类是私有的，结构体是私有的</p>
<p>一般不对结构体使用继承，或过于复杂的功能，仅仅保持结构体为数据和简单的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">// 将公有私有变量、方法分开。</span></span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line">   	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">            m_LogLevel = level;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelError)</span><br><span class="line">            	std::cout &lt;&lt; <span class="string">&quot;[ERROR]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)</span><br><span class="line">            	std::cout &lt;&lt; <span class="string">&quot;[WARNING]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)</span><br><span class="line">            	std::cout &lt;&lt; <span class="string">&quot;[Info]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Log log;</span><br><span class="line">    log.<span class="built_in">SetLevel</span>(log.LogLevelWarning);</span><br><span class="line">    Log.<span class="built_in">Error</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    Log.<span class="built_in">warn</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    Log.<span class="built_in">Info</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    std::cin,<span class="built_in">get</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Static静态关键字"><a href="#Static静态关键字" class="headerlink" title="Static静态关键字"></a>Static静态关键字</h3><p>类外或结构体外的static修饰符在link阶段是局部的，它只对定义它的编译单元（.obj）可见</p>
<p>类内或结构体里面的static表示这部分内存是这个类的所有实例共享的，即就算实例化了很多次这个类或结构体，这个静态static变量只会有一个实例，并被共享。</p>
<p>静态方法也是如此，没有该实例的指针（this）</p>
<h4 id="类外的static。"><a href="#类外的static。" class="headerlink" title="类外的static。"></a>类外的static。</h4><p>static.cpp:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> s_Variable = <span class="number">5</span>; <span class="comment">// 这个变量在link的时候只对这个编译单元(.obj)里的东西可见</span></span><br><span class="line"><span class="comment">// static变量或函数表示在link到它实际的定义时，linker 不会再这个编译单元.obj外面寻找它的定义</span></span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> s_Variable = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; s_Variable &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">//输出10 不会与static.cpp中的static变量发生重复定义</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">=========================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> s_Variable;<span class="comment">//外部链接，会在其他编译单元里寻找定义，但如果static.cpp中是静态声明，就找不到了，静态声明使其他编译单元不能访问s_Variable,相当于私有变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; s_Variable &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类内Static"><a href="#类内Static" class="headerlink" title="类内Static"></a>类内Static</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt;std:endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">    e,x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line">    Entity e1 = &#123; <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>();<span class="comment">//2, 3 /n 5, 8</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">============================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> Entity&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt;std:endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line">    Entity e1<span class="comment">// = &#123; 5, 8 &#125;;//x和y不再是类的成员, 这种写法会报错</span></span><br><span class="line">    e<span class="number">1.</span>x = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//等同于Entity::x = 5,虽然写了e1.x，但其实并不属于类成员</span></span><br><span class="line">    e<span class="number">1.</span>y = <span class="number">8</span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>();<span class="comment">//5, 8 /n 5, 8</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//static 修饰的struct全局会共用一块内存</span></span><br><span class="line">    <span class="comment">//无法通过静态方法访问非静态的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部静态Local-Static"><a href="#局部静态Local-Static" class="headerlink" title="局部静态Local Static"></a>局部静态Local Static</h4><p>变量的</p>
<ul>
<li><p>生命周期：变量被删除前在内存中停留多久</p>
</li>
<li><p>作用域：在哪里能访问这个变量</p>
</li>
</ul>
<p>一个静态局部变量允许我们定义一个变量，生命周期是整个程序，但作用于被限制在这个函数里或任何作用域。和类内作用域的静态变量是一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;<span class="comment">//如果没有静态，则每次调用函数时，i的值被设为0,自增后输出1 </span></span><br><span class="line">    <span class="comment">//局部静态变量和在函数外定义全局变量的区别在于作用域</span></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ENUMS枚举"><a href="#ENUMS枚举" class="headerlink" title="ENUMS枚举"></a>ENUMS枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">  A,B,C  	</span><br><span class="line">      <span class="comment">//第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。</span></span><br><span class="line">      <span class="comment">// 可以指定任意数组，默认顺序</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example value = B</span><br><span class="line">&#125;</span><br><span class="line">============</span><br><span class="line"><span class="keyword">enum</span> Example : <span class="type">unsigned</span> <span class="type">char</span> &#123;<span class="comment">// 可以指定任意类型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Level</span>&#123;</span><br><span class="line">        Error, Warning, Info</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// const int LogLevelError = 0;</span></span><br><span class="line">    <span class="comment">// const int LogLevelWarning = 1;</span></span><br><span class="line">    <span class="comment">// const int LogLevelInfo = 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Constructor构造函数"><a href="#Constructor构造函数" class="headerlink" title="Constructor构造函数"></a>Constructor构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;<span class="comment">//需要一种方式，每当构造Entity实例时，需要将X，Y初始化</span></span><br><span class="line">        X = <span class="number">0.0f</span>;</span><br><span class="line">        Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt; X&lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Init</span>();</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line">=================================================</span><br><span class="line"><span class="keyword">class</span> Entity&#123;<span class="comment">//构造函数就是每当构建一个对象时都会调用的方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    <span class="comment">// Entity() = delete;删除默认的构造函数</span></span><br><span class="line">    <span class="built_in">Entity</span>()&#123;</span><br><span class="line">        X = <span class="number">0.0f</span>;</span><br><span class="line">        Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;<span class="comment">// 可以写许多构造函数（重载）</span></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y)&#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="function">Entity <span class="title">e2</span><span class="params">(<span class="number">10.0f</span>, <span class="number">5.0f</span>)</span></span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">2.</span><span class="built_in">Print</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用static声明类中元素时，并不会调用构造函数（因为static是所有实例共有的）</p>
<p>特殊类型的构造函数：拷贝构造函数Copy Constructor， Move Constructor</p>
<h3 id="Destructors析构函数"><a href="#Destructors析构函数" class="headerlink" title="Destructors析构函数"></a>Destructors析构函数</h3><p>constructor 在创建一个对象实例时运行，而析构函数在摧毁一个对象时运行</p>
<p>构造函数通常用来设置变量或者进行某些需要的初始化</p>
<p>当对象即将结束生命周期时，需要清理原本占用的内存，</p>
<p>析构函数同时使用堆和栈来给对象分配空间，所以如果使用new给对象分配空间，而对应的需要使用delete调用析构函数释放空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;<span class="comment">//构造函数就是每当构建一个对象时都会调用的方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    <span class="built_in">Entity</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        X = <span class="number">0.0f</span>;</span><br><span class="line">        Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y)&#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>()&#123;</span><br><span class="line">       	std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Created Entity!</span></span><br><span class="line"><span class="comment">0, 0</span></span><br><span class="line"><span class="comment">Destroyed Entity!</span></span><br><span class="line"><span class="comment">实例e的生命周期只在Function函数中，因此Function结束后，就调用析构函数释放了空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inheritance继承"><a href="#Inheritance继承" class="headerlink" title="Inheritance继承"></a>Inheritance继承</h3><p>（Code Duplication）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X,Y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xa, <span class="type">float</span> ya)</span> </span>&#123;</span><br><span class="line">        X += xa;</span><br><span class="line">        Y += ya;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity&#123;<span class="comment">// Entity中任何非私有的变量或函数，Player都可用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* Name;</span><br><span class="line">    <span class="comment">/*float X,Y;</span></span><br><span class="line"><span class="comment">    void Move(float xa, float ya) &#123;</span></span><br><span class="line"><span class="comment">        X += xa;</span></span><br><span class="line"><span class="comment">        Y += ya;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt; Name &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player palyer;</span><br><span class="line">    player.<span class="built_in">PrintName</span>();</span><br><span class="line">    palyer.<span class="built_in">Move</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Virtual-Functions虚函数"><a href="#Virtual-Functions虚函数" class="headerlink" title="Virtual Functions虚函数"></a>Virtual Functions虚函数</h3><p>虚函数允许我们覆盖子类中的方法</p>
<p>比如B是A的派生类（子类），如果指定A中某虚函数方法，则可以在B中覆盖该方法做别的事</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)<span class="comment">//这里使用了初始化列表，在构造时先于函数体执行，代表将name赋值给m_Name</span></span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">PrintName</span>(e)<span class="comment">//Entity</span></span><br><span class="line">    </span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;<span class="comment">//Cherno</span></span><br><span class="line">	<span class="built_in">PrintName</span>(p)<span class="comment">//Entity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数引入了动态分派Dynamic Dispatch，通常使用VTable虚函数表实现此编译</p>
<p>虚函数表包含基类中所有虚函数的映射，在运行时映射向正确的覆写函数</p>
<p>总之，如果要覆盖函数，需要在基类中将基函数标记为虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">//std::string Getname() &#123; retrun m_Name; &#125;</span></span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">    <span class="comment">//在C++11中，可以将覆写的函数用关键词override标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">PrintName</span>(e)<span class="comment">//Entity</span></span><br><span class="line">    </span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;<span class="comment">//Cherno</span></span><br><span class="line">	<span class="built_in">PrintName</span>(p)<span class="comment">//Cherno</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数的性能代价，是需要遍历整个虚函数表查看映射</p>
<h4 id="Pure-virtual-function纯虚函数"><a href="#Pure-virtual-function纯虚函数" class="headerlink" title="Pure virtual function纯虚函数"></a>Pure virtual function纯虚函数</h4><p>纯虚函数允许我们定义一个在基类中没有实现的函数，然后迫使在子类中实际实现</p>
<p>在接口中，类仅仅包含未实现的方法并充当一种勉强的模板,这种类无法实例化，必须在子类中实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">//std::string Getname() &#123; retrun m_Name; &#125;</span></span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">    <span class="comment">//在C++11中，可以将覆写的函数用关键词override标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Entity* e = new Entity();</span></span><br><span class="line">    <span class="comment">// PrintName(e)//Entity无法再实例化Entity类</span></span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintName</span>(e);</span><br><span class="line">    </span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;<span class="comment">//Cherno</span></span><br><span class="line">	<span class="built_in">PrintName</span>(p)<span class="comment">//Cherno</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当一个类提供所有纯虚函数的实现，才能实例化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> : <span class="keyword">public</span> Printable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">    std::string GetClassName <span class="keyword">override</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">     std::string GetClassName <span class="keyword">override</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;GetClassNmae &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="comment">// PrintName(e)//Entity</span></span><br><span class="line">    <span class="built_in">Print</span>(e)<span class="comment">//Entity</span></span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p-&gt;GetName() &lt;&lt; std::endl;//Cherno</span></span><br><span class="line">	<span class="comment">// PrintName(p)//Cherno</span></span><br><span class="line">    <span class="built_in">Print</span>(p)<span class="comment">// Player,如果没有在Player中定义，调用的是Entity中的override，输出Entity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Visibility访问控制"><a href="#Visibility访问控制" class="headerlink" title="Visibility访问控制"></a>Visibility访问控制</h3><p>本质指类中的成员数据及函数的可访问性</p>
<p>基本的访问控制修饰符：public公有， protected保护， private私有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">int</span> X,Y;<span class="comment">// 默认私有,意味着只有Entity类内才能访问这些变量，包括读写（除非是friend）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        X = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;<span class="comment">//Player的构造函数也不能访问Entity的私有变量</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> example[<span class="number">5</span>]; <span class="comment">//声明并分配空间</span></span><br><span class="line">example[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; example[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; example &lt;&lt; std::endl;<span class="comment">//输出example的地址，这是一个指针类型</span></span><br><span class="line"><span class="type">int</span>* ptr = example;</span><br><span class="line">*(ptr<span class="number">+2</span>) = <span class="number">6</span>;<span class="comment">//example[2] = 6,example地址后移两个int的空间并解引用，得到example[2]的值赋值为6</span></span><br></pre></td></tr></table></figure>

<p> new 运算符动态分配内存空间，</p>
<p>delete 运算符释放，否则即便局部作用域的程序运行完毕，内存也不会被回收。</p>
<p>为class分配内存空间时，还会同时运行构造函数。</p>
<p>实例的地址所指向的就是成员变量的地址；但如果用new关键字来分配，为成员变量建立了一个指针，实例的地址指向的是指针的地址。</p>
<h3 id="Strings字符串"><a href="#Strings字符串" class="headerlink" title="Strings字符串"></a>Strings字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line"><span class="comment">// 字符串在内存中末尾需要有0 填充作终止符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name2[<span class="number">6</span>] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">std::cout&lt;&lt;name2&lt;&lt;std::endl;<span class="comment">//输出的Cherno后面会跟随后面内存所对应的无意义的ASCII码，如锟斤拷</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name2[<span class="number">7</span>] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>，<span class="number">0</span>&#125;</span><br><span class="line">std::cout&lt;&lt;name2&lt;&lt;std::endl;<span class="comment">// 加上终止符，能正常输出Cherno</span></span><br><span class="line">name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="standard-string"><a href="#standard-string" class="headerlink" title="standard string"></a>standard string</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    <span class="comment">//std string 有一个构造函数，接受一个char ptr或const char ptr</span></span><br><span class="line">    <span class="comment">//这里是（const char[7]）</span></span><br><span class="line">    <span class="comment">//std string 还有一些成员函数可以使用</span></span><br><span class="line">    <span class="comment">//std::string name = &quot;Cherno&quot; + &quot;hello!&quot;;这是不可以的，这相当于把两个数组相加</span></span><br><span class="line">    name += <span class="string">&quot;hello!&quot;</span>;<span class="comment">//这是可以的，将一个指针和name相加，利用string的重载+ 拼接字符串</span></span><br><span class="line">    std::string name2 = std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>) + “hello!<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    //这也是可以的</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="string-literal"><a href="#string-literal" class="headerlink" title="string literal"></a>string literal</h4><p>字符串是不可变的。默认为const，在内存中只读</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正如上面所说，字符串的末尾默认有\0的填充，作为终止符</span></span><br><span class="line"><span class="comment">//&quot;Che\0rno&quot; =&quot;Che\0rno\0&quot;</span></span><br><span class="line"><span class="comment">//实际的字符长度因为中间的终止符，只有3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;Cherno&quot;</span><span class="comment">// 将它定义为数组，而不是字符串或字符串指针，就可以修改了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">u8&quot;Cherno&quot;</span>;<span class="comment">//每个字符一个字节</span></span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* name2 = <span class="string">L&quot;Cherno&quot;</span>;<span class="comment">//宽指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char16_t</span>* name3 = <span class="string">u&quot;Cherno&quot;</span>;<span class="comment">//每个字符两个字节的16位字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char32_t</span>* name4 = <span class="string">U&quot;Cherno&quot;</span>;<span class="comment">//32位字符或每个字符四个字节</span></span><br></pre></td></tr></table></figure>

<p>在C++14中，还可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line">std::string name0 = <span class="string">&quot;Cherno&quot;</span>s + <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::wstring name0 = <span class="string">L&quot;Cherno&quot;</span>s + <span class="string">L&quot;hello&quot;</span>;</span><br><span class="line">std::u32string name0 = <span class="string">U&quot;Cherno&quot;</span>s + <span class="string">U&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//R前缀</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* example = <span class="string">R&quot;(Line1</span></span><br><span class="line"><span class="string">Line2</span></span><br><span class="line"><span class="string">Line3</span></span><br><span class="line"><span class="string">Line4)&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Const常量"><a href="#Const常量" class="headerlink" title="Const常量"></a>Const常量</h3><p>就像一个承诺，认为一个变量不改变，但是否信守承诺还是取决于你自己。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">90</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a =<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">// 意味着不能再更改指针的内容，但是可以读取,也可以更改指针。</span></span><br><span class="line">*a = <span class="number">2</span>；<span class="comment">//不可操作</span></span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE； <span class="comment">//可以操作</span></span><br><span class="line">================================</span><br><span class="line"><span class="comment">//也等同于:    </span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">=================================</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">// 完全相反，不能更改指针，但可以更改指针的内容</span></span><br><span class="line">*a = <span class="number">2</span>;<span class="comment">// 可以操作</span></span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE；<span class="comment">// 不可操作</span></span><br><span class="line">================================</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_X,m_Y;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> var;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">// 此方法不会修改任何类成员变量，是一种只读方法</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_X = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        m_X = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">// 此方法的指针和此方法都不能更改，且不会修改任何成员变量。</span></span><br><span class="line">        retrun m_X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;e.<span class="built_in">GetX</span>()&lt;&lt;std::end;;</span><br><span class="line">    <span class="comment">//因为这里是引用了常量，因此不能对类有任何修改，在调用类方法时，也只能调用只读方法，如果没有类方法没有const，则不能调用，因为无法保证没有更改类成员。</span></span><br><span class="line">    <span class="comment">//有时同名的类方法会有const版本和无const版本，在这里调用时会自动使用const版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutable关键字"><a href="#Mutable关键字" class="headerlink" title="Mutable关键字"></a>Mutable关键字</h4><p>与const共同使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_DebugCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		m_DebugCount++;<span class="comment">//在这里，本来该方法不能修改类成员变量，但mutable是例外，可以修改了,mutable 将其标记为可变的。</span></span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lambda</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">auto</span> f = []() &#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;<span class="comment">//lambada函数</span></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]() &#123;<span class="comment">//传地址</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() &#123;<span class="comment">//传值</span></span><br><span class="line">    x++;<span class="comment">//在这里因为是值传递，相当于用新的变量储存，x不会发生改变</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    x++;<span class="comment">//外部的x变量仍然不会改变</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;<span class="comment">//9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f</span>();<span class="comment">//x = 8</span></span><br></pre></td></tr></table></figure>

<h3 id="Member-Initializer-Lists成员初始化列表"><a href="#Member-Initializer-Lists成员初始化列表" class="headerlink" title="Member Initializer Lists成员初始化列表"></a>Member Initializer Lists成员初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    &#125;<span class="comment">//可以使用初始化列表来完成：</span></span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Score</span>(<span class="number">0</span>)<span class="comment">//需要按照声明顺序定义</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    	：<span class="built_in">m_Name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_Name = name;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entiyt e0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，实际上在不同的构造函数中，如果对</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    Example m_Example;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    	m_Example = <span class="built_in">Example</span>(<span class="number">8</span>)<span class="comment">////调用了构造函数，不带参数，来源于m_Example声明。也调用了参数为8的构造函数。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Example</span>(<span class="built_in">Example</span>(<span class="number">8</span>))，<span class="built_in">m_Example</span>(<span class="number">8</span>)<span class="comment">//只调用一次参数为8的构造函数，节约性能。</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    	：<span class="built_in">m_Name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_Name = name;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ternary-Operators三元操作符"><a href="#Ternary-Operators三元操作符" class="headerlink" title="Ternary Operators三元操作符"></a>Ternary Operators三元操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s_Level&gt;<span class="number">5</span>)&#123;</span><br><span class="line">    s_Speed = <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s_Speed = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">s_Speed = s_Level&gt;<span class="number">5</span> ? <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">std::string rank = s_Level &gt; <span class="number">10</span> ?<span class="string">&quot;Master&quot;</span>: <span class="string">&quot;Beginner&quot;</span>;<span class="comment">//三元操作符能做到更快</span></span><br><span class="line">std::string rank;<span class="comment">//需要先声明，并调用构造函数</span></span><br><span class="line"><span class="keyword">if</span>(s_Level&gt;<span class="number">10</span>)</span><br><span class="line">    rank = <span class="string">&quot;Master&quot;</span>;<span class="comment">//还要进行重载</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    rank = <span class="string">&quot;Beginner&quot;</span>;</span><br><span class="line"></span><br><span class="line">s_Speed = s_Level &gt; <span class="number">5</span> ? s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line">s_Speed = s_Level &gt; <span class="number">5</span> ? (s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> ) : <span class="number">5</span>;</span><br><span class="line">s_Speed = s_Level &gt; <span class="number">5</span> &amp;&amp; s_Level &lt; <span class="number">100</span> ? s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> : <span class="number">5</span>;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/OpenGL/C++%20learning_01/" data-id="cmfe1u6p70011scuhb9a1cyz7" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/C++ learning_02" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2025/09/10/TA/OpenGL/C++%20learning_02/" class="article-date">
  <time datetime="2025-09-10T13:18:14.018Z" itemprop="datePublished">2025-09-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="Create-Instantiate-Objects-对象的实例化"><a href="#Create-Instantiate-Objects-对象的实例化" class="headerlink" title="Create&#x2F;Instantiate Objects 对象的实例化"></a>Create&#x2F;Instantiate Objects 对象的实例化</h3><p>创建一个类始终需要在C++中占用内存，即使是空类，也会占用一个字节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> String std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> String&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity entity = <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);<span class="comment">//当前函数运行结束时，该实例会销毁</span></span><br><span class="line">    <span class="comment">//如果希望对象在当前函数的生命周期之外存在，</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Funtion</span>();</span><br><span class="line">    Entity entity;<span class="comment">//调用默认构造函数</span></span><br><span class="line">    Entity entity2 = <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="function">Entity <span class="title">entity3</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; entity.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    Entity* e;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">        <span class="comment">//即便如此，括号结束后，e指向的地址上的对象也会被销毁。</span></span><br><span class="line">        e = &amp;entity;</span><br><span class="line">        std::cout &lt;&lt; entity.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;<span class="comment">//如果要让entity一直存在，就不能这样实例化在(stack)堆栈中。</span></span><br><span class="line">    </span><br><span class="line">    Entity* e;</span><br><span class="line">    &#123;</span><br><span class="line">        Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);<span class="comment">//在Array部分也说过，new关键字的特性，即使当前生命周期结束也不会销毁内存，必须手动释放。(heap堆)</span></span><br><span class="line">        e = entity;</span><br><span class="line">        std::cout &lt;&lt; (*entity).<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> e;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="New-Keyword-New关键字"><a href="#New-Keyword-New关键字" class="headerlink" title="New Keyword New关键字"></a>New Keyword New关键字</h3><p>New的主要功能是在heap堆上分配内存</p>
<ul>
<li>new int在内存上连续的一部分分配一个4bytes的空间，并返回一个指针指向这个地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];<span class="comment">// 200 bytes</span></span><br><span class="line"></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//根据Entity()的大小，获得在内存上连续的一块空间</span></span><br><span class="line"><span class="comment">//********同时会调用构造函数********</span></span><br><span class="line">Entity* e = <span class="keyword">new</span> Entity[<span class="number">50</span>];<span class="comment">//50倍大小</span></span><br><span class="line"></span><br><span class="line">(Entity*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Entity));<span class="comment">//不会调用构造函数</span></span><br></pre></td></tr></table></figure>

<p>new的实质是一个operator</p>
<ul>
<li>使用new分配内存，必须使用delete进行释放</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="keyword">delete</span>[] b;</span><br></pre></td></tr></table></figure>

<h3 id="Implicit-Conversion-and-the-Explicit-Keyword隐式转换和显式关键字"><a href="#Implicit-Conversion-and-the-Explicit-Keyword隐式转换和显式关键字" class="headerlink" title="Implicit Conversion and the Explicit Keyword隐式转换和显式关键字"></a>Implicit Conversion and the Explicit Keyword隐式转换和显式关键字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name):<span class="built_in">m_Name</span>(name),<span class="built_in">m_Age</span>(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> age) : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Age</span>(age)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; entity)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printingfunction</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">a</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">b</span><span class="params">(<span class="number">22</span>)</span></span>;</span><br><span class="line">    <span class="comment">//利用隐式转换可以写成</span></span><br><span class="line">    Entity a = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    Entity b = <span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PrintEntity</span>(<span class="number">22</span>);</span><br><span class="line">    <span class="built_in">PrintEntity</span>(<span class="string">&quot;Cherno&quot;</span>);<span class="comment">//这样不行</span></span><br><span class="line">    <span class="comment">//Entity 构造函数需要的string 是STD string，是一个char array</span></span><br><span class="line">    <span class="comment">//C++必须要做两次类型转换才能匹配，char-string-Entity,一次只能做一个</span></span><br><span class="line">    <span class="built_in">PintEntity</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示关键字禁止隐式转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span>:m_Name(name),m_Age(<span class="number">-1</span>)&#123;</span>&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> age) : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Age</span>(age)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; entity)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printingfunction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OPERATORS-and-OPERATOR-OVERLOADING运算符和运算符重载"><a href="#OPERATORS-and-OPERATOR-OVERLOADING运算符和运算符重载" class="headerlink" title="OPERATORS and OPERATOR OVERLOADING运算符和运算符重载"></a>OPERATORS and OPERATOR OVERLOADING运算符和运算符重载</h3><p>运算符就是一种函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x,<span class="type">float</span> y) :<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x+other.x,y+other.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector2 <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x*other.x,y*other.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Vector2 <span class="keyword">operator</span>+ (<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x+other.x,y+other.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Vector2 <span class="keyword">operator</span>* (<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x*other.x,y*other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::stream&amp; stream,<span class="type">const</span> Vector2&amp; other)&#123;</span><br><span class="line">    stream&lt;&lt;otehr.x&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;other.y;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vector2 <span class="title">pos</span><span class="params">(<span class="number">4.0f</span>,<span class="number">4.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">dir</span><span class="params">(<span class="number">3.0f</span>,<span class="number">5.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">1.1f</span>,<span class="number">1.1f</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    Vector2 resul=pos.<span class="built_in">Add</span>(dir.<span class="built_in">multiply</span>(speed));</span><br><span class="line">    Vector2 resul2 = pos+dir*speed;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt;std::endl;<span class="comment">//&lt;&lt;运算符不能直接输出Vector类型，需要重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="“this”关键字"><a href="#“this”关键字" class="headerlink" title="“this”关键字"></a>“this”关键字</h3><p>在类中，this是一个指向当前实例的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(Entity* e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">int</span> x,<span class="type">int</span> y) &#123;</span><br><span class="line">		Entity* e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//或Entity* const e = this;</span></span><br><span class="line">		x = x;</span><br><span class="line">		y = y;</span><br><span class="line">		<span class="comment">//====可以写</span></span><br><span class="line">		e-&gt;x = x</span><br><span class="line">		e-&gt;y = y</span><br><span class="line">		<span class="comment">//因此可以直接写</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="built_in">PrintEntity</span>(<span class="keyword">this</span>);<span class="comment">//this是一个指针</span></span><br><span class="line">        Entity&amp; e =*<span class="keyword">this</span></span><br><span class="line">        <span class="built_in">PrintEntity</span>(*<span class="keyword">this</span>);<span class="comment">//解指针，引用</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在const方法中并非Entity*e = this</span></span><br><span class="line">        <span class="type">const</span> Entity* e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">const</span> Entity&amp; e = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-Lifetime-Stack-Scope-Lifetimes"><a href="#Object-Lifetime-Stack-Scope-Lifetimes" class="headerlink" title="Object Lifetime(Stack&#x2F;Scope Lifetimes)"></a>Object Lifetime(Stack&#x2F;Scope Lifetimes)</h3><p>一个Scope就是一个独立的stack栈，声明周期结束，栈和栈上所有的东西都被销毁。</p>
<p>new关键字使变量创建在heap堆上，栈销毁不会影响堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Entity e;<span class="comment">//创建实例，调用构造函数</span></span><br><span class="line">        <span class="comment">//stack based variable</span></span><br><span class="line">    &#125;<span class="comment">//Scope结束，e生命周期结束，调用析构函数</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//创建实例，调用构造函数</span></span><br><span class="line">        <span class="comment">//heap based variable</span></span><br><span class="line">    &#125;<span class="comment">//Scope结束，但是并没有调用e的析构函数,因为e以new关键字声明，必须要delete才能释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">CreateArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> array[<span class="number">50</span>];<span class="comment">//这个变量内存是创建在栈上的</span></span><br><span class="line">    <span class="comment">//必须以new声明</span></span><br><span class="line">    <span class="comment">//int* array = new int[50];</span></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="built_in">CreateArray</span>();<span class="comment">//这是没用的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* ptr) : <span class="built_in">m_Ptr</span>(ptr)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">		ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">        Entity* a = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">        <span class="comment">//ScopedPtr e是创建在栈上的，因此Scope结束，会调用析构函数，这个指针的内存会通过delete被释放。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这就是智能指针unique_ptr的作用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Smart-Pointers智能指针"><a href="#Smart-Pointers智能指针" class="headerlink" title="Smart Pointers智能指针"></a>Smart Pointers智能指针</h3><ul>
<li>std::unique_ptr</li>
<li>std::shared_ptr</li>
<li>std::weak_ptr</li>
</ul>
<p>在讲述new和delete的过程中，我们为了在Scope结束时自动释放new分配的内存，在Scope内定义了一个类，储存new分配内存的指针，并在这个类中的析构函数使用delete释放，使得new分配的内存生命周期和Scope一致</p>
<p>而智能指针就是自动完成这一功能</p>
<p>智能指针就是包裹一个原生的（real raw）指针，使用new分配内存，并且基于使用智能指针的scope使用delete释放内存</p>
<h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p>unique指针就是最简单的智能指针，完成上述任务。</p>
<p>unique指针无法copy（因为是unique），如果copy这个指针，它们指向同一块内存地址。如果一个指针释放，那第二个指向同一个地址的指针也被释放了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main &#123;</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">        <span class="comment">//std::unique_ptr&lt;Entity&gt; entity = new Entity();这样是不行的</span></span><br><span class="line">        <span class="comment">//unique_ptr的定义是显式声明的，因此必须显式调用构造函数，而不能隐式转换</span></span><br><span class="line">        <span class="comment">//当然也可以这样,这是更安全的做法，如果构造函数有exception，不会出现dangling pointer悬空指针</span></span><br><span class="line">        std::unique_ptr&lt;Entity&gt; entity = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();</span><br><span class="line">        entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题在于，如果想要复制指针、或者把它传入到一个函数中等等，unique无法做到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Entity&gt; e0 = entity;<span class="comment">//这是不行的，在uniquePtr的定义中，=操作符被删除了。</span></span><br></pre></td></tr></table></figure>

<h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p>shared_ptr工作的方式是使用<strong>reference counting引用计数</strong>，引用计数可以跟踪指针使用了多少引用，只要引用数为0就释放</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line"><span class="comment">//在uniquePtr中不建议使用std::unique_ptr&lt;Entity&gt; entity(new Entity())</span></span><br><span class="line"><span class="comment">//因为会存在exception unsafety,但是sharedPtr不会</span></span><br></pre></td></tr></table></figure>

<p>shared_ptr在内存中会另外分配一块地址control block，用于储存引用计数，如果先创建new entity()，然后传递给shared_ptr构造函数，这样就是两块地址，也是exception safety的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">        std::weak_ptr&lt;Entity&gt; weakEntity = sharedEntity;</span><br><span class="line">        <span class="comment">//调用构造函数</span></span><br><span class="line">        e0 = sharedEntity;</span><br><span class="line">    &#125;<span class="comment">//scope结束，sharedEntity结束，但是内存未被销毁，因为e0还保持着它的引用</span></span><br><span class="line">&#125;<span class="comment">//e0结束，内存才被销毁，调用析构函数</span></span><br></pre></td></tr></table></figure>

<h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h4><p>weak_ptr在复制上和shared_ptr是相同的，但是它没有引用计数，也不会增加shared_ptr的引用计数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::weak_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">        <span class="comment">//调用构造函数</span></span><br><span class="line">        e0 = sharedEntity;</span><br><span class="line">    &#125;<span class="comment">//调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Copying-and-Copying-Constructors拷贝与拷贝构造函数"><a href="#Copying-and-Copying-Constructors拷贝与拷贝构造函数" class="headerlink" title="Copying and Copying Constructors拷贝与拷贝构造函数"></a>Copying and Copying Constructors拷贝与拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vec2</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">2</span>;    </span><br><span class="line">	<span class="type">int</span> b = a;<span class="comment">//这就是一个拷贝，a,b具有不同的地址</span></span><br><span class="line">    </span><br><span class="line">    vec2* a = <span class="keyword">new</span> <span class="built_in">vec2</span>();</span><br><span class="line">    vec2* b = a;<span class="comment">//a是一个指针指向一个地址，b指针现在指向同样的地址，因此这里拷贝的不是变量，而是a指向的地址（这个地址就是的地址储存的变量）</span></span><br><span class="line">    b++;<span class="comment">//因此这里b改变的是b自己的地址</span></span><br><span class="line">    b-&gt;x = <span class="number">2</span>;<span class="comment">//那么这里就是b储存的地址里的变量，因此a指向的变量也会改变。</span></span><br><span class="line">    <span class="comment">//根据指针的概念这些很容易理解</span></span><br><span class="line">    </span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些过程都是copy，包括reference</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> Char[m_Size<span class="number">+1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer,string,m_Size<span class="number">+1</span>);</span><br><span class="line">        m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里教程中演示的时候，输出的最后出现了一堆乱码，还记不记得之前讲字符串的时候说char在内存中末尾需要有0填充作终止符，因此把m_Size+1用来储存终止符</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string) &#123;</span><br><span class="line">    <span class="comment">//stream&lt;&lt; string.GetBuffer();通常来说m_Buffer是私有变量，因此需要一个接口函数，但是这里我们使用了友元函数friend关键字，让这个方法可以访问私有变量。</span></span><br><span class="line">    stream&lt;&lt;string.m_Buffer;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String string = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    String second = string;</span><br><span class="line">    </span><br><span class="line">    second[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//那么在这里由于m_Buffer的地址相同,两个实例都会发生改变</span></span><br><span class="line">    std::cout&lt;&lt;string&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;second&lt;&lt;std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对string直接拷贝然后输出后，尽管有正确的结果，但是运行结束后程序出错了。</p>
<p>在内存中我们有这两个string，它们进行的拷贝叫做shallow copy浅拷贝，它拷贝的是指针。</p>
<p>因此这两个string在内存中有相同的child pointer value子指针值（应该是指成员变量的指针）。</p>
<p>即string和second两个实例的m_Buffer地址是相同的。</p>
<p>那么这里问题就很好理解了。因为写了析构函数，在程序结束时删除m_Buffer，但是两个实例共用一个m_Buffer，自然在第二次删除的时候删除不了东西，就报错了。</p>
<p>&#x3D;&#x3D;那么这里我的思考是，如果说两个实例本来就需要用同一个变量，那么可否用static关键字来解决这个报错（至于在这里对string这个类有没有意义就不管了）&#x3D;&#x3D;</p>
<p>到这里应用上的问题已经很明显了，也就是说如果类中的成员是指针的话，不同的实例之间在拷贝的时候使用的是shallow copy，无法达到我们想要的deep copy深拷贝。</p>
<p>解决方案就是使用拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> Char[m_Size<span class="number">+1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer,string,m_Size<span class="number">+1</span>);</span><br><span class="line">        m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other);</span><br><span class="line">    <span class="comment">//C++为这种构造函数提供了接口，把它认为是拷贝构造函数，完整写出来就是下面这样</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    	: <span class="built_in">m_Buffer</span>(other.m_Buffer), <span class="built_in">m_Size</span>(other.m_Size)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="built_in">sizeof</span>(String));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这些都是浅拷贝</span></span><br><span class="line">    <span class="comment">//也可以禁用拷贝构造函数，这样就不能拷贝了，比如unique_ptr</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">        : <span class="built_in">m_Size</span>(other.m_Size) &#123;</span><br><span class="line">            m_Buffer = <span class="keyword">new</span> CHar[m_Size<span class="number">+1</span>]；</span><br><span class="line">            <span class="built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PringString</span> <span class="params">(String string)</span> </span>&#123;<span class="comment">//这样实际上又执行了拷贝构造函数，可以使用引用传递</span></span><br><span class="line">    std::cout&lt;&lt;string &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PringString</span> <span class="params">(<span class="type">const</span> String&amp; string)</span> </span>&#123;<span class="comment">//建议总是使用const reference来传递对象</span></span><br><span class="line">    std::cout&lt;&lt;string &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String string = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    String second = string;</span><br><span class="line">    </span><br><span class="line">    second[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">PringString</span>(string);</span><br><span class="line">    <span class="built_in">PringString</span>(second);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrow-Operator箭头操作符"><a href="#Arrow-Operator箭头操作符" class="headerlink" title="Arrow Operator箭头操作符"></a>Arrow Operator箭头操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;<span class="comment">//const版本中，这里也需要是const函数才可以被调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* e) : <span class="built_in">m_Obj</span>(e) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Entity* <span class="title">GetObject</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Obj &#125;</span><br><span class="line">    </span><br><span class="line">    Entiyt* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        retrun m_Obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> Entity* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="comment">//const版本</span></span><br><span class="line">        <span class="keyword">return</span> m_Obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span> () &#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    Entity* ptr = &amp;e;</span><br><span class="line">    (*ptr).<span class="built_in">Print</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    </span><br><span class="line">    ScopePtr entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    entiyt.<span class="built_in">GetObject</span>()-&gt;<span class="built_in">Print</span>();<span class="comment">//这是可以的</span></span><br><span class="line">    entity-&gt;<span class="built_in">Print</span>();<span class="comment">//这是不行的，还记得吗，这个包裹的类的地址指向成员指针，</span></span><br><span class="line">    <span class="comment">//因此为了更简便，我们需要进行重载</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> ScopePtr entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//const版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vec3</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ((vec3*)<span class="number">0</span>)-&gt;x;</span><br><span class="line">    ((vec3)<span class="literal">nullptr</span>)-&gt;;</span><br><span class="line">    <span class="type">int</span> offset = (<span class="type">int</span>*)&amp;((vec3)<span class="literal">nullptr</span>)-&gt;x;<span class="comment">//可以用箭头函数看到类储存成员变量的相对位置</span></span><br><span class="line">    vec3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dynamic-Arrays动态数组"><a href="#Dynamic-Arrays动态数组" class="headerlink" title="Dynamic Arrays动态数组"></a>Dynamic Arrays动态数组</h3><p>关于standard template，它就像一个容器，可以包含各种类型的数据。</p>
<p>std::vector其实本身和vector没啥关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vertex* vertices = <span class="keyword">new</span> Vertex[<span class="number">5</span>];</span><br><span class="line">   	<span class="comment">//限制就是我们想持续往里加东西的时候是不行的，除非把数组设很大。</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; vertices.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        std::cout&lt;&lt;vertices[i] &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v : vertices) &#123;<span class="comment">//这样每一次都对vertices的元素进行了拷贝</span></span><br><span class="line">        std::cout&lt;&lt; v &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex&amp; v : vertices) &#123;</span><br><span class="line">        std::cout&lt;&lt; v &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//erase不能传递数字，需要传递iterator</span></span><br><span class="line">    </span><br><span class="line">    vertices.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Optimizing-the-useage-of-std-vector"><a href="#Optimizing-the-useage-of-std-vector" class="headerlink" title="Optimizing the useage of std::vector"></a>Optimizing the useage of std::vector</h4><p>std::vector 在每次push_back时可能会进行拷贝，然后重新分配一段内存，删除原来的内存。因此速度会变慢</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertex) :<span class="built_in">x</span>(vertex.x),<span class="built_in">y</span>(vertex,y),<span class="built_in">z</span>(vertex.z)  &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;copied&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="comment">//一次拷贝</span></span><br><span class="line">    <span class="comment">//我们首先在mian的stack上创建了vertex，然后把它拷贝到vertices里</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;);</span><br><span class="line">    <span class="comment">//+两次拷贝，vertices进行resize，capacity变为2，然后进行两次拷贝</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>));<span class="comment">//上面这段发生了6次拷贝</span></span><br><span class="line">    <span class="comment">//capacity变为3,+三次拷贝</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>));</span><br><span class="line">    <span class="comment">//一共三次拷贝</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="comment">//直接在vector中进行构造，而不是main中。0次拷贝</span></span><br><span class="line">    <span class="comment">//注意这里不再传递vertex，而是传递构造的参数。</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Using-Libraries-static-linking-静态链接"><a href="#Using-Libraries-static-linking-静态链接" class="headerlink" title="Using Libraries(static linking)静态链接"></a>Using Libraries(static linking)静态链接</h3><p>选择库的环境（32bit，64bit）并不意味着开发的环境需要是这个，而是开发的对象，目标的运行环境。</p>
<p>32位的平台不能运行64位的程序。但是64位平台可以运行32位的程序，向下兼容。</p>
<p>我们下载预编译版本的glfw（32-bit windows binaries）</p>
<p>通常libraries会有两部分</p>
<ul>
<li>includes<ul>
<li>header files</li>
</ul>
</li>
<li>lib<ul>
<li>pre-built binaries</li>
</ul>
</li>
</ul>
<p>static linking</p>
<p>dynamic linking</p>
<p>把需要的include和对应版本的lib文件放进项目依赖文件夹中</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630103950872.png" alt="image-20220630103950872"></p>
<p>所以这就是预编译的意思，对于这个库已经帮你编译成lib文件了，运行的时候只需要link就行了，不用自己编译。</p>
<p>dll文件相当于一个字典储存了有哪些函数</p>
<p>lib就是一个static library静态库</p>
<p>在C++ 常规属性的附加包含目录就是inlude的目录，可以使用解决方案的相对路径</p>
<p>D:\学习\浙大\C++\Cherno tutorial\Practice\HelloWorld\Dependencies\GLFW\include</p>
<p>$(SolutionDir)Dependencies\GLFW\include</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630104355277.png" alt="image-20220630104355277"></p>
<p>然后就可以include了</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630104812733.png" alt="image-20220630104812733"></p>
<p>使用引号会先检索目录地址，然后再查找外部依赖库</p>
<p>如果是外部依赖External Dependencies，建议使用&lt;&gt;</p>
<p>如果是和项目一起编译，再使用“”</p>
<p>这时已经可以正常编译了ctrl+7</p>
<p>但是运行时，在link阶段就出错了</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630105501781.png" alt="image-20220630105501781"></p>
<p>这说明还没有对library进行link</p>
<p>因为我们include文件里，只有对这个函数的声明，但我们没有link去找到这个函数的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW//glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">glfwInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="built_in">glfwInit</span>();</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如我这样搞，也是可以运行的。</p>
<p>那么在项目属性的链接器linker中，可以添加附加依赖库</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630110022357.png" alt="image-20220630110022357"></p>
<p>我可以输入lib的相对地址</p>
<p>也可以直接输入名字就行了，只需要在常规选项中添加一个附加库目录</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630110240741.png" alt="image-20220630110240741"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630110149324.png" alt="image-20220630110149324"></p>
<h3 id="Using-Dynamic-Libraries动态链接"><a href="#Using-Dynamic-Libraries动态链接" class="headerlink" title="Using Dynamic Libraries动态链接"></a>Using Dynamic Libraries动态链接</h3><p>&#x3D;&#x3D;这一段暂时有点看不懂在讲什么，贴个链接在这&#x3D;&#x3D;，这个链接讲得很好</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/alexhu2010q/article/details/106264237">https://blog.csdn.net/alexhu2010q/article/details/106264237</a></p>
<p>上面的linking都是静态的，在编译时linking</p>
<p>dynamic linking就是在运行时linking，即启动程序的时候进行link，但它实际上不是exe的一部分。</p>
<p>当一般exe执行的时候，它加载进内存。如果有Dynamic link lib，这样会在运行时链接另外一个lib和额外的二进制文件（dll中），加载进内存。</p>
<p>C++的库文件分为两种：</p>
<ul>
<li>lib文件<ul>
<li>静态的</li>
<li>在build时就被打包到exe内</li>
<li>单独的一个exe文件就可以运行</li>
</ul>
</li>
<li>dll文件<ul>
<li>动态的</li>
<li>不会被打包到exe内</li>
<li>除了exe，还需要对应的dll文件一起才可以运行</li>
</ul>
</li>
</ul>
<p>glfw3dll.lib储存的是dll中的指针，用来记录glfw3.dll里面的函数等内容</p>
<p>他把link依赖库的glfwd.lib删掉了，然后换成了glfw3dll.lib</p>
<p>这时出现</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630112323377.png" alt="image-20220630112323377"></p>
<p>只需要把dll文件和可执行文件放一起就可以了。exe在执行时就能自己去找到。所以这就是为什么那么多程序有好多dll文件，他们都采用了动态链接。</p>
<p>当然也可以自己设置地址，但是exe始终是自动搜索当前目录的。</p>
<p>当我们关注glfw库中的声明时，它们一律使用了一个GLFWAPI命名空间，从它的定义可以看到在这里使用静态和动态库的区别，静态库就直接define GLFWAPI了，动态库使用了一个__declspec(dllimport)命令，（第一部分是export导出成dll的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GLFWAPI is used to declare public API functions for export</span></span><br><span class="line"><span class="comment"> * from the DLL / shared library / dynamic library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN32) &amp;&amp; defined(_GLFW_BUILD_DLL)</span></span><br><span class="line"> <span class="comment">/* We are building GLFW as a Win32 DLL */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GLFWAPI __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_WIN32) &amp;&amp; defined(GLFW_DLL)</span></span><br><span class="line"> <span class="comment">/* We are calling GLFW as a Win32 DLL */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GLFWAPI __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__GNUC__) &amp;&amp; defined(_GLFW_BUILD_DLL)</span></span><br><span class="line"> <span class="comment">/* We are building GLFW as a shared / dynamic library */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GLFWAPI __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> <span class="comment">/* We are building or calling GLFW as a static library */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GLFWAPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>但是问题在于，我们明明没有在预处理器定义里些GLFW_DLL，GLFWAPI定义为nothing，我们仍然能成功运行，这是为什么，教程把它留作小作业希望我们自己处理</p>
<p>在预处理器这里加上GFLW_DLL，和不加并没有任何不同</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630112720473.png" alt="image-20220630112720473"></p>
<p>可以看到不加这个定义，它是作为静态库的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630144531511.png" alt="image-20220630144531511"></p>
<p>目前的理解暂时是，由于glfw3dll.lib的存在，它储存了dll中的指针，因为是静态链接，在编译的时候自己就找到了。</p>
<h3 id="Making-and-Working-with-Libraries-in-C-生成库文件"><a href="#Making-and-Working-with-Libraries-in-C-生成库文件" class="headerlink" title="Making and Working with Libraries in C++生成库文件"></a>Making and Working with Libraries in C++生成库文件</h3><p>首先把我们要输出的库文件配置类型改为静态类</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701100834701.png" alt="image-20220701100834701"></p>
<p>在所需要的项目里，include目录加上engine.h所在目录</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701102241940.png" alt="image-20220701102241940"></p>
<p>这样engine已经可以在另一个项目中编译了，但还无法进行link</p>
<p>但是其实在生成engine项目时我们可以看到，它生成了一个lib文件</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701102527029.png" alt="image-20220701102527029"></p>
<p>可以在helloWorld项目右键</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701102922814.png" alt="image-20220701102922814"></p>
<p>引用选择Engine</p>
<p>然后生成时我们可以发现它首先生成Engine.lib，然后再生成Helloworld</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701102956503.png" alt="image-20220701102956503"></p>
<p>使用静态链接生成的exe包含了所有的二进制文件，可以独立运行</p>
<h3 id="How-to-Deal-with-Multiple-Return-Values处理多个返回值"><a href="#How-to-Deal-with-Multiple-Return-Values处理多个返回值" class="headerlink" title="How to Deal with Multiple Return Values处理多个返回值"></a>How to Deal with Multiple Return Values处理多个返回值</h3><p>对于同种变量，你可以返回一个数组std::&lt;array,2&gt; 或者用std::&lt;vector&gt;</p>
<p>不同种变量还可以使用tuple&#x2F;pari</p>
<p>std::tuple&lt;std::string,std::string&gt;</p>
<p>定义的方式是std::make_pari&lt;std::string,std::string&gt;()</p>
<p>调用：std::get&lt;0&gt;(sources),std::get&lt;1&gt;(sources)</p>
<p>这需要使用</p>
<p>#include &lt;utility&gt;</p>
<p>#include&lt;functional&gt;</p>
<p>但是总之建议</p>
<p>使用指针&#x2F;引用来处理返回值</p>
<p>或者使用数据结构</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/TA/OpenGL/C++%20learning_02/" data-id="cmfe1u6pa001hscuh4txy8jpf" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>