<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">XZYW7&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="XZYW7&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-TA/Maya/Maya python工作流" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/07/07/TA/Maya/Maya%20python%E5%B7%A5%E4%BD%9C%E6%B5%81/">【过程记录】Git-Vscode-Maya Python 工作流</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/07/07/TA/Maya/Maya%20python%E5%B7%A5%E4%BD%9C%E6%B5%81/" class="article-date">
  <time datetime="2022-07-06T18:16:27.000Z" itemprop="datePublished">2022-07-07</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="Maya-Python-Vscode"><a href="#Maya-Python-Vscode" class="headerlink" title="Maya Python - Vscode"></a>Maya Python - Vscode</h3><p>在maya python当中的脚本编写与运行都十分麻烦。在vscode中编写则更容易。</p>
<p>也可以搜到一些关于maya python在vscode中使用的教程，但是本文会完善一些细节以及整合更优的工作流选择。</p>
        
          <p>
            <a class="article-more-link" href="/2022/07/07/TA/Maya/Maya%20python%E5%B7%A5%E4%BD%9C%E6%B5%81/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/07/TA/Maya/Maya%20python%E5%B7%A5%E4%BD%9C%E6%B5%81/" data-id="cmfe999lq000wp4uh0ztw5oaf" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" rel="tag">过程记录</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/Sampling" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/06/29/TA/Graphics/Sampling/">【笔记】球面均匀采样的方法</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/06/29/TA/Graphics/Sampling/" class="article-date">
  <time datetime="2022-06-29T05:52:34.000Z" itemprop="datePublished">2022-06-29</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="球面均匀采样"><a href="#球面均匀采样" class="headerlink" title="球面均匀采样"></a>球面均匀采样</h2><p>对于一个参数化的单位球面<br>$$<br>x&#x3D;\cos\theta \cos\phi\<br>y&#x3D;\cos\theta \sin\phi\<br>z&#x3D;\sin\theta<br>$$</p>
<p>如果很自然地对$\theta \sim U[0,\pi],\phi \sim U[0,2\pi]$ 均匀采样的话,这张可视化的图可以很容易理解（这里 $\theta,\phi$ 和我是反的）</p>
<p><img src="http://corysimon.github.io/images/sphere/incorrect.png" alt="image"></p>
<p>回忆球面到平面参数化的展开图（如HDR图、地图），在顶部和底部的的两条线会被压缩成极点，因此靠近这两个边缘的点的分布会变得非常密集。</p>
<p>那么一般的做法是，因为我们考虑球面均匀采样，是面积均匀，对于某个采样点v，因此我们希望它的概率密度函数$pdf(v) &#x3D; \frac{1}{4\pi}$ ，</p>
<p>然后我们需要将这个采样点参数化，利用概率密度函数在积分域上积分为1<br>$$<br>pdf(v)dA &#x3D; \frac{1}{4\pi}dA &#x3D; pdf(\theta,\phi)d\theta d\phi<br>$$<br>那么这样我们需要找到$dA$ 和$d\theta d\phi$ 的映射关系，而面积微元$dA &#x3D; \sin\theta d\theta d\phi$</p>
<p>所以联合概率密度函数<br>$$<br>pdf(\theta,\phi) &#x3D; \frac{1}{4\pi}\sin\theta<br>$$<br>可以求出边际概率密度函数，由于$\theta,\phi$ 是独立的，其实也就是$\theta,\phi$ 各自的概率密度函数<br>$$<br>pdf(\theta) &#x3D; \int_0^{2\pi}pdf(\theta,\phi)d\phi &#x3D; \frac{\sin\theta}{2}\<br>pdf(\phi)&#x3D;\int_0^\pi pdf(\theta,\phi)d\theta &#x3D; \frac{1}{2\pi}<br>$$<br>概率分布函数&#x2F;累积分布函数<br>$$<br>F(\theta) &#x3D; \int_0^\theta pdf(\theta)d\theta &#x3D; \frac{1-\cos\theta}{2}\<br>F(\phi) &#x3D; \int_0^\phi pdf(\phi)d\phi &#x3D; \frac{\phi}{2\pi}<br>$$<br>也就是说，我们的参数化平面这张图上，$\theta，\phi$ 的分布就应该长这个样子了。</p>
<p>但是如何来获得一个这种分布呢？</p>
<p>方法有很多</p>
<h3 id="逆变换采样"><a href="#逆变换采样" class="headerlink" title="逆变换采样"></a>逆变换采样</h3><p>就实际应用上来说，我们最容易做的random也就是均匀分布。</p>
<p>利用一个均匀分布来得到另外一种分布，我们需要用到一个东西叫做逆变换采样<strong>Inverse_transform_sampling</strong> </p>
<p>维基百科上这张图很形象</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Inverse_transform_sampling.png/360px-Inverse_transform_sampling.png" alt="img"></p>
<p>其实就是假定某种变换$T$,使得$T(U) \sim F(\theta)$<br>$$<br>\因为U是均匀分布，因此有P(U\leq y) &#x3D; y\<br>F(\theta) &#x3D; P(\xi \leq \theta) &#x3D; P(T(U)\leq\theta)&#x3D;P(U\leq T^{-1}(\theta)) &#x3D; T^{-1}(\theta)\<br>那么自然知道，F(\theta) &#x3D; T^{-1}(\theta)\<br>那么这种变换T(U) &#x3D; F^{-1}(U)\<br>取两个随机变量\xi_1,\xi_2 \sim U\<br>F_{\theta}^{-1}(\xi_1) &#x3D; \arccos (1-2\xi_1)\<br>F_{\phi}^{-1}(\xi_2) &#x3D; 2\pi \xi_2<br>$$<br>至此推导完毕。</p>
<h3 id="其他采样方法"><a href="#其他采样方法" class="headerlink" title="其他采样方法"></a>其他采样方法</h3><p>Wolfram MathWorld里面还给了很多神奇的采样方法</p>
<h4 id="Marsaglia（1972）"><a href="#Marsaglia（1972）" class="headerlink" title="Marsaglia（1972）"></a>Marsaglia（1972）</h4><h5 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h5><p>$$<br>选择u &#x3D; \cos\theta 均匀分布，所以du &#x3D; \sin\theta d\theta\<br>x &#x3D; \sqrt{1-u^2}\cos\phi\<br>y &#x3D; \sqrt{1-u^2}\sin\phi\<br>z&#x3D;u<br>$$</p>
<h5 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h5><p>$$<br>选取x_1,x_2\sim U(0,1),进行剔除x_1^2+x_2^2\geq1\<br>x &#x3D; 2x_1\sqrt{1-x_1^2-x_2^2}\<br>y &#x3D; 2x_2\sqrt{1-x_1^2-x_2^2}\<br>z &#x3D; 1-2(x_1^2+x_2^2)<br>$$</p>
<h4 id="Cook-1957，Marsaglia-1972"><a href="#Cook-1957，Marsaglia-1972" class="headerlink" title="Cook 1957，Marsaglia 1972"></a>Cook 1957，Marsaglia 1972</h4><p>$$<br>选取x_0,x_1,x_2,x_3\sim U(-1,1)，拒绝域x_0^2+x_1^2+x_2^2+x_3^2\ge1\<br>利用四元数的变换规则\<br>x &#x3D; \frac{2(x_1x_3+x_0x_2)}{x_0^2+x_1^2+x_2^2+x_3^2}\<br>y &#x3D; \frac{2(x_2x_3-x_0x_1)}{x_0^2+x_1^2+x_2^2+x_3^2}\<br>z &#x3D; \frac{x_0^2+x_3^2-x_1^2-x_2^2}{x_0^2+x_1^2+x_2^2+x_3^2}\<br>$$</p>
<h4 id="Muller-1959，Marsaglia-1972"><a href="#Muller-1959，Marsaglia-1972" class="headerlink" title="Muller 1959，Marsaglia 1972"></a>Muller 1959，Marsaglia 1972</h4><p>$$<br>生成三个高斯随机变量x,y,z\<br>向量\frac{1}{\sqrt{x^2+y^2+z^2}}\left[\begin{array}{} x\y\z\end{array}{}\right]<br>\在表面S^2上是均匀的<br>$$</p>
<h3 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a>【参考资料】</h3><p><a target="_blank" rel="noopener" href="http://corysimon.github.io/articles/uniformdistn-on-sphere/">http://corysimon.github.io/articles/uniformdistn-on-sphere/</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/360420413">https://zhuanlan.zhihu.com/p/360420413</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/49746076">https://zhuanlan.zhihu.com/p/49746076</a></p>
<p><a target="_blank" rel="noopener" href="https://mathworld.wolfram.com/SpherePointPicking.html">球体点拾取 – 来自 Wolfram MathWorld</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inverse_transform_sampling">逆变换采样 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv5661231/">https://www.bilibili.com/read/cv5661231/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/29/TA/Graphics/Sampling/" data-id="cmfe999m1002hp4uhb40w3vad" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/C++ learning_02" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/06/28/TA/OpenGL/C++%20learning_02/">【笔记】Cherno C++ Tutorial note 02</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/06/28/TA/OpenGL/C++%20learning_02/" class="article-date">
  <time datetime="2022-06-28T05:43:54.000Z" itemprop="datePublished">2022-06-28</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h3 id="Create-Instantiate-Objects-对象的实例化"><a href="#Create-Instantiate-Objects-对象的实例化" class="headerlink" title="Create&#x2F;Instantiate Objects 对象的实例化"></a>Create&#x2F;Instantiate Objects 对象的实例化</h3><p>创建一个类始终需要在C++中占用内存，即使是空类，也会占用一个字节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> String std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> String&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity entity = <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);<span class="comment">//当前函数运行结束时，该实例会销毁</span></span><br><span class="line">    <span class="comment">//如果希望对象在当前函数的生命周期之外存在，</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Funtion</span>();</span><br><span class="line">    Entity entity;<span class="comment">//调用默认构造函数</span></span><br><span class="line">    Entity entity2 = <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="function">Entity <span class="title">entity3</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; entity.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    Entity* e;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">        <span class="comment">//即便如此，括号结束后，e指向的地址上的对象也会被销毁。</span></span><br><span class="line">        e = &amp;entity;</span><br><span class="line">        std::cout &lt;&lt; entity.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;<span class="comment">//如果要让entity一直存在，就不能这样实例化在(stack)堆栈中。</span></span><br><span class="line">    </span><br><span class="line">    Entity* e;</span><br><span class="line">    &#123;</span><br><span class="line">        Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);<span class="comment">//在Array部分也说过，new关键字的特性，即使当前生命周期结束也不会销毁内存，必须手动释放。(heap堆)</span></span><br><span class="line">        e = entity;</span><br><span class="line">        std::cout &lt;&lt; (*entity).<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> e;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="New-Keyword-New关键字"><a href="#New-Keyword-New关键字" class="headerlink" title="New Keyword New关键字"></a>New Keyword New关键字</h3><p>New的主要功能是在heap堆上分配内存</p>
<ul>
<li>new int在内存上连续的一部分分配一个4bytes的空间，并返回一个指针指向这个地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];<span class="comment">// 200 bytes</span></span><br><span class="line"></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//根据Entity()的大小，获得在内存上连续的一块空间</span></span><br><span class="line"><span class="comment">//********同时会调用构造函数********</span></span><br><span class="line">Entity* e = <span class="keyword">new</span> Entity[<span class="number">50</span>];<span class="comment">//50倍大小</span></span><br><span class="line"></span><br><span class="line">(Entity*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Entity));<span class="comment">//不会调用构造函数</span></span><br></pre></td></tr></table></figure>

<p>new的实质是一个operator</p>
<ul>
<li>使用new分配内存，必须使用delete进行释放</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="keyword">delete</span>[] b;</span><br></pre></td></tr></table></figure>

<h3 id="Implicit-Conversion-and-the-Explicit-Keyword隐式转换和显式关键字"><a href="#Implicit-Conversion-and-the-Explicit-Keyword隐式转换和显式关键字" class="headerlink" title="Implicit Conversion and the Explicit Keyword隐式转换和显式关键字"></a>Implicit Conversion and the Explicit Keyword隐式转换和显式关键字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name):<span class="built_in">m_Name</span>(name),<span class="built_in">m_Age</span>(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> age) : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Age</span>(age)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; entity)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printingfunction</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">a</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">b</span><span class="params">(<span class="number">22</span>)</span></span>;</span><br><span class="line">    <span class="comment">//利用隐式转换可以写成</span></span><br><span class="line">    Entity a = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    Entity b = <span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PrintEntity</span>(<span class="number">22</span>);</span><br><span class="line">    <span class="built_in">PrintEntity</span>(<span class="string">&quot;Cherno&quot;</span>);<span class="comment">//这样不行</span></span><br><span class="line">    <span class="comment">//Entity 构造函数需要的string 是STD string，是一个char array</span></span><br><span class="line">    <span class="comment">//C++必须要做两次类型转换才能匹配，char-string-Entity,一次只能做一个</span></span><br><span class="line">    <span class="built_in">PintEntity</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示关键字禁止隐式转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span>:m_Name(name),m_Age(<span class="number">-1</span>)&#123;</span>&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> age) : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Age</span>(age)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; entity)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printingfunction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OPERATORS-and-OPERATOR-OVERLOADING运算符和运算符重载"><a href="#OPERATORS-and-OPERATOR-OVERLOADING运算符和运算符重载" class="headerlink" title="OPERATORS and OPERATOR OVERLOADING运算符和运算符重载"></a>OPERATORS and OPERATOR OVERLOADING运算符和运算符重载</h3><p>运算符就是一种函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x,<span class="type">float</span> y) :<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x+other.x,y+other.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector2 <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x*other.x,y*other.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Vector2 <span class="keyword">operator</span>+ (<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x+other.x,y+other.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Vector2 <span class="keyword">operator</span>* (<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector2</span>(x*other.x,y*other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::stream&amp; stream,<span class="type">const</span> Vector2&amp; other)&#123;</span><br><span class="line">    stream&lt;&lt;otehr.x&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;other.y;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vector2 <span class="title">pos</span><span class="params">(<span class="number">4.0f</span>,<span class="number">4.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">dir</span><span class="params">(<span class="number">3.0f</span>,<span class="number">5.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">1.1f</span>,<span class="number">1.1f</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    Vector2 resul=pos.<span class="built_in">Add</span>(dir.<span class="built_in">multiply</span>(speed));</span><br><span class="line">    Vector2 resul2 = pos+dir*speed;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt;std::endl;<span class="comment">//&lt;&lt;运算符不能直接输出Vector类型，需要重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="“this”关键字"><a href="#“this”关键字" class="headerlink" title="“this”关键字"></a>“this”关键字</h3><p>在类中，this是一个指向当前实例的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(Entity* e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">int</span> x,<span class="type">int</span> y) &#123;</span><br><span class="line">		Entity* e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//或Entity* const e = this;</span></span><br><span class="line">		x = x;</span><br><span class="line">		y = y;</span><br><span class="line">		<span class="comment">//====可以写</span></span><br><span class="line">		e-&gt;x = x</span><br><span class="line">		e-&gt;y = y</span><br><span class="line">		<span class="comment">//因此可以直接写</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="built_in">PrintEntity</span>(<span class="keyword">this</span>);<span class="comment">//this是一个指针</span></span><br><span class="line">        Entity&amp; e =*<span class="keyword">this</span></span><br><span class="line">        <span class="built_in">PrintEntity</span>(*<span class="keyword">this</span>);<span class="comment">//解指针，引用</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在const方法中并非Entity*e = this</span></span><br><span class="line">        <span class="type">const</span> Entity* e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">const</span> Entity&amp; e = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-Lifetime-Stack-Scope-Lifetimes"><a href="#Object-Lifetime-Stack-Scope-Lifetimes" class="headerlink" title="Object Lifetime(Stack&#x2F;Scope Lifetimes)"></a>Object Lifetime(Stack&#x2F;Scope Lifetimes)</h3><p>一个Scope就是一个独立的stack栈，声明周期结束，栈和栈上所有的东西都被销毁。</p>
<p>new关键字使变量创建在heap堆上，栈销毁不会影响堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Entity e;<span class="comment">//创建实例，调用构造函数</span></span><br><span class="line">        <span class="comment">//stack based variable</span></span><br><span class="line">    &#125;<span class="comment">//Scope结束，e生命周期结束，调用析构函数</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//创建实例，调用构造函数</span></span><br><span class="line">        <span class="comment">//heap based variable</span></span><br><span class="line">    &#125;<span class="comment">//Scope结束，但是并没有调用e的析构函数,因为e以new关键字声明，必须要delete才能释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">CreateArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> array[<span class="number">50</span>];<span class="comment">//这个变量内存是创建在栈上的</span></span><br><span class="line">    <span class="comment">//必须以new声明</span></span><br><span class="line">    <span class="comment">//int* array = new int[50];</span></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="built_in">CreateArray</span>();<span class="comment">//这是没用的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* ptr) : <span class="built_in">m_Ptr</span>(ptr)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">		ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">        Entity* a = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">        <span class="comment">//ScopedPtr e是创建在栈上的，因此Scope结束，会调用析构函数，这个指针的内存会通过delete被释放。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这就是智能指针unique_ptr的作用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Smart-Pointers智能指针"><a href="#Smart-Pointers智能指针" class="headerlink" title="Smart Pointers智能指针"></a>Smart Pointers智能指针</h3><ul>
<li>std::unique_ptr</li>
<li>std::shared_ptr</li>
<li>std::weak_ptr</li>
</ul>
<p>在讲述new和delete的过程中，我们为了在Scope结束时自动释放new分配的内存，在Scope内定义了一个类，储存new分配内存的指针，并在这个类中的析构函数使用delete释放，使得new分配的内存生命周期和Scope一致</p>
<p>而智能指针就是自动完成这一功能</p>
<p>智能指针就是包裹一个原生的（real raw）指针，使用new分配内存，并且基于使用智能指针的scope使用delete释放内存</p>
<h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p>unique指针就是最简单的智能指针，完成上述任务。</p>
<p>unique指针无法copy（因为是unique），如果copy这个指针，它们指向同一块内存地址。如果一个指针释放，那第二个指向同一个地址的指针也被释放了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main &#123;</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">        <span class="comment">//std::unique_ptr&lt;Entity&gt; entity = new Entity();这样是不行的</span></span><br><span class="line">        <span class="comment">//unique_ptr的定义是显式声明的，因此必须显式调用构造函数，而不能隐式转换</span></span><br><span class="line">        <span class="comment">//当然也可以这样,这是更安全的做法，如果构造函数有exception，不会出现dangling pointer悬空指针</span></span><br><span class="line">        std::unique_ptr&lt;Entity&gt; entity = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();</span><br><span class="line">        entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题在于，如果想要复制指针、或者把它传入到一个函数中等等，unique无法做到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Entity&gt; e0 = entity;<span class="comment">//这是不行的，在uniquePtr的定义中，=操作符被删除了。</span></span><br></pre></td></tr></table></figure>

<h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p>shared_ptr工作的方式是使用<strong>reference counting引用计数</strong>，引用计数可以跟踪指针使用了多少引用，只要引用数为0就释放</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line"><span class="comment">//在uniquePtr中不建议使用std::unique_ptr&lt;Entity&gt; entity(new Entity())</span></span><br><span class="line"><span class="comment">//因为会存在exception unsafety,但是sharedPtr不会</span></span><br></pre></td></tr></table></figure>

<p>shared_ptr在内存中会另外分配一块地址control block，用于储存引用计数，如果先创建new entity()，然后传递给shared_ptr构造函数，这样就是两块地址，也是exception safety的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">        std::weak_ptr&lt;Entity&gt; weakEntity = sharedEntity;</span><br><span class="line">        <span class="comment">//调用构造函数</span></span><br><span class="line">        e0 = sharedEntity;</span><br><span class="line">    &#125;<span class="comment">//scope结束，sharedEntity结束，但是内存未被销毁，因为e0还保持着它的引用</span></span><br><span class="line">&#125;<span class="comment">//e0结束，内存才被销毁，调用析构函数</span></span><br></pre></td></tr></table></figure>

<h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h4><p>weak_ptr在复制上和shared_ptr是相同的，但是它没有引用计数，也不会增加shared_ptr的引用计数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::weak_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">        <span class="comment">//调用构造函数</span></span><br><span class="line">        e0 = sharedEntity;</span><br><span class="line">    &#125;<span class="comment">//调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Copying-and-Copying-Constructors拷贝与拷贝构造函数"><a href="#Copying-and-Copying-Constructors拷贝与拷贝构造函数" class="headerlink" title="Copying and Copying Constructors拷贝与拷贝构造函数"></a>Copying and Copying Constructors拷贝与拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vec2</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">2</span>;    </span><br><span class="line">	<span class="type">int</span> b = a;<span class="comment">//这就是一个拷贝，a,b具有不同的地址</span></span><br><span class="line">    </span><br><span class="line">    vec2* a = <span class="keyword">new</span> <span class="built_in">vec2</span>();</span><br><span class="line">    vec2* b = a;<span class="comment">//a是一个指针指向一个地址，b指针现在指向同样的地址，因此这里拷贝的不是变量，而是a指向的地址（这个地址就是的地址储存的变量）</span></span><br><span class="line">    b++;<span class="comment">//因此这里b改变的是b自己的地址</span></span><br><span class="line">    b-&gt;x = <span class="number">2</span>;<span class="comment">//那么这里就是b储存的地址里的变量，因此a指向的变量也会改变。</span></span><br><span class="line">    <span class="comment">//根据指针的概念这些很容易理解</span></span><br><span class="line">    </span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些过程都是copy，包括reference</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> Char[m_Size<span class="number">+1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer,string,m_Size<span class="number">+1</span>);</span><br><span class="line">        m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里教程中演示的时候，输出的最后出现了一堆乱码，还记不记得之前讲字符串的时候说char在内存中末尾需要有0填充作终止符，因此把m_Size+1用来储存终止符</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string) &#123;</span><br><span class="line">    <span class="comment">//stream&lt;&lt; string.GetBuffer();通常来说m_Buffer是私有变量，因此需要一个接口函数，但是这里我们使用了友元函数friend关键字，让这个方法可以访问私有变量。</span></span><br><span class="line">    stream&lt;&lt;string.m_Buffer;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String string = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    String second = string;</span><br><span class="line">    </span><br><span class="line">    second[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//那么在这里由于m_Buffer的地址相同,两个实例都会发生改变</span></span><br><span class="line">    std::cout&lt;&lt;string&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;second&lt;&lt;std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对string直接拷贝然后输出后，尽管有正确的结果，但是运行结束后程序出错了。</p>
<p>在内存中我们有这两个string，它们进行的拷贝叫做shallow copy浅拷贝，它拷贝的是指针。</p>
<p>因此这两个string在内存中有相同的child pointer value子指针值（应该是指成员变量的指针）。</p>
<p>即string和second两个实例的m_Buffer地址是相同的。</p>
<p>那么这里问题就很好理解了。因为写了析构函数，在程序结束时删除m_Buffer，但是两个实例共用一个m_Buffer，自然在第二次删除的时候删除不了东西，就报错了。</p>
<p>&#x3D;&#x3D;那么这里我的思考是，如果说两个实例本来就需要用同一个变量，那么可否用static关键字来解决这个报错（至于在这里对string这个类有没有意义就不管了）&#x3D;&#x3D;</p>
<p>到这里应用上的问题已经很明显了，也就是说如果类中的成员是指针的话，不同的实例之间在拷贝的时候使用的是shallow copy，无法达到我们想要的deep copy深拷贝。</p>
<p>解决方案就是使用拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> Char[m_Size<span class="number">+1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer,string,m_Size<span class="number">+1</span>);</span><br><span class="line">        m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other);</span><br><span class="line">    <span class="comment">//C++为这种构造函数提供了接口，把它认为是拷贝构造函数，完整写出来就是下面这样</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    	: <span class="built_in">m_Buffer</span>(other.m_Buffer), <span class="built_in">m_Size</span>(other.m_Size)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="built_in">sizeof</span>(String));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这些都是浅拷贝</span></span><br><span class="line">    <span class="comment">//也可以禁用拷贝构造函数，这样就不能拷贝了，比如unique_ptr</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">        : <span class="built_in">m_Size</span>(other.m_Size) &#123;</span><br><span class="line">            m_Buffer = <span class="keyword">new</span> CHar[m_Size<span class="number">+1</span>]；</span><br><span class="line">            <span class="built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">unsigned</span> <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PringString</span> <span class="params">(String string)</span> </span>&#123;<span class="comment">//这样实际上又执行了拷贝构造函数，可以使用引用传递</span></span><br><span class="line">    std::cout&lt;&lt;string &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PringString</span> <span class="params">(<span class="type">const</span> String&amp; string)</span> </span>&#123;<span class="comment">//建议总是使用const reference来传递对象</span></span><br><span class="line">    std::cout&lt;&lt;string &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String string = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    String second = string;</span><br><span class="line">    </span><br><span class="line">    second[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">PringString</span>(string);</span><br><span class="line">    <span class="built_in">PringString</span>(second);</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrow-Operator箭头操作符"><a href="#Arrow-Operator箭头操作符" class="headerlink" title="Arrow Operator箭头操作符"></a>Arrow Operator箭头操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;<span class="comment">//const版本中，这里也需要是const函数才可以被调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* e) : <span class="built_in">m_Obj</span>(e) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Entity* <span class="title">GetObject</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Obj &#125;</span><br><span class="line">    </span><br><span class="line">    Entiyt* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        retrun m_Obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> Entity* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="comment">//const版本</span></span><br><span class="line">        <span class="keyword">return</span> m_Obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span> () &#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    Entity* ptr = &amp;e;</span><br><span class="line">    (*ptr).<span class="built_in">Print</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    </span><br><span class="line">    ScopePtr entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    entiyt.<span class="built_in">GetObject</span>()-&gt;<span class="built_in">Print</span>();<span class="comment">//这是可以的</span></span><br><span class="line">    entity-&gt;<span class="built_in">Print</span>();<span class="comment">//这是不行的，还记得吗，这个包裹的类的地址指向成员指针，</span></span><br><span class="line">    <span class="comment">//因此为了更简便，我们需要进行重载</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> ScopePtr entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//const版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vec3</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ((vec3*)<span class="number">0</span>)-&gt;x;</span><br><span class="line">    ((vec3)<span class="literal">nullptr</span>)-&gt;;</span><br><span class="line">    <span class="type">int</span> offset = (<span class="type">int</span>*)&amp;((vec3)<span class="literal">nullptr</span>)-&gt;x;<span class="comment">//可以用箭头函数看到类储存成员变量的相对位置</span></span><br><span class="line">    vec3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dynamic-Arrays动态数组"><a href="#Dynamic-Arrays动态数组" class="headerlink" title="Dynamic Arrays动态数组"></a>Dynamic Arrays动态数组</h3><p>关于standard template，它就像一个容器，可以包含各种类型的数据。</p>
<p>std::vector其实本身和vector没啥关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vertex* vertices = <span class="keyword">new</span> Vertex[<span class="number">5</span>];</span><br><span class="line">   	<span class="comment">//限制就是我们想持续往里加东西的时候是不行的，除非把数组设很大。</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; vertices.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        std::cout&lt;&lt;vertices[i] &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v : vertices) &#123;<span class="comment">//这样每一次都对vertices的元素进行了拷贝</span></span><br><span class="line">        std::cout&lt;&lt; v &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex&amp; v : vertices) &#123;</span><br><span class="line">        std::cout&lt;&lt; v &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//erase不能传递数字，需要传递iterator</span></span><br><span class="line">    </span><br><span class="line">    vertices.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Optimizing-the-useage-of-std-vector"><a href="#Optimizing-the-useage-of-std-vector" class="headerlink" title="Optimizing the useage of std::vector"></a>Optimizing the useage of std::vector</h4><p>std::vector 在每次push_back时可能会进行拷贝，然后重新分配一段内存，删除原来的内存。因此速度会变慢</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    <span class="type">float</span> x,y,z;</span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertex) :<span class="built_in">x</span>(vertex.x),<span class="built_in">y</span>(vertex,y),<span class="built_in">z</span>(vertex.z)  &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;copied&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="comment">//一次拷贝</span></span><br><span class="line">    <span class="comment">//我们首先在mian的stack上创建了vertex，然后把它拷贝到vertices里</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;);</span><br><span class="line">    <span class="comment">//+两次拷贝，vertices进行resize，capacity变为2，然后进行两次拷贝</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>));<span class="comment">//上面这段发生了6次拷贝</span></span><br><span class="line">    <span class="comment">//capacity变为3,+三次拷贝</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;);</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>));</span><br><span class="line">    <span class="comment">//一共三次拷贝</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="comment">//直接在vector中进行构造，而不是main中。0次拷贝</span></span><br><span class="line">    <span class="comment">//注意这里不再传递vertex，而是传递构造的参数。</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Using-Libraries-static-linking-静态链接"><a href="#Using-Libraries-static-linking-静态链接" class="headerlink" title="Using Libraries(static linking)静态链接"></a>Using Libraries(static linking)静态链接</h3><p>选择库的环境（32bit，64bit）并不意味着开发的环境需要是这个，而是开发的对象，目标的运行环境。</p>
<p>我们下载预编译版本的glfw（32-bit windows binaries）</p>
<p>通常libraries会有两部分</p>
<ul>
<li>includes<ul>
<li>header files</li>
</ul>
</li>
<li>lib<ul>
<li>pre-built binaries</li>
</ul>
</li>
</ul>
<p>static linking</p>
<p>dynamic linking</p>
<p>把需要的include和对应版本的lib文件放进项目依赖文件夹中</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630103950872.png" alt="image-20220630103950872"></p>
<p>所以这就是预编译的意思，对于这个库已经帮你编译成lib文件了，运行的时候只需要link就行了，不用自己编译。</p>
<p>dll文件相当于一个字典储存了有哪些函数</p>
<p>lib就是一个static library静态库</p>
<p>在C++ 常规属性的附加包含目录就是inlude的目录，可以使用解决方案的相对路径</p>
<p>D:\学习\浙大\C++\Cherno tutorial\Practice\HelloWorld\Dependencies\GLFW\include</p>
<p>$(SolutionDir)Dependencies\GLFW\include</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630104355277.png" alt="image-20220630104355277"></p>
<p>然后就可以include了</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630104812733.png" alt="image-20220630104812733"></p>
<p>使用引号会先检索目录地址，然后再查找外部依赖库</p>
<p>如果是外部依赖External Dependencies，建议使用&lt;&gt;</p>
<p>如果是和项目一起编译，再使用“”</p>
<p>这时已经可以正常编译了ctrl+7</p>
<p>但是运行时，在link阶段就出错了</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630105501781.png" alt="image-20220630105501781"></p>
<p>这说明还没有对library进行link</p>
<p>因为我们include文件里，只有对这个函数的声明，但我们没有link去找到这个函数的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW//glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">glfwInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="built_in">glfwInit</span>();</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如我这样搞，也是可以运行的。</p>
<p>那么在项目属性的链接器linker中，可以添加附加依赖库</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630110022357.png" alt="image-20220630110022357"></p>
<p>我可以输入lib的相对地址</p>
<p>也可以直接输入名字就行了，只需要在常规选项中添加一个附加库目录</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630110240741.png" alt="image-20220630110240741"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630110149324.png" alt="image-20220630110149324"></p>
<h3 id="Using-Dynamic-Libraries动态链接"><a href="#Using-Dynamic-Libraries动态链接" class="headerlink" title="Using Dynamic Libraries动态链接"></a>Using Dynamic Libraries动态链接</h3><p>&#x3D;&#x3D;这一段暂时有点看不懂在讲什么，贴个链接在这&#x3D;&#x3D;，这个链接讲得很好</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/alexhu2010q/article/details/106264237">https://blog.csdn.net/alexhu2010q/article/details/106264237</a></p>
<p>上面的linking都是静态的，在编译时linking</p>
<p>dynamic linking就是在运行时linking，即启动程序的时候进行link，但它实际上不是exe的一部分。</p>
<p>当一般exe执行的时候，它加载进内存。如果有Dynamic link lib，这样会在运行时链接另外一个lib和额外的二进制文件（dll中），加载进内存。</p>
<p>C++的库文件分为两种：</p>
<ul>
<li>lib文件<ul>
<li>静态的</li>
<li>在build时就被打包到exe内</li>
<li>单独的一个exe文件就可以运行</li>
</ul>
</li>
<li>dll文件<ul>
<li>动态的</li>
<li>不会被打包到exe内</li>
<li>除了exe，还需要对应的dll文件一起才可以运行</li>
</ul>
</li>
</ul>
<p>glfw3dll.lib储存的是dll中的指针，用来记录glfw3.dll里面的函数等内容</p>
<p>他把link依赖库的glfwd.lib删掉了，然后换成了glfw3dll.lib</p>
<p>这时出现</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630112323377.png" alt="image-20220630112323377"></p>
<p>只需要把dll文件和可执行文件放一起就可以了。exe在执行时就能自己去找到。所以这就是为什么那么多程序有好多dll文件，他们都采用了动态链接。</p>
<p>当然也可以自己设置地址，但是exe始终是自动搜索当前目录的。</p>
<p>当我们关注glfw库中的声明时，它们一律使用了一个GLFWAPI命名空间，从它的定义可以看到在这里使用静态和动态库的区别，静态库就直接define GLFWAPI了，动态库使用了一个__declspec(dllimport)命令，（第一部分是export导出成dll的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GLFWAPI is used to declare public API functions for export</span></span><br><span class="line"><span class="comment"> * from the DLL / shared library / dynamic library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN32) &amp;&amp; defined(_GLFW_BUILD_DLL)</span></span><br><span class="line"> <span class="comment">/* We are building GLFW as a Win32 DLL */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GLFWAPI __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_WIN32) &amp;&amp; defined(GLFW_DLL)</span></span><br><span class="line"> <span class="comment">/* We are calling GLFW as a Win32 DLL */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GLFWAPI __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__GNUC__) &amp;&amp; defined(_GLFW_BUILD_DLL)</span></span><br><span class="line"> <span class="comment">/* We are building GLFW as a shared / dynamic library */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GLFWAPI __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> <span class="comment">/* We are building or calling GLFW as a static library */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GLFWAPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>但是问题在于，我们明明没有在预处理器定义里些GLFW_DLL，GLFWAPI定义为nothing，我们仍然能成功运行，这是为什么，教程把它留作小作业希望我们自己处理</p>
<p>在预处理器这里加上GFLW_DLL，和不加并没有任何不同</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630112720473.png" alt="image-20220630112720473"></p>
<p>可以看到不加这个定义，它是作为静态库的</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220630144531511.png" alt="image-20220630144531511"></p>
<p>目前的理解暂时是，由于glfw3dll.lib的存在，它储存了dll中的指针，因为是静态链接，在编译的时候自己就找到了。</p>
<h3 id="Making-and-Working-with-Libraries-in-C-生成库文件"><a href="#Making-and-Working-with-Libraries-in-C-生成库文件" class="headerlink" title="Making and Working with Libraries in C++生成库文件"></a>Making and Working with Libraries in C++生成库文件</h3><p>首先把我们要输出的库文件配置类型改为静态类</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701100834701.png" alt="image-20220701100834701"></p>
<p>在所需要的项目里，include目录加上engine.h所在目录</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701102241940.png" alt="image-20220701102241940"></p>
<p>这样engine已经可以在另一个项目中编译了，但还无法进行link</p>
<p>但是其实在生成engine项目时我们可以看到，它生成了一个lib文件</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701102527029.png" alt="image-20220701102527029"></p>
<p>可以在helloWorld项目右键</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701102922814.png" alt="image-20220701102922814"></p>
<p>引用选择Engine</p>
<p>然后生成时我们可以发现它首先生成Engine.lib，然后再生成Helloworld</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220701102956503.png" alt="image-20220701102956503"></p>
<p>使用静态链接生成的exe包含了所有的二进制文件，可以独立运行</p>
<h3 id="How-to-Deal-with-Multiple-Return-Values处理多个返回值"><a href="#How-to-Deal-with-Multiple-Return-Values处理多个返回值" class="headerlink" title="How to Deal with Multiple Return Values处理多个返回值"></a>How to Deal with Multiple Return Values处理多个返回值</h3><p>对于同种变量，你可以返回一个数组std::&lt;array,2&gt; 或者用std::&lt;vector&gt;</p>
<p>不同种变量还可以使用tuple&#x2F;pari</p>
<p>std::tuple&lt;std::string,std::string&gt;</p>
<p>定义的方式是std::make_pari&lt;std::string,std::string&gt;()</p>
<p>调用：std::get&lt;0&gt;(sources),std::get&lt;1&gt;(sources)</p>
<p>这需要使用</p>
<p>#include <utility></p>
<p>#include<functional></p>
<p>但是总之建议</p>
<p>使用指针&#x2F;引用来处理返回值</p>
<p>或者使用数据结构</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/28/TA/OpenGL/C++%20learning_02/" data-id="cmfe999lw001pp4uh1v0lcae8" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/PRT" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/06/15/TA/Graphics/PRT/">【笔记】Precomputed Radiance Transfer</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/06/15/TA/Graphics/PRT/" class="article-date">
  <time datetime="2022-06-14T17:03:46.000Z" itemprop="datePublished">2022-06-15</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="论文：《Precomputed-Radiance-Transfer-for-Real-Time-Rendering"><a href="#论文：《Precomputed-Radiance-Transfer-for-Real-Time-Rendering" class="headerlink" title="论文：《Precomputed Radiance Transfer for Real-Time Rendering"></a><center>论文：《Precomputed Radiance Transfer for Real-Time Rendering</h2><h2 id="in-Dynamic-Low-Frequency-Lighting-Environments》"><a href="#in-Dynamic-Low-Frequency-Lighting-Environments》" class="headerlink" title="in Dynamic, Low-Frequency Lighting Environments》"></a><center>in Dynamic, Low-Frequency Lighting Environments》</h2>
        
          <p>
            <a class="article-more-link" href="/2022/06/15/TA/Graphics/PRT/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/15/TA/Graphics/PRT/" data-id="cmfe999m0002dp4uh8ne61ndn" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Advanced/" rel="tag">CG Advanced</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/GAMES/过程记录PRT" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/06/15/TA/Graphics/GAMES/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95PRT/">【过程记录】【GAMES202】PRT</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/06/15/TA/Graphics/GAMES/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95PRT/" class="article-date">
  <time datetime="2022-06-14T16:03:46.000Z" itemprop="datePublished">2022-06-15</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="【过程记录】【GAMES202】PRT"><a href="#【过程记录】【GAMES202】PRT" class="headerlink" title="【过程记录】【GAMES202】PRT"></a>【过程记录】【GAMES202】PRT</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337319903">https://zhuanlan.zhihu.com/p/337319903</a></p>
<p>离线渲染的书籍：<br> \1. Physically Based Rendering (third edition)，这个不用多说了<br> \2. Advanced Global Illumination，整本书只有300多页，却基本覆盖了所有的Light Transport Method<br> \3. Robust Monte Carlo Methods for Light Transport Simulation，离线渲染必读: <a target="_blank" rel="noopener" href="http://graphics.stanford.edu/papers/veach_thesis/">http://graphics.stanford.edu/papers/veach_thesis/</a></p>
<p>课程：<br> UWaterloo蜂须贺先生的CS888: <a target="_blank" rel="noopener" href="https://cs.uwaterloo.ca/~thachisu/CS888_W21/%EF%BC%8C%E9%87%8D%E7%82%B9%E6%98%AF%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84paper">https://cs.uwaterloo.ca/~thachisu/CS888_W21/，重点是页面中的paper</a> list</p>
<p>不建议：<br> \1. Ray Traing三部曲 (in One Weekend, …) ，没啥用（默认已经从101之类的课程学到了基本的Monte Carlo方法和Path tracing的话）<br> \2. SmallPT，这个学懂了来看着玩可以，不懂的不要妄想从这个来学习离线渲染（本末倒置了属于是）</p>
<p>首先作业分成两部分</p>
<ol>
<li>预计算部分（cpp）</li>
<li>实时环境光照部分（webgl）</li>
</ol>
<p>这次的作业离线预计算部分使用了nori的光线追踪框架（既然这么巧遇到，正好202结束，渲染方向就做这个吧）</p>
<h3 id="预计算部分"><a href="#预计算部分" class="headerlink" title="预计算部分"></a>预计算部分</h3><p>首先是项目构建，就cmake构建。</p>
<p>在编译时就遇到了问题</p>
<p><img src="/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95PRT/image-20221006012253027.png" alt="image-20221006012253027"></p>
<p>但是这儿明明啥都没有</p>
<p><img src="/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95PRT/image-20221006012301544.png" alt="image-20221006012301544"></p>
<p>解决方法如下，这是由于MSVC对中文字符编码的支持问题。</p>
<p><a target="_blank" rel="noopener" href="https://games-cn.org/forums/topic/guanyuzuoye2kaitoubianyidekunhuo/">https://games-cn.org/forums/topic/guanyuzuoye2kaitoubianyidekunhuo/</a></p>
<p>编译成功后是这样的输出</p>
<p><img src="/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95PRT/image-20221006013619106.png" alt="image-20221006013619106"></p>
<p><img src="/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95PRT/image-20221006013558409.png" alt="image-20221006013558409"></p>
<p>这里输出的信息有一些值得关注的</p>
<p>主要是这里讲光照的信息</p>
<p><img src="/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95PRT/image-20221006013929438.png" alt="image-20221006013929438"></p>
<p>来自于这个light.txt</p>
<p>而我们的SH系数最后输出到了transport.txt里面</p>
<p><img src="/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95PRT/image-20221006014056237.png" alt="image-20221006014056237"></p>
<p>根据作业说明，我们知道这次的环境光照也还是来源于环境贴图，也就是说，我们这次其实不是完全计算的环境光，其实只是把环境贴图的环境光照转化成SH的表达而已。</p>
<p>3.54535 3.54535 3.54535<br>4.92763e-07 4.92763e-07 4.92763e-07<br>-1.9416e-07 -1.9416e-07 -1.9416e-07<br>2.29642e-07 2.29642e-07 2.29642e-07<br>0 0 0<br>0 0 0<br>0 0 0<br>0 0 0<br>0 0 0</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/15/TA/Graphics/GAMES/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95PRT/" data-id="cmfe999mx00cbp4uhcr2w7nvj" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Advanced/" rel="tag">CG Advanced</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAMES/" rel="tag">GAMES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" rel="tag">过程记录</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Diary/2022-06-09" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/06/09/Diary/2022-06-09/">2022年6月9日 周四</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/06/09/Diary/2022-06-09/" class="article-date">
  <time datetime="2022-06-09T15:30:50.000Z" itemprop="datePublished">2022-06-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>今天算是阶段性的结束，稍微来写点总结。</p>
        
          <p>
            <a class="article-more-link" href="/2022/06/09/Diary/2022-06-09/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/09/Diary/2022-06-09/" data-id="cmfe999lm000cp4uh7ykx5qte" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/GAMES/Real-time Global Illumination" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/15/TA/Graphics/GAMES/Real-time%20Global%20Illumination/">【笔记】【GAMES202】Real-time Global Illumination实时全局光照</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/15/TA/Graphics/GAMES/Real-time%20Global%20Illumination/" class="article-date">
  <time datetime="2022-05-15T06:26:26.000Z" itemprop="datePublished">2022-05-15</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="Real-time-Global-Illumination-in-3D"><a href="#Real-time-Global-Illumination-in-3D" class="headerlink" title="Real-time Global Illumination(in 3D)"></a>Real-time Global Illumination(in 3D)</h2><p>全局光照 &#x3D; 直接光照（光线弹射一次）+ 间接光照（光线弹射大于一次）</p>
<h3 id="Reflective-Shadow-Maps-RSM"><a href="#Reflective-Shadow-Maps-RSM" class="headerlink" title="Reflective Shadow Maps(RSM)"></a>Reflective Shadow Maps(RSM)</h3><p>用间接光照照亮一个点p需要知道什么？</p>
<ul>
<li>哪些surface patches are directly lit<ul>
<li>shadow mapping可以提供这个信息</li>
</ul>
</li>
<li>每个surface patch对p的贡献是什么<ul>
<li>每个surface patch作为area light，把他们都加起来</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220512222030784.png" alt="image-20220512222030784" style="zoom:67%;" />

<p>假设被直接光照亮的次级光源是diffuse的</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220512222601390.png" alt="image-20220512222601390" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220512225823209.png" alt="image-20220512225823209" style="zoom:67%;" />

<p>（它这里分母四次方是因为点乘当中没有归一化）</p>
<p>忽略次级光源对shading point的可见性。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220512230920138.png" alt="image-20220512230920138" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220512230929309.png" alt="image-20220512230929309" style="zoom:67%;" />

<p>总结：其实就是shadow mapping的思想，把所有次级光源看作diffuse，着色的时候进行对次级光源采样</p>
<p>这是对于单个光源。问题是无法处理过多光源，也没有考虑间接光照部分的可见项，并且有非常多的采样。</p>
<p>可以看作Virtual point light（VPL）方法的光栅化版</p>
<h3 id="Light-Propagation-Volumes-LPV"><a href="#Light-Propagation-Volumes-LPV" class="headerlink" title="Light Propagation Volumes(LPV)"></a>Light Propagation Volumes(LPV)</h3><p>CryEngine3引入的技术，快速、质量高</p>
<ul>
<li><p>核心问题</p>
<ul>
<li>shading point来自不同方向的radiance</li>
</ul>
</li>
<li><p>思想</p>
<ul>
<li>Radiance在空间中沿直线传播并且不改变</li>
<li>使用3D网格将直接光照的表面传输到其他地方</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li><p>&#x3D;&#x3D;Generation&#x3D;&#x3D; of radiance point set scene representation生成radiance点集</p>
<ul>
<li>找到直接光照表面</li>
<li>应用RSM</li>
<li>可能使用简化的diffuse surface patches（virtual light sources）</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;Injection&#x3D;&#x3D; of point cloud of virtual light source into radiance volume</p>
<ul>
<li>预细分场景为3D网格</li>
<li>对于每个格子，找到包含的virtual light source</li>
<li>Sum up their directional light distribution</li>
<li>Project to first 2 orders of SHs（4 in total）投影到2阶SH</li>
</ul>
</li>
<li><p>Volumetric radiance &#x3D;&#x3D;propagetion&#x3D;&#x3D;</p>
<ul>
<li>对于每个网格，收集6个表面接收到的radiance</li>
<li>Sum up，and again use SH to represent</li>
<li>重复传播若干次至收敛</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514211324813.png" alt="image-20220514211324813" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>Scene &#x3D;&#x3D;lighting&#x3D;&#x3D; with final light propagation volume</p>
<ul>
<li>对于每个shading point，找到所在的grid cell</li>
<li>取网格中的incident radiance（from all directions）</li>
<li>Shade</li>
</ul>
</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514211513120.png" alt="image-20220514211513120" style="zoom:67%;" /></li>
<li>因为认为同一网格radiance相同 ——light leaking</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514213435555.png" alt="image-20220514213435555" style="zoom:67%;" /></li>
<li>同样假设格子间的visibility不计算</li>
</ul>
</li>
</ul>
<h3 id="Voxel-Global-Illumination-VXGI"><a href="#Voxel-Global-Illumination-VXGI" class="headerlink" title="Voxel Global Illumination(VXGI)"></a>Voxel Global Illumination(VXGI)</h3><ul>
<li><p>two-pass algorithm</p>
</li>
<li><p>Two main differences with RSM</p>
<ul>
<li>Directly illuminated pixels -&gt; （hierachical） voxels</li>
<li>Sampling on RSM -&gt; tracing reflected cones in 3D(Note the inaccuracy in sampling RSM) （Cone tracing）</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514220033906.png" alt="image-20220514220033906" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514220348504.png" alt="image-20220514220348504" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514220600084.png" alt="image-20220514220600084" style="zoom:67%;" />

<p>问题：体素化的复杂度</p>
<h2 id="Real-time-Global-Illumination-Screen-Space"><a href="#Real-time-Global-Illumination-Screen-Space" class="headerlink" title="Real-time Global Illumination(Screen Space)"></a>Real-time Global Illumination(Screen Space)</h2><p>Screen space：利用从相机渲染场景得到的直接光照信息Direct illumination</p>
<p>相当于post processing on existing rendering</p>
<h3 id="Screen-Space-Ambient-Occlusion-SSAO"><a href="#Screen-Space-Ambient-Occlusion-SSAO" class="headerlink" title="Screen Space Ambient Occlusion(SSAO)"></a>Screen Space Ambient Occlusion(SSAO)</h3><p>环境光遮蔽AO，Crytek</p>
<p>AO就是场景中物体之间的contact shadow，易于实现，增强场景中的相对位置信息</p>
<ul>
<li><p>SSAO</p>
<ul>
<li>An approximation of GI</li>
<li>in screen space</li>
</ul>
</li>
<li><p>Key idea 1</p>
<ul>
<li>假设不知道间接光照</li>
<li>假设它是一个常数，对于所有shading points，来自不同方向</li>
<li>idea1相当于Ambient的思路</li>
</ul>
</li>
<li><p>Key idea 2&amp;3</p>
<ul>
<li>考虑different visibility（towards all directions）at different shading points</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514222931272.png" alt="image-20220514222931272" style="zoom:67%;" /></li>
<li>（3D建模软件里大概叫天光）</li>
<li>此外，假设是diffuse材质</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514223032378.png" alt="image-20220514223032378" style="zoom:67%;" />

<h4 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h4><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514223158769.png" alt="image-20220514223158769" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514223535289.png" alt="image-20220514223535289" style="zoom:67%;" />

<p>$K_a * L_i^{indir}*albedo$ </p>
<p>在diffuse、间接光照为常数的情况下，这是准确的</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514223901474.png" alt="image-20220514223901474" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514224020238.png" alt="image-20220514224020238" style="zoom:67%;" />

<p>投影立体角（Projected solid angle）</p>
<p>（实际上解释了$cos\theta dw_i$ 半球积分为$\pi$  ）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514224235118.png" alt="image-20220514224235118" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514224537665.png" alt="image-20220514224537665" style="zoom:67%;" />

<p>但是这样是没有加权平均的</p>
<h4 id="如何实时计算ka项"><a href="#如何实时计算ka项" class="headerlink" title="如何实时计算ka项"></a>如何实时计算ka项</h4><ul>
<li>世界空间<ul>
<li>ray casting</li>
</ul>
</li>
<li>屏幕空间<ul>
<li>post-rendering pass</li>
<li>不用预计算</li>
<li>不依赖场景复杂度</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514224953129.png" alt="image-20220514224953129" style="zoom:67%;" />

<p>只考虑一定范围内有没有遮挡物</p>
<ul>
<li>SSAO</li>
<li>假设任何一个shading point 在周围体积采样点，判断点被shading point看到的结果</li>
<li>使用相机的depth buffer来判断</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514225151550.png" alt="image-20220514225151550" style="zoom:67%;" /></li>
<li>按理说只需要考虑法线方向的半球就可以了，但法线信息可能是不知道的</li>
<li>因此做法是，只有过半的点在内部（红点），才开始使用AO，使用球而不是半球，但是只有过半的点才开始计算</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514225603651.png" alt="image-20220514225603651" style="zoom:67%;" /></li>
<li>也没有cos项的权重，但这一点可以忽略了</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514230015563.png" alt="image-20220514230015563" style="zoom:67%;" /></li>
</ul>
<p>其他问题：False occlusions</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220514230147163.png" alt="image-20220514230147163" style="zoom:67%;" />

<ul>
<li><p>Choosing samples</p>
<ul>
<li>采样越多越精确，但考虑速度只用16个</li>
<li>少量sample得到结果，再降噪</li>
</ul>
</li>
<li><p>Horizon based ambient occlusion（HBAO）</p>
<ul>
<li>也是在屏幕空间</li>
<li>近似ray tracing 深度缓冲</li>
<li>需要知道法线（normal map），只采样半球</li>
<li>（有法线可以对不同方向进行加权计算）</li>
</ul>
</li>
</ul>
<h3 id="Screen-Space-Directional-Occlusion-SSDO"><a href="#Screen-Space-Directional-Occlusion-SSDO" class="headerlink" title="Screen Space Directional Occlusion(SSDO)"></a>Screen Space Directional Occlusion(SSDO)</h3><ul>
<li>SSDO<ul>
<li>SSAO的提高</li>
<li>考虑更多的实际间接光照</li>
</ul>
</li>
<li>思路<ul>
<li>不必假设接受的间接光照是uniform的</li>
<li>一部分间接光照信息是已知的（间接光照&#x3D;次级光源提供的直接光照（RSM））</li>
</ul>
</li>
<li>SSDO使用的直接光照信息不来自于RSM，来自于摄像机</li>
<li>类似于path tracing<ul>
<li>在shading point发射随机的光线</li>
<li>如果没有遇到障碍物，是直接光照</li>
<li>如果遇到障碍，是间接光照</li>
</ul>
</li>
<li>比较<ul>
<li>AO假设间接光照来源非常远，DO假设间接光照来源周围</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515131429453.png" alt="image-20220515131429453" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515131937025.png" alt="image-20220515131937025" style="zoom:67%;" />

<p>类似HBAO，考虑点p的局部半球</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515132410638.png" alt="image-20220515132410638" style="zoom:67%;" />

<p>采样到的点不被挡住，则没有间接光照，被挡住，则有间接光照，并且把它们加起来。</p>
<p>如图3，会出这样的问题，P-A没有被挡住，但在屏幕空间的深度判断下，将它认为是挡住的，P-B则相反。</p>
<ul>
<li>SSDO质量更接近离线渲染</li>
<li>仍然只是小范围的GI</li>
<li>可见性偏差</li>
<li>屏幕空间的问题，丢失了不可见表面的信息（一切SS都会出现这种问题）</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515132917610.png" alt="image-20220515132917610" style="zoom:67%;" />

<h3 id="Screen-Space-Reflection-SSR"><a href="#Screen-Space-Reflection-SSR" class="headerlink" title="Screen Space Reflection(SSR)"></a>Screen Space Reflection(SSR)</h3><ul>
<li>SSR<ul>
<li>RTR中实施GI的方式</li>
<li>在屏幕空间进行光线追踪</li>
<li>不需要3D信息</li>
</ul>
</li>
<li>基本任务<ul>
<li>求交<ul>
<li>光线和场景</li>
</ul>
</li>
<li>着色<ul>
<li>从交点像素到着色点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>反射本身就是全局光照</p>
<p>假设场景没有反射，要加入反射，反射出来的东西都是屏幕上已有的东西。</p>
<ul>
<li>对于每个像素（镜面反射）<ul>
<li>计算反射光线</li>
<li>和屏幕上的物体求交</li>
<li>使用交点颜色做反射色</li>
</ul>
</li>
<li>对于一定roughness的材质，根据BRDF考虑采样的反射光线数量</li>
<li>甚至可以加上法线信息</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515133949777.png" alt="image-20220515133949777" style="zoom:67%;" />

<p>对于地面任何一个点，可以描述它的反射光，如何求交？</p>
<ul>
<li>Linear Raymarch<ul>
<li>每一步检测深度值</li>
<li>质量取决于step size</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515134334564.png" alt="image-20220515134334564" style="zoom:67%;" />

<ul>
<li>Hierarchy ray trace<ul>
<li>Generate Depth Mip map<ul>
<li>下采样使用最小深度而不是平均</li>
<li>类似于3D空间的层次结构（BVH，KD-tree）</li>
<li>能快速舍弃不可能相交的像素</li>
<li>最小值建立一个保守的判断逻辑</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515134751855.png" alt="image-20220515134751855" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515134931819.png" alt="image-20220515134931819" style="zoom:67%;" />

<p>先保守一点只走一步，没有交点，就可以多走一些，如果终于遇到了最小深度交点，就有可能和场景相交了，就需要少走一些。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515135234170.png" alt="image-20220515135234170" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515135328284.png" alt="image-20220515135328284" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515135417034.png" alt="image-20220515135417034"  />

<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515135432576.png" alt="image-20220515135432576"></p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515135443096.png" alt="image-20220515135443096"></p>
<p>最小层级都有交点，或者离开了屏幕，就可以停止了。</p>
<p>局限：Mipmap上判断不了起点不在2^k上像素的深度最小值</p>
<ul>
<li>问题：，因为只在屏幕空间中计算<ul>
<li>Hidden Geometry Problem</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515140428156.png" alt="image-20220515140428156" style="zoom:67%;" /></li>
<li>Edge Cutoff</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515140620129.png" alt="image-20220515140620129" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h4 id="Shading-using-SSR"><a href="#Shading-using-SSR" class="headerlink" title="Shading using SSR"></a>Shading using SSR</h4><p>和path tracing没有差别，只需要假设diffuse reflectors&#x2F;secondary lights</p>
<ul>
<li>是否引入平方衰减？<ul>
<li>不需要，只要是算radiance，就不用，只有irradiance才会有伴随面积变大，能量衰减的效果。</li>
</ul>
</li>
<li>是否考虑了着色点和次级光源之间的可见性？<ul>
<li>是的，因为ray trace</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220515140938022.png" alt="image-20220515140938022" style="zoom:67%;" />

<p>可以解决</p>
<ul>
<li><p>Sharp、bulrry reflections</p>
</li>
<li><p>Contact hardening(specular的lobe在非常近的距离，也只会采样很少的范围)</p>
</li>
<li><p>Specular elongation（被拉长，还是brdf的lobe采样的原因）</p>
</li>
<li><p>Per-pixel roughness and normal</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/15/TA/Graphics/GAMES/Real-time%20Global%20Illumination/" data-id="cmfe999mf0055p4uhbwk83ok4" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Advanced/" rel="tag">CG Advanced</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAMES/" rel="tag">GAMES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/Progressive Photon Mapping" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/14/TA/Graphics/Progressive%20Photon%20Mapping/">【笔记】Progressive Photon Mapping渐进式光子映射</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/14/TA/Graphics/Progressive%20Photon%20Mapping/" class="article-date">
  <time datetime="2022-05-14T15:52:46.000Z" itemprop="datePublished">2022-05-14</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="渐进式光子映射Progressive-Photon-Mapping"><a href="#渐进式光子映射Progressive-Photon-Mapping" class="headerlink" title="渐进式光子映射Progressive Photon Mapping"></a>渐进式光子映射Progressive Photon Mapping</h2><p>感觉有点难找到合适的教程。</p>
<p>直接看pbrt有点头大，于是选择了从论文开始。这里的内容主要是论文翻译</p>
<p>PPM相对于其他无偏的离线渲染方法（主要指PT，BPT，MLT）和一些有偏的方法（PM），解决的是SDS的问题（SDS中的caustic现象）。</p>
<h3 id="光子映射Photon-mapping"><a href="#光子映射Photon-mapping" class="headerlink" title="光子映射Photon mapping"></a>光子映射Photon mapping</h3><p>是一个2pass 的方法</p>
<ul>
<li>1st pass<ul>
<li>photon tracing</li>
</ul>
</li>
<li>2nd pass<ul>
<li>rendering using photon map</li>
</ul>
</li>
</ul>
<p>对于一个photon map，任何一个表面位置x的exitant radiance估计为<br>$$<br>L(x,\overrightarrow w)\approx\sum_{p&#x3D;1}^n\frac{f_r(x,\overrightarrow w,\overrightarrow w_p)\phi_p(x_p,\overrightarrow w_p)}{\pi r^2}<br>$$<br>$n$ :邻近的光子数量，用来估计incoming radiance</p>
<p>$\phi_p$ :第p个光子的flux（power）</p>
<p>这种估计假设了局部的光子代表了x接收到的radiance,并且x周围的表面是平坦（flat）的。</p>
<p>这也是Photon mapping方法偏差的来源。photon tracing过程本身是无偏的，但是photon分布的结果在radiance estimate的过程中进行平均（blurred）。</p>
<p>光子密度（photon density）增加，radiance的估计也会收敛到正确的结果，这说明光子映射是一致的(consistent)。</p>
<p>为了保证收敛到正确结果，需要在photon map中储存无限的光子，并且radius半径需要收敛到0。我们可以通过一种操作满足这些要求：</p>
<p>在photon map 中使用$N$个光子，但是只有$N^\beta$ ($\beta\in [0,1]$)个光子用来进行radiance 估计，当$N$趋近无穷时，$N$和$N^\beta$ 都趋近无穷，但是$N^\beta$是N的高阶无穷小，保证了r收敛到0，以下会把它称为辐射度估计方程。<br>$$<br>L(x,\overrightarrow w)\approx \lim <em>{N\to\infin}\sum</em>{p&#x3D;1}^{N^\beta}\frac{f_r(x,\overrightarrow w,\overrightarrow w_p)\phi_p(x_p,\overrightarrow w_p)}{\pi r^2}<br>$$<br>在标准的光子映射中，这个结果是理论正确的，但是光子储存在内存中，这使得无法获得精确的结果。</p>
<p>渐进式光子映射将解决这个问题。</p>
<h3 id="渐进式光子映射Progressive-Photon-Mapping-1"><a href="#渐进式光子映射Progressive-Photon-Mapping-1" class="headerlink" title="渐进式光子映射Progressive Photon Mapping"></a>渐进式光子映射Progressive Photon Mapping</h3><p>刚才又去浏览了一下PBRT，我知道我为什么看起来难受了，Literate Programming是什么鬼啊……文学编程……从零开始直接跳去看PM的内容着实有点难受了。还是接着从论文开始吧。</p>
<p>PPM是多pass的算法，先是ray tracing，然后子序列的pass用来做photon tracing，每一次的photon tracing pass 都会提升全局光照结果的准确性。</p>
<h4 id="Ray-Tracing-Pass"><a href="#Ray-Tracing-Pass" class="headerlink" title="Ray Tracing Pass"></a>Ray Tracing Pass</h4><p>使用标准的ray tracing通过图像中的每个像素找到场景中所有可见表面，每一条ray path都包含了所有specular的反弹，直到遇到第一个non-specular的表面。</p>
<p>场景中specular表面比较多时，也可以用俄罗斯轮盘赌（Russian Roulette）来停止。而如果击中的表面BRDF有non-specular的部分，对于每个ray path我们都储存路径上所有的hit points（对于这句话我的理解是，如果不是完全镜面的表面，就会有能量的吸收，有一部分光子停留在这里）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  <span class="title class_">hitpoint</span> &#123;</span><br><span class="line">    position x;<span class="comment">//击中位置</span></span><br><span class="line">    normal   n;<span class="comment">//x所在的法线</span></span><br><span class="line">    vector   w;<span class="comment">//入射光线方向</span></span><br><span class="line">    integer BRDF;<span class="comment">//BRDF的index</span></span><br><span class="line">    <span class="type">float</span>    x,y;<span class="comment">//像素位置</span></span><br><span class="line">    color    wgt;<span class="comment">//像素权重</span></span><br><span class="line">    <span class="type">float</span>    R;<span class="comment">//当前的光子查找半径</span></span><br><span class="line">    integer  N;<span class="comment">//累计光子数</span></span><br><span class="line">    color    t;<span class="comment">//累计反射的flux能量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Photon-Tracing-Pass"><a href="#Photon-Tracing-Pass" class="headerlink" title="Photon Tracing Pass"></a>Photon Tracing Pass</h4><p>这个步骤是用来累计光子能量的。可以分成很多的pass去做，每个pass追踪一系列光子，每个 photon tracing pass结束后，就去查看所有hit points，找到半径区域的光子。使用新加入的光子来修正光照计算。光子的贡献一经记录，就可以把光子丢掉了，然后再去处理下一个photon tracing pass。直到累积了足够数量的光子。</p>
<p>我们甚至可以在每个PTP后渲染一遍场景，累积的光子越多，场景的质量就越高。</p>
<h4 id="Progressive-Radiance-Estimate渐进的辐射度估计"><a href="#Progressive-Radiance-Estimate渐进的辐射度估计" class="headerlink" title="Progressive Radiance Estimate渐进的辐射度估计"></a>Progressive Radiance Estimate渐进的辐射度估计</h4><p>传统的PM算法估计着色点的局部光子密度<br>$$<br>d(x) &#x3D; \frac{n}{\pi r^2}<br>$$<br>这个估计的假设是周围是平面，在一个半径为r的圆盘上去估计。如果我们在新的光子图上，要产生新的光子，在同样的圆盘上去估计密度，那就是<br>$$<br>d’(x)&#x3D;\frac{n’}{\pi r^2}<br>$$<br>把$d(x)$ 和$d’(x)$ 进行平均，我们可以获得半径 r上更准确的估计。这种方法可以获得更加平滑的radiance估计，但是最终结果由于平均计算会失去很多细节。并且平均过程会破坏一致性，使得无法收敛到正确结果。</p>
<p>渐进式的辐射度估计结合多个光子图，能够收敛到正确结果，也能解决细节问题。关键方法是在每个hit point的辐射度估计中，随着光子数量的累计减少半径。这有效地保证了光子密度在极限估计趋于无穷。</p>
<p>接下来会描述光子密度是如何渐进式增长的。我们在ray tracing pass生成的每个hit points上都会计算辐射度估计。初始化时，x对应的半径R(x)会设置一个非零值，比如说对应像素的footprint（虎书中对像素footprint的解释是，屏幕空间像素映射到纹理空间的形状，这里可以看作世界空间）。也可以第一次photon tracing pass后，通过使用光子图来估计半径。 </p>
<h5 id="Radius-Reduction半径缩减"><a href="#Radius-Reduction半径缩减" class="headerlink" title="Radius Reduction半径缩减"></a>Radius Reduction半径缩减</h5><p>每个hit point都有一个半径R(x)，我们的目标是，半径内的光子数量累计增加时，减少半径。</p>
<p><img src="/PPM%20Note/image-20220515211027302.png" alt="image-20220515211027302"></p>
<p>hit point x的密度d(x)，使用上面的公式就可以算，假设已经做了一些photon tracing了，在x处累计了N(x)的光子，如果这个时候在做一个photon tracing pass，并且在R(x)范围内又找到M(x)个光子，我们可以把新的M(x)个光子加上去<br>$$<br>\hat d(x)&#x3D;\frac{N(x)+M(x)}{\pi R(x)^2}<br>$$<br>下一步就是用dR(x)来减少半径R(x)，如果我们假设半径R(x)内的光子密度是常数，我们可以算出新的圆盘半径$\hat R(x)&#x3D;R(x)-dR(x)$ 内光子总数<br>$$<br>\hat N(x) &#x3D; \pi\hat R(x)^2\hat d(x) &#x3D; \pi(R(x)-dR(x))^2\hat d(x)<br>$$<br>为了满足辐射度估计方程中的条件 ，每一次迭代的光子总数都需要有增加的($\hat N(x)&gt;N(x)$，为了简便，使用了一个系数$\alpha \in [0,1]$ 来控制光子的比例<br>$$<br>\hat N(x) &#x3D; N(x) + \alpha M(x)<br>$$<br>也就是说，我们每次迭代可以把$\alpha M(x)$ 个新的光子加上去，可以计算出对应需要减少的半径$dR(x)$<br>$$<br>\pi(R(x)-dR(x))^2\hat d(x) &#x3D; \hat N(x)<br>\\Leftrightarrow \pi(R(x)-dR(x))^2\frac{N(x)+M(x)}{\pi R(x)^2} &#x3D; N(x) + \alpha M(x)<br>\\Leftrightarrow dR(x)  &#x3D; R(x) - R(x)\sqrt{\frac{N(x) + \alpha M(x)}{N(x)+M(x)}}<br>$$<br>所以更新的$\hat R(x)$<br>$$<br>\hat R(x)&#x3D;R(x)-dR(x)&#x3D;R(x)\sqrt{\frac{N(x) + \alpha M(x)}{N(x)+M(x)}}<br>$$<br>注意，在每个hit point，这个公式都是独立计算的。</p>
<h5 id="Flux-Correction能量修正"><a href="#Flux-Correction能量修正" class="headerlink" title="Flux Correction能量修正"></a>Flux Correction能量修正</h5><p>当hit point接收到新的M(x)个光子，我们还需要加上这些光子所携带的能量。还需要把前面计算的半径缩减考虑在内。每个hit point储存接收到的BRDF预乘后未归一化的能量。把它叫做$\tau(x,\vec w)$ ,对于N(x)个光子<br>$$<br>\tau_N(x,\vec w) &#x3D; \sum_{p&#x3D;1}^{N(x)}f_r(x,\vec w,\vec w_p)\phi_p’(x_p,\vec w_p)<br>$$<br>$\vec w$是hit point的入射光线的方向，$\vec w_p$是入射光子的方向，$\phi_p’(x_p,\vec w_p)$ 是光子p携带的未归一化的能量。注意！这个阶段的能量在标准光子映射中，是没有被发出光子的数量除掉的。</p>
<p>同样的，新的M(x)个光子提供的能量<br>$$<br>\tau_M(x,\vec w) &#x3D; \sum_{p&#x3D;1}^{M(x)}f_r(x,\vec w,\vec w_p)\phi_p’(x_p,\vec w_p)<br>$$<br>如果半径是常数，那我们可以干嘛，直接把这两个能量加起来了。但是半径减少了，我们还要考虑到已经变成在半径外面的那些光子。</p>
<p>一种方法是，维护一个圆盘内所有光子的列表，半径衰减后，不在圆盘内的，就把它们移出去。 但是这个方法不实用，因为光子列表消耗太多内存了。因此，我们假设圆盘内的光照和光子密度是常数，会有以下的结果<br>$$<br>\tau_{\hat N}(x,\vec w) &#x3D; (\tau_N(x,\vec w)+\tau_M(x,\vec w))\frac{\pi \hat R(x)^2}{\pi R(x)^2}<br>\&#x3D;\tau_{N+M}(x,\vec w)\frac{\pi(R(x)\sqrt{\frac{N(x)+\alpha M(x)}{N(x)+M(x)}})^2}{\pi R(x)^2}<br>\&#x3D;\tau_{N+M}(x,\vec w)\frac{N(x)+\alpha M(x)}{N(x)+M(x)}<br>$$<br>$\tau_{\hat N}$ 就是半径缩减后$\hat N$ 个光子相关的缩减后的能量。最开始的时候，假设的是半径内的光子密度和光照是常数，这可能不正确，但是随着半径越来越小，这个结果会变得越来越正确，除了恰好位于照明不连续处的点。但这不构成问题，因为不连续的光照是未定义的，击中点恰好在不连续的位置的概率是0。</p>
<h5 id="Radiance-Evaluation辐射度估计"><a href="#Radiance-Evaluation辐射度估计" class="headerlink" title="Radiance Evaluation辐射度估计"></a>Radiance Evaluation辐射度估计</h5><p>每一次光子追踪后，我们都可以估计击中点的辐射度。回调储存的数据，包括当前半径、当前的乘以BRDF后的截断能量。估计的辐射度要乘以对应像素的权重，再加到对应像素上。</p>
<p>为了估计辐射度，我们还需要知道发射出的光子总数$N_{emitted}$ 用来归一化$\tau (x,\vec w)$ </p>
<p>辐射度估计如下<br>$$<br>L(x,\vec w) &#x3D; \int_{2\pi}f_r(x,\vec w,\vec w’)L(x,\vec w’)(\vec n\cdot\vec w’)dw’<br>\\approx\frac{1}{\Delta A}\sum_{p&#x3D;1}^nf_r(x,\vec w,\vec w’)\Delta\phi_p(x_p,\vec w_p)<br>\&#x3D;\frac{1}{\pi R(x)^2}\frac{\tau(x,\vec w)}{N_{emitted}}<br>$$<br>和正常的光子映射相似，这个公式没有限制为Lambertian材质，因为我们要把能量预先乘上BRDF再储存为$\tau(x,\vec w)$ 。</p>
<p>如果R（x）定义的圆盘位于未照明区域内，则半径R（x）不会减小（因为M（x）&#x3D; 0 ）。虽然这种情况看起来破坏了一致性，它仍然会收敛到正确的结果$L(x,\vec w) &#x3D; 0$ ，因为随着$N_{emitted}\to \infin,  \tau(x,\vec w)也不会增加，L(x,\vec w)\to0$ ，</p>
<p>总之论文根据实验数据给出N(x)和R(x)是正确收敛的，半径衰减至0，光子数量增长至无穷，辐射度也会正确收敛。渐进式的辐射度估计保证了每次迭代中每个击中点光子密度的增加，和辐射度估计方程是一致的。</p>
<p>再往后就是论文对不同方法的效果的比较了，差不多到这里就结束了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/14/TA/Graphics/Progressive%20Photon%20Mapping/" data-id="cmfe999lz002ap4uh8srn1vea" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Advanced/" rel="tag">CG Advanced</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Diary/2022-05-12" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/12/Diary/2022-05-12/">2022年5月12日 周四 小雨</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/12/Diary/2022-05-12/" class="article-date">
  <time datetime="2022-05-12T10:51:46.000Z" itemprop="datePublished">2022-05-12</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>需要纪念一下，这个日子。<br>成年人的崩溃，往往只在一瞬间。</p>
        
          <p>
            <a class="article-more-link" href="/2022/05/12/Diary/2022-05-12/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/12/Diary/2022-05-12/" data-id="cmfe999ll000ap4uh0p8h2vy7" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Diary/2022-05-11" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/10/Diary/2022-05-11/">2022年5月11日 周三</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/10/Diary/2022-05-11/" class="article-date">
  <time datetime="2022-05-10T15:57:49.000Z" itemprop="datePublished">2022-05-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>原来前面那篇就是昨天写的，太不可思议了，但其实已经过了快48小时了。<br>感觉这40多个小时经历了好多……</p>
<p>今天拍摄完了雷人的元宇宙视频，虽然其实已经超出预期了，效果竟然还不错。全程非常欢乐。<br>有好多需要处理的事，开始一件件冒头了。</p>
        
          <p>
            <a class="article-more-link" href="/2022/05/10/Diary/2022-05-11/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/10/Diary/2022-05-11/" data-id="cmfe999lh0003p4uh4cmc5wsb" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>