<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    XZYW7&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">XZYW7&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="XZYW7&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-Diary/2022-05-09" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/09/Diary/2022-05-09/">2022年5月9日 周一</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/09/Diary/2022-05-09/" class="article-date">
  <time datetime="2022-05-09T02:03:44.000Z" itemprop="datePublished">2022-05-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>E星计划结束了。就在今天凌晨。<br>一个月的时间，在课程和实践中都收获了很多。<br>但也有一些遗憾。<br>最后一天的时间完成shadow mapping，原理都明白，之前opengl上也做过。但是由于对bgfx的引擎框架不熟悉，它的framebuffer完全不会用，提取出来的深度图是错误的。<br>最终shadow mapping 也没有完成。</p>
<p>这学期也是同时在做一大堆事情。上学期像这样同时做很多事情的时候，最终是没有一件做到满意，给每件平均打70分吧。<br>这学期同样如此，这是完成的第一件，虽然也有遗憾，但我给自己能打到85分了。剩下还有好多事情，DIP，元宇宙（虽然这些不太放在心上），还有很希望做好的图形学研究进展的作业和报告。<br>要抽时间去研究PRT和photon mapping了。<br>我总是劝告自己，不要同时把很多事情揽在身上，不然最后一件都做不好。<br>但这么多事情就是同时出现了，又不能不去做（不做DIP和元宇宙行不行），只能接受了，希望这学期都能有好的结果吧</p>
        
          <p>
            <a class="article-more-link" href="/2022/05/09/Diary/2022-05-09/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/09/Diary/2022-05-09/" data-id="cmfe999lo000np4uhhu9m6w1f" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/GAMES/Real-time Environment Mapping" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/03/TA/Graphics/GAMES/Real-time%20Environment%20Mapping/">【笔记】【GAMES202】Real-time Environment Mapping实时环境光照</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/03/TA/Graphics/GAMES/Real-time%20Environment%20Mapping/" class="article-date">
  <time datetime="2022-05-03T12:04:20.000Z" itemprop="datePublished">2022-05-03</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>环境光照：认为来自无限远的（低频）光照</p>
<ul>
<li>spherical map</li>
<li>cube map</li>
</ul>
        
          <p>
            <a class="article-more-link" href="/2022/05/03/TA/Graphics/GAMES/Real-time%20Environment%20Mapping/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/03/TA/Graphics/GAMES/Real-time%20Environment%20Mapping/" data-id="cmfe999mg0059p4uhcl1u2nk8" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CG-Advanced/" rel="tag">CG Advanced</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAMES/" rel="tag">GAMES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/GAMES/Real-time Shadows" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/02/TA/Graphics/GAMES/Real-time%20Shadows/">【笔记】【GAMES202】Real-time Shadows实时阴影</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/02/TA/Graphics/GAMES/Real-time%20Shadows/" class="article-date">
  <time datetime="2022-05-02T06:13:55.000Z" itemprop="datePublished">2022-05-02</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h2 id="Real-time-Shadows"><a href="#Real-time-Shadows" class="headerlink" title="Real-time Shadows"></a>Real-time Shadows</h2><h3 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h3><p>2-pass Algorithm</p>
<ul>
<li>The light pass generates the SM</li>
<li>The camera pass uses the SM</li>
</ul>
<p>Image-space algorithm</p>
<ul>
<li>不需要场景的几何信息</li>
<li>自遮挡、走样</li>
</ul>
<p>Pass1:Render from Light</p>
<p>Pass2:Render from Eye</p>
<h4 id="Issues-Self-occlusion"><a href="#Issues-Self-occlusion" class="headerlink" title="Issues: Self occlusion"></a>Issues: Self occlusion</h4><p>一个像素内记录一个深度，在场景中，属于一个像素的一片区域，光源深度并不相同，更远的就被认为成阴影了。</p>
<h5 id="解决方式：Bias"><a href="#解决方式：Bias" class="headerlink" title="解决方式：Bias"></a>解决方式：Bias</h5><p>Adding a bias to reduce self occlusion，</p>
<p>比较深度时，增加bias，距离“明显”更远时才记为阴影。</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220501231928346.png" alt="image-20220501231928346"></p>
<h5 id="新的问题：Bias引发的悬浮Peter-Panning"><a href="#新的问题：Bias引发的悬浮Peter-Panning" class="headerlink" title="新的问题：Bias引发的悬浮Peter Panning"></a>新的问题：Bias引发的悬浮Peter Panning</h5><p>（找一个合适的Bias）或：</p>
<h5 id="Second-depth-shadow-mapping"><a href="#Second-depth-shadow-mapping" class="headerlink" title="Second-depth shadow mapping"></a>Second-depth shadow mapping</h5><p>用最小深度和次小深度的中间深度做最终的比较。（可用性不高）</p>
<h4 id="Issues-Aliasing"><a href="#Issues-Aliasing" class="headerlink" title="Issues: Aliasing"></a>Issues: Aliasing</h4><h3 id="Math-behind-shadow-mapping数学解释"><a href="#Math-behind-shadow-mapping数学解释" class="headerlink" title="Math behind shadow mapping数学解释"></a>Math behind shadow mapping数学解释</h3><p>$$<br>\int_{\Omega}f(x)g(x)dx \simeq\frac{\int_{\Omega}f(x)dx}{\int_{\Omega}dx}\cdot \int_{\Omega}g(x)dx<br>$$</p>
<p>当g(x)足够光滑，g(x)的support较小，二者满足一个，该近似比较准确。</p>
<p>在Esp的IBL-Specular中讲述了同样的&#x3D;&#x3D;split sum approximate&#x3D;&#x3D;，<br>$$<br>L_o(p,\omega_o) &#x3D; \int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos \theta_iV(p,\omega_i)d\omega_i<br>\\simeq\frac{\int_{\Omega^+}V(p,\omega_i)d\omega_i}{\int_{\Omega^+}d\omega_i}\cdot\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos \theta_id\omega_i<br>$$<br>右边代表正常的着色，左边的可见项代表阴影，分开来算再乘起来，正是shadow mapping的思想。</p>
<p>Small support: point &#x2F; directional lighting</p>
<p>Smooth integrand: diffuse bsdf &#x2F; constant radiance area lighting</p>
<p>面光源、环境光照、glossy会不太准确</p>
<h3 id="Percentage-closer-soft-shadows-PCSS"><a href="#Percentage-closer-soft-shadows-PCSS" class="headerlink" title="Percentage closer soft shadows(PCSS)"></a>Percentage closer soft shadows(PCSS)</h3><h4 id="Percentage-Closer-Filtering-PCF"><a href="#Percentage-Closer-Filtering-PCF" class="headerlink" title="Percentage Closer Filtering(PCF)"></a>Percentage Closer Filtering(PCF)</h4><ul>
<li><p>用于阴影边缘的反走样，并不适用于软阴影</p>
</li>
<li><p>阴影比较的结果进行滤波</p>
</li>
<li><p>不能将shadow map滤波，因为记录的是深度。</p>
</li>
</ul>
<p>对于世界空间的点，判断比较深度不光查找shadow map对应的一个像素，而是周围的局部区域的像素，每一个深度都进行比较，将这些值作平均</p>
<p>（如果是在阴影边缘，那么对应深度图上有阴影部分，也有照亮部分，这样能达到滤波效果）</p>
<p>Filter Size:</p>
<ul>
<li>Small-&gt;sharper</li>
<li>Large-&gt;softer</li>
</ul>
<p>将一个较大的PCF应用于硬阴影，就类似于软阴影效果 </p>
<h4 id="Percentage-closer-soft-shadows"><a href="#Percentage-closer-soft-shadows" class="headerlink" title="Percentage closer soft shadows"></a>Percentage closer soft shadows</h4><p>Filter size &lt;-&gt; blocker distance</p>
<p>阴影的软硬和遮挡物距离有关,也将决定filter size的不同。<br>$$<br>w_{Penumbra} &#x3D;(d_{Receiver}-d_{Blocker})\cdot w_{Light}&#x2F;d_{Blocker}<br>$$<br><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502002132527.png" alt="image-20220502002132527"></p>
<p>$w_{Penumbra}$ 即衡量了软阴影的范围</p>
<ul>
<li>blocker size</li>
<li>light size</li>
</ul>
<h5 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h5><p>Tips: W_light是指定的，Shadow mapping需要用点光源。</p>
<ul>
<li>Step1：Blocker search(Slow)<ul>
<li>对于一个着色点，在特定区域计算平均blocker深度（类似PCF）</li>
<li>这个区域可以是常量，也可以是启发式:<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502003207293.png" alt="image-20220502003207293"></li>
</ul>
</li>
<li>Step2: Penumbra estimation<ul>
<li>使用平均blocker深度，决定filter size</li>
</ul>
</li>
<li>Step3：Percentage Closer Filtering(Slow)</li>
<li>可以减少sample的数量来加速，但是会有噪声</li>
</ul>
<h4 id="Deeper-Look-at-PCF"><a href="#Deeper-Look-at-PCF" class="headerlink" title="Deeper Look at PCF"></a>Deeper Look at PCF</h4><p>$V(x) &#x3D; \sum_{q\in N(p)} w(p,q)\cdot\chi^+[D_{SM}(q)-D_{scene}(x)]$ </p>
<p>而不是filter shadow map：</p>
<p>$V(x)\neq\chi^+{<a href="q">w*D_{SM}</a>-D_{scene}(x)}$ </p>
<p>也不是在图像上filter</p>
<p>$V(x)\neq\sum_{q\in N(p)}w(p,q)V(q)$ </p>
<h3 id="Variance-soft-shadow-mapping（VSSM）"><a href="#Variance-soft-shadow-mapping（VSSM）" class="headerlink" title="Variance soft shadow mapping（VSSM）"></a>Variance soft shadow mapping（VSSM）</h3><p>解决PCSS在step1和step3慢的问题</p>
<p>PCSS中做平均，其实就是知道区域内阴影和照亮的比例</p>
<h4 id="Accelerate-PCF"><a href="#Accelerate-PCF" class="headerlink" title="Accelerate PCF"></a>Accelerate PCF</h4><p>将shading point对应周围的点的最近深度看作正态分布</p>
<ul>
<li>计算该区域深度的均值和方差<ul>
<li>均值<ul>
<li>MipMap</li>
<li>Summed Area Tables(SAT)</li>
</ul>
</li>
<li>方差<ul>
<li>$Var(X) &#x3D; E(X^2) - E^2(X)$ </li>
<li>$E(X^2)$ 项需要另外一个shadow map(square-depth map) 记录（总共只需要两个通道）</li>
</ul>
</li>
<li>如果假设是正态分布CDF(x)(只有数值解，没有解析解)<ul>
<li>切比雪夫不等式 $P(x&gt;t)\leq \frac{\sigma^2}{\sigma^2+(t-\mu)^2}$ （甚至不需要知道分布函数）</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502131303998.png" alt="image-20220502131303998"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Accelerate-PCSS"><a href="#Accelerate-PCSS" class="headerlink" title="Accelerate PCSS"></a>Accelerate PCSS</h4><p>计算遮挡物的平均深度</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502132700742.png" alt="image-20220502132700742" style="zoom: 67%;" />

 
<p>$$<br>\frac{N_1}{N}z_{unocc}+\frac{N_2}{N}z_{occ}&#x3D;z_{Avg}<br>$$<br>Approximation:N1&#x2F;N &#x3D; P(x&gt;t) -&gt; Chebyshev</p>
<p>需要 $Z_{unocc}$ 将其假设为t（shading point的深度-&gt;导致只有阴影接收物为平面时效果比较好）</p>
<h4 id="MipMap-and-Summed-Area-Variance-Shadow-Maps"><a href="#MipMap-and-Summed-Area-Variance-Shadow-Maps" class="headerlink" title="MipMap and Summed-Area Variance Shadow Maps"></a>MipMap and Summed-Area Variance Shadow Maps</h4><h5 id="构建SAT范围查询"><a href="#构建SAT范围查询" class="headerlink" title="构建SAT范围查询"></a>构建SAT范围查询</h5><p>前缀和算法</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502134821180.png" alt="image-20220502134821180"> </p>
<p>2D情况：</p>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502135327231.png" alt="image-20220502135327231"></p>
<h3 id="Moment-shadow-mapping"><a href="#Moment-shadow-mapping" class="headerlink" title="Moment shadow mapping"></a>Moment shadow mapping</h3><p>VSSM：在一些特定的遮挡物场景，分布与假设差别太大，可能偏黑，也可能过亮</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502140118793.png" alt="image-20220502140118793" style="zoom: 67%;" />

<p>切比雪夫不等式只有t&gt;z_avg时有效</p>
<p>解决方式：Moment（矩） Shadow Mapping</p>
<p>VSSM只用了前二阶矩</p>
<p>用前m阶矩描述，可以恢复有m&#x2F;2个阶跃的CDF</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502140821983.png" alt="image-20220502140821983" style="zoom:67%;" />

<p>4阶也正好可以用4个通道存储。</p>
<p>问题：主要在于利用Moment的Reconstruction需要比较大的开销，至于如何reconstruction，比较复杂，如果要深入了解，去看论文。</p>
<h3 id="Distance-field-soft-shadows距离场阴影"><a href="#Distance-field-soft-shadows距离场阴影" class="headerlink" title="Distance field soft shadows距离场阴影"></a>Distance field soft shadows距离场阴影</h3><ul>
<li>Distance functions：（Optimal transform）<ul>
<li>空间任何一个点到物体表面的最小距离</li>
</ul>
</li>
</ul>
<h4 id="Usage1：Ray-marching"><a href="#Usage1：Ray-marching" class="headerlink" title="Usage1：Ray marching"></a>Usage1：Ray marching</h4><ul>
<li>Ray marching（sphere tracing） to perform ray-SDF intersection<ul>
<li>在任意一点，到物体最小距离之内，不会和物体相交</li>
<li>因此在任何一点P，都可以走SDF(P)的距离</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502154558204.png" alt="image-20220502154558204"></p>
<h4 id="Usage2：Approximate-percentage-of-occlusion"><a href="#Usage2：Approximate-percentage-of-occlusion" class="headerlink" title="Usage2：Approximate percentage of occlusion"></a>Usage2：Approximate percentage of occlusion</h4><p>软阴影始终定义在面光源下</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502160104196.png" alt="image-20220502160104196" style="zoom:67%;" />

<ul>
<li><p>During ray marching</p>
<ul>
<li>任意一点的SDF，能够提供一个“safe angle”<ul>
<li>Safe angle越小，能够看到的东西越少</li>
</ul>
</li>
<li>在每一个step，计算眼睛出发的safe angle<ul>
<li>$\arcsin \frac{SDF(p)}{p-o}$ 运算量较大</li>
<li>$min{\frac{k\cdot SDF(p)}{p-o},1.0}$ ，k越大，earlier cutoff of penumbra，阴影越硬</li>
<li><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220502155552433.png" alt="image-20220502155552433"></li>
</ul>
</li>
<li>保留最小的safe angle，用来决定阴影软硬</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>快速</li>
<li>高质量</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li>需要预计算</li>
<li>大量的存储空间</li>
<li>Artifact</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/02/TA/Graphics/GAMES/Real-time%20Shadows/" data-id="cmfe999mg005cp4uh651r5ovs" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAMES/" rel="tag">GAMES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Diary/2022-04-24" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/04/24/Diary/2022-04-24/">2022年4月24日 周日</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/04/24/Diary/2022-04-24/" class="article-date">
  <time datetime="2022-04-24T07:35:29.000Z" itemprop="datePublished">2022-04-24</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>刚好又是一个周末。</p>
<p>这周怎么说呢，花了很多功夫去做N星的笔试题，之前固定好睡前看的C++教程也落下了。八选二最终也只完成了一个。抛开平时其他的杂事占用的时间，确实对这八个题目没有什么熟练度。本来简单的效果和作品就还没做过几个，突然要做完整的demo，确实比较困难。</p>
        
          <p>
            <a class="article-more-link" href="/2022/04/24/Diary/2022-04-24/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/24/Diary/2022-04-24/" data-id="cmfe999lk0008p4uhh6zw398j" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/OpenGL/C++ learning_01" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/04/21/TA/OpenGL/C++%20learning_01/">【笔记】Cherno C++ Tutorial note 01</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/04/21/TA/OpenGL/C++%20learning_01/" class="article-date">
  <time datetime="2022-04-21T03:09:14.000Z" itemprop="datePublished">2022-04-21</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>@[TOC]</p>
<h3 id="指针Pointers"><a href="#指针Pointers" class="headerlink" title="指针Pointers"></a>指针Pointers</h3><p>指针是一个整数，储存一个内存地址。</p>
<p>类型没有意义，只是在这个地址的数据是这个类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">void</span>* ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;<span class="comment">// 指针解引用，访问对应地址储存的值</span></span><br><span class="line">=========================</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>]; </span><br><span class="line"><span class="comment">// 一个char占用1个字节，分配了8个字节的内存，并返回一个指向这块内存的开始地址的指针</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span> );<span class="comment">// 为指定地址填充值</span></span><br><span class="line"><span class="keyword">delete</span>[] buffer;<span class="comment">// 删除值</span></span><br><span class="line">buffer = <span class="literal">nullptr</span>;<span class="comment">// 回收指针</span></span><br></pre></td></tr></table></figure>

<p>指针本身也只是变量，这些变量也储存在内存中（double pointers，triple pointers-指针的指针）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>]; </span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span> );</span><br><span class="line"><span class="type">char</span>** ptr = &amp;buffer;<span class="comment">// 在32位程序里，一个内存地址是32位的</span></span><br></pre></td></tr></table></figure>

<h3 id="引用Reference"><a href="#引用Reference" class="headerlink" title="引用Reference"></a>引用Reference</h3><p>指针和引用基本是一回事，引用是对某个存在变量的引用。引用本身不是一个新的变量，并不真正占用内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* b = &amp;a;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;<span class="comment">//这里引用的&amp;符号不同于指针，它是变量类型的一部分，紧跟着变量类型</span></span><br><span class="line"><span class="comment">//在这里创建了一个a的别名，ref其实不是一个实际的变量，只是a所在地址的数据的别称</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; <span class="comment">// 在这里是传值调用（passing by value）</span></span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">increment</span>(a);<span class="comment">//将a拷贝到了函数中，创造一个全新的变量value,a并不会发生改变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>* value)</span> </span>&#123;<span class="comment">//传递地址，调用a的内存地址而不是a本身给函数</span></span><br><span class="line">    (*value)++;<span class="comment">//解引用，改变地址储存的数值而不是地址本身.</span></span><br><span class="line">    <span class="comment">//递增符号会优先执行，所以添括号保证先解引用再递增</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">increment</span>(&amp;a)<span class="comment">//传递变量地址</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;<span class="comment">//引用传递,passing by reference</span></span><br><span class="line">    <span class="comment">//和传递地址是一样的，但是看起来更简单了</span></span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">increment</span>(a)</span><br></pre></td></tr></table></figure>

<p>引用只是让代码更好看了，没有什么事情是引用能做但指针不能的</p>
<p>一旦声明一个引用，就不能更改它所引用的对象</p>
<h3 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h3><p>C++支持面向过程，基于对象，面向对象，泛型编程</p>
<p>类是一种将数据和函数组织在一起的方式</p>
<p>由类类型制成的变量叫对象，新创建对象的过程叫做实例化</p>
<p>默认情况下，类成员的访问控制都是私有的，只有类内部的函数才能访问——提供公有函数访问接口</p>
<p>类内的函数称为方法（method）</p>
<h4 id="与结构体的区别"><a href="#与结构体的区别" class="headerlink" title="与结构体的区别"></a>与结构体的区别</h4><p>默认情况下，类是私有的，结构体是私有的</p>
<p>一般不对结构体使用继承，或过于复杂的功能，仅仅保持结构体为数据和简单的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">// 将公有私有变量、方法分开。</span></span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line">   	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">            m_LogLevel = level;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelError)</span><br><span class="line">            	std::cout &lt;&lt; <span class="string">&quot;[ERROR]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)</span><br><span class="line">            	std::cout &lt;&lt; <span class="string">&quot;[WARNING]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)</span><br><span class="line">            	std::cout &lt;&lt; <span class="string">&quot;[Info]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Log log;</span><br><span class="line">    log.<span class="built_in">SetLevel</span>(log.LogLevelWarning);</span><br><span class="line">    Log.<span class="built_in">Error</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    Log.<span class="built_in">warn</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    Log.<span class="built_in">Info</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    std::cin,<span class="built_in">get</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Static静态关键字"><a href="#Static静态关键字" class="headerlink" title="Static静态关键字"></a>Static静态关键字</h3><p>类外或结构体外的static修饰符在link阶段是局部的，它只对定义它的编译单元（.obj）可见</p>
<p>类内或结构体里面的static表示这部分内存是这个类的所有实例共享的，即就算实例化了很多次这个类或结构体，这个静态static变量只会有一个实例，并被共享。</p>
<p>静态方法也是如此，没有该实例的指针（this）</p>
<h4 id="类外的static。"><a href="#类外的static。" class="headerlink" title="类外的static。"></a>类外的static。</h4><p>static.cpp:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> s_Variable = <span class="number">5</span>; <span class="comment">// 这个变量在link的时候只对这个编译单元(.obj)里的东西可见</span></span><br><span class="line"><span class="comment">// static变量或函数表示在link到它实际的定义时，linker 不会再这个编译单元.obj外面寻找它的定义</span></span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> s_Variable = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; s_Variable &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">//输出10 不会与static.cpp中的static变量发生重复定义</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">=========================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> s_Variable;<span class="comment">//外部链接，会在其他编译单元里寻找定义，但如果static.cpp中是静态声明，就找不到了，静态声明使其他编译单元不能访问s_Variable,相当于私有变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; s_Variable &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类内Static"><a href="#类内Static" class="headerlink" title="类内Static"></a>类内Static</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt;std:endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">    e,x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line">    Entity e1 = &#123; <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>();<span class="comment">//2, 3 /n 5, 8</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">============================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> Entity&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt;std:endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line">    Entity e1<span class="comment">// = &#123; 5, 8 &#125;;//x和y不再是类的成员, 这种写法会报错</span></span><br><span class="line">    e<span class="number">1.</span>x = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//等同于Entity::x = 5,虽然写了e1.x，但其实并不属于类成员</span></span><br><span class="line">    e<span class="number">1.</span>y = <span class="number">8</span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>();<span class="comment">//5, 8 /n 5, 8</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//static 修饰的struct全局会共用一块内存</span></span><br><span class="line">    <span class="comment">//无法通过静态方法访问非静态的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部静态Local-Static"><a href="#局部静态Local-Static" class="headerlink" title="局部静态Local Static"></a>局部静态Local Static</h4><p>变量的</p>
<ul>
<li><p>生命周期：变量被删除前在内存中停留多久</p>
</li>
<li><p>作用域：在哪里能访问这个变量</p>
</li>
</ul>
<p>一个静态局部变量允许我们定义一个变量，生命周期是整个程序，但作用于被限制在这个函数里或任何作用域。和类内作用域的静态变量是一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;<span class="comment">//如果没有静态，则每次调用函数时，i的值被设为0,自增后输出1 </span></span><br><span class="line">    <span class="comment">//局部静态变量和在函数外定义全局变量的区别在于作用域</span></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ENUMS枚举"><a href="#ENUMS枚举" class="headerlink" title="ENUMS枚举"></a>ENUMS枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">  A,B,C  	</span><br><span class="line">      <span class="comment">//第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。</span></span><br><span class="line">      <span class="comment">// 可以指定任意数组，默认顺序</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example value = B</span><br><span class="line">&#125;</span><br><span class="line">============</span><br><span class="line"><span class="keyword">enum</span> Example : <span class="type">unsigned</span> <span class="type">char</span> &#123;<span class="comment">// 可以指定任意类型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Level</span>&#123;</span><br><span class="line">        Error, Warning, Info</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// const int LogLevelError = 0;</span></span><br><span class="line">    <span class="comment">// const int LogLevelWarning = 1;</span></span><br><span class="line">    <span class="comment">// const int LogLevelInfo = 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Constructor构造函数"><a href="#Constructor构造函数" class="headerlink" title="Constructor构造函数"></a>Constructor构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;<span class="comment">//需要一种方式，每当构造Entity实例时，需要将X，Y初始化</span></span><br><span class="line">        X = <span class="number">0.0f</span>;</span><br><span class="line">        Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt; X&lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Init</span>();</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line">=================================================</span><br><span class="line"><span class="keyword">class</span> Entity&#123;<span class="comment">//构造函数就是每当构建一个对象时都会调用的方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    <span class="comment">// Entity() = delete;删除默认的构造函数</span></span><br><span class="line">    <span class="built_in">Entity</span>()&#123;</span><br><span class="line">        X = <span class="number">0.0f</span>;</span><br><span class="line">        Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;<span class="comment">// 可以写许多构造函数（重载）</span></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y)&#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="function">Entity <span class="title">e2</span><span class="params">(<span class="number">10.0f</span>, <span class="number">5.0f</span>)</span></span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">2.</span><span class="built_in">Print</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用static声明类中元素时，并不会调用构造函数（因为static是所有实例共有的）</p>
<p>特殊类型的构造函数：拷贝构造函数Copy Constructor， Move Constructor</p>
<h3 id="Destructors析构函数"><a href="#Destructors析构函数" class="headerlink" title="Destructors析构函数"></a>Destructors析构函数</h3><p>constructor 在创建一个对象实例时运行，而析构函数在摧毁一个对象时运行</p>
<p>构造函数通常用来设置变量或者进行某些需要的初始化</p>
<p>当对象即将结束生命周期时，需要清理原本占用的内存，</p>
<p>析构函数同时使用堆和栈来给对象分配空间，所以如果使用new给对象分配空间，而对应的需要使用delete调用析构函数释放空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;<span class="comment">//构造函数就是每当构建一个对象时都会调用的方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">    <span class="built_in">Entity</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        X = <span class="number">0.0f</span>;</span><br><span class="line">        Y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y)&#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>()&#123;</span><br><span class="line">       	std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Created Entity!</span></span><br><span class="line"><span class="comment">0, 0</span></span><br><span class="line"><span class="comment">Destroyed Entity!</span></span><br><span class="line"><span class="comment">实例e的生命周期只在Function函数中，因此Function结束后，就调用析构函数释放了空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inheritance继承"><a href="#Inheritance继承" class="headerlink" title="Inheritance继承"></a>Inheritance继承</h3><p>（Code Duplication）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> X,Y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xa, <span class="type">float</span> ya)</span> </span>&#123;</span><br><span class="line">        X += xa;</span><br><span class="line">        Y += ya;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity&#123;<span class="comment">// Entity中任何非私有的变量或函数，Player都可用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* Name;</span><br><span class="line">    <span class="comment">/*float X,Y;</span></span><br><span class="line"><span class="comment">    void Move(float xa, float ya) &#123;</span></span><br><span class="line"><span class="comment">        X += xa;</span></span><br><span class="line"><span class="comment">        Y += ya;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt; Name &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player palyer;</span><br><span class="line">    player.<span class="built_in">PrintName</span>();</span><br><span class="line">    palyer.<span class="built_in">Move</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Virtual-Functions虚函数"><a href="#Virtual-Functions虚函数" class="headerlink" title="Virtual Functions虚函数"></a>Virtual Functions虚函数</h3><p>虚函数允许我们覆盖子类中的方法</p>
<p>比如B是A的派生类（子类），如果指定A中某虚函数方法，则可以在B中覆盖该方法做别的事</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)<span class="comment">//这里使用了初始化列表，在构造时先于函数体执行，代表将name赋值给m_Name</span></span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">PrintName</span>(e)<span class="comment">//Entity</span></span><br><span class="line">    </span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;<span class="comment">//Cherno</span></span><br><span class="line">	<span class="built_in">PrintName</span>(p)<span class="comment">//Entity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数引入了动态分派Dynamic Dispatch，通常使用VTable虚函数表实现此编译</p>
<p>虚函数表包含基类中所有虚函数的映射，在运行时映射向正确的覆写函数</p>
<p>总之，如果要覆盖函数，需要在基类中将基函数标记为虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">//std::string Getname() &#123; retrun m_Name; &#125;</span></span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">    <span class="comment">//在C++11中，可以将覆写的函数用关键词override标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">PrintName</span>(e)<span class="comment">//Entity</span></span><br><span class="line">    </span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;<span class="comment">//Cherno</span></span><br><span class="line">	<span class="built_in">PrintName</span>(p)<span class="comment">//Cherno</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数的性能代价，是需要遍历整个虚函数表查看映射</p>
<h4 id="Pure-virtual-function纯虚函数"><a href="#Pure-virtual-function纯虚函数" class="headerlink" title="Pure virtual function纯虚函数"></a>Pure virtual function纯虚函数</h4><p>纯虚函数允许我们定义一个在基类中没有实现的函数，然后迫使在子类中实际实现</p>
<p>在接口中，类仅仅包含未实现的方法并充当一种勉强的模板,这种类无法实例化，必须在子类中实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="comment">//std::string Getname() &#123; retrun m_Name; &#125;</span></span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">    <span class="comment">//在C++11中，可以将覆写的函数用关键词override标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Entity* e = new Entity();</span></span><br><span class="line">    <span class="comment">// PrintName(e)//Entity无法再实例化Entity类</span></span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintName</span>(e);</span><br><span class="line">    </span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;<span class="comment">//Cherno</span></span><br><span class="line">	<span class="built_in">PrintName</span>(p)<span class="comment">//Cherno</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当一个类提供所有纯虚函数的实现，才能实例化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> : <span class="keyword">public</span> Printable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">    std::string GetClassName <span class="keyword">override</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">Getname</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; retrun m_Name; &#125;</span><br><span class="line">     std::string GetClassName <span class="keyword">override</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;GetClassNmae &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="comment">// PrintName(e)//Entity</span></span><br><span class="line">    <span class="built_in">Print</span>(e)<span class="comment">//Entity</span></span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p-&gt;GetName() &lt;&lt; std::endl;//Cherno</span></span><br><span class="line">	<span class="comment">// PrintName(p)//Cherno</span></span><br><span class="line">    <span class="built_in">Print</span>(p)<span class="comment">// Player,如果没有在Player中定义，调用的是Entity中的override，输出Entity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Visibility访问控制"><a href="#Visibility访问控制" class="headerlink" title="Visibility访问控制"></a>Visibility访问控制</h3><p>本质指类中的成员数据及函数的可访问性</p>
<p>基本的访问控制修饰符：public公有， protected保护， private私有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">int</span> X,Y;<span class="comment">// 默认私有,意味着只有Entity类内才能访问这些变量，包括读写（除非是friend）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        X = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;<span class="comment">//Player的构造函数也不能访问Entity的私有变量</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> example[<span class="number">5</span>]; <span class="comment">//声明并分配空间</span></span><br><span class="line">example[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; example[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; example &lt;&lt; std::endl;<span class="comment">//输出example的地址，这是一个指针类型</span></span><br><span class="line"><span class="type">int</span>* ptr = example;</span><br><span class="line">*(ptr<span class="number">+2</span>) = <span class="number">6</span>;<span class="comment">//example[2] = 6,example地址后移两个int的空间并解引用，得到example[2]的值赋值为6</span></span><br></pre></td></tr></table></figure>

<p> new 运算符动态分配内存空间，</p>
<p>delete 运算符释放，否则即便局部作用域的程序运行完毕，内存也不会被回收。</p>
<p>为class分配内存空间时，还会同时运行构造函数。</p>
<p>实例的地址所指向的就是成员变量的地址；但如果用new关键字来分配，为成员变量建立了一个指针，实例的地址指向的是指针的地址。</p>
<h3 id="Strings字符串"><a href="#Strings字符串" class="headerlink" title="Strings字符串"></a>Strings字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line"><span class="comment">// 字符串在内存中末尾需要有0 填充作终止符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name2[<span class="number">6</span>] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">std::cout&lt;&lt;name2&lt;&lt;std::endl;<span class="comment">//输出的Cherno后面会跟随后面内存所对应的无意义的ASCII码，如锟斤拷</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name2[<span class="number">7</span>] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>，<span class="number">0</span>&#125;</span><br><span class="line">std::cout&lt;&lt;name2&lt;&lt;std::endl;<span class="comment">// 加上终止符，能正常输出Cherno</span></span><br><span class="line">name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="standard-string"><a href="#standard-string" class="headerlink" title="standard string"></a>standard string</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    <span class="comment">//std string 有一个构造函数，接受一个char ptr或const char ptr</span></span><br><span class="line">    <span class="comment">//这里是（const char[7]）</span></span><br><span class="line">    <span class="comment">//std string 还有一些成员函数可以使用</span></span><br><span class="line">    <span class="comment">//std::string name = &quot;Cherno&quot; + &quot;hello!&quot;;这是不可以的，这相当于把两个数组相加</span></span><br><span class="line">    name += <span class="string">&quot;hello!&quot;</span>;<span class="comment">//这是可以的，将一个指针和name相加，利用string的重载+ 拼接字符串</span></span><br><span class="line">    std::string name2 = std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>) + “hello!<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    //这也是可以的</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="string-literal"><a href="#string-literal" class="headerlink" title="string literal"></a>string literal</h4><p>字符串是不可变的。默认为const，在内存中只读</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正如上面所说，字符串的末尾默认有\0的填充，作为终止符</span></span><br><span class="line"><span class="comment">//&quot;Che\0rno&quot; =&quot;Che\0rno\0&quot;</span></span><br><span class="line"><span class="comment">//实际的字符长度因为中间的终止符，只有3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;Cherno&quot;</span><span class="comment">// 将它定义为数组，而不是字符串或字符串指针，就可以修改了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="string">u8&quot;Cherno&quot;</span>;<span class="comment">//每个字符一个字节</span></span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* name2 = <span class="string">L&quot;Cherno&quot;</span>;<span class="comment">//宽指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char16_t</span>* name3 = <span class="string">u&quot;Cherno&quot;</span>;<span class="comment">//每个字符两个字节的16位字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char32_t</span>* name4 = <span class="string">U&quot;Cherno&quot;</span>;<span class="comment">//32位字符或每个字符四个字节</span></span><br></pre></td></tr></table></figure>

<p>在C++14中，还可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line">std::string name0 = <span class="string">&quot;Cherno&quot;</span>s + <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::wstring name0 = <span class="string">L&quot;Cherno&quot;</span>s + <span class="string">L&quot;hello&quot;</span>;</span><br><span class="line">std::u32string name0 = <span class="string">U&quot;Cherno&quot;</span>s + <span class="string">U&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//R前缀</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* example = <span class="string">R&quot;(Line1</span></span><br><span class="line"><span class="string">Line2</span></span><br><span class="line"><span class="string">Line3</span></span><br><span class="line"><span class="string">Line4)&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Const常量"><a href="#Const常量" class="headerlink" title="Const常量"></a>Const常量</h3><p>就像一个承诺，认为一个变量不改变，但是否信守承诺还是取决于你自己。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">90</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a =<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">// 意味着不能再更改指针的内容，但是可以读取,也可以更改指针。</span></span><br><span class="line">*a = <span class="number">2</span>；<span class="comment">//不可操作</span></span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE； <span class="comment">//可以操作</span></span><br><span class="line">================================</span><br><span class="line"><span class="comment">//也等同于:    </span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">=================================</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">// 完全相反，不能更改指针，但可以更改指针的内容</span></span><br><span class="line">*a = <span class="number">2</span>;<span class="comment">// 可以操作</span></span><br><span class="line">a = (<span class="type">int</span>*)&amp;MAX_AGE；<span class="comment">// 不可操作</span></span><br><span class="line">================================</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_X,m_Y;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> var;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">// 此方法不会修改任何类成员变量，是一种只读方法</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_X = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        m_X = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">// 此方法的指针和此方法都不能更改，且不会修改任何成员变量。</span></span><br><span class="line">        retrun m_X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;e.<span class="built_in">GetX</span>()&lt;&lt;std::end;;</span><br><span class="line">    <span class="comment">//因为这里是引用了常量，因此不能对类有任何修改，在调用类方法时，也只能调用只读方法，如果没有类方法没有const，则不能调用，因为无法保证没有更改类成员。</span></span><br><span class="line">    <span class="comment">//有时同名的类方法会有const版本和无const版本，在这里调用时会自动使用const版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutable关键字"><a href="#Mutable关键字" class="headerlink" title="Mutable关键字"></a>Mutable关键字</h4><p>与const共同使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_DebugCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		m_DebugCount++;<span class="comment">//在这里，本来该方法不能修改类成员变量，但mutable是例外，可以修改了,mutable 将其标记为可变的。</span></span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lambda</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">auto</span> f = []() &#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;<span class="comment">//lambada函数</span></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]() &#123;<span class="comment">//传地址</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() &#123;<span class="comment">//传值</span></span><br><span class="line">    x++;<span class="comment">//在这里因为是值传递，相当于用新的变量储存，x不会发生改变</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    x++;<span class="comment">//外部的x变量仍然不会改变</span></span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl;<span class="comment">//9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f</span>();<span class="comment">//x = 8</span></span><br></pre></td></tr></table></figure>

<h3 id="Member-Initializer-Lists成员初始化列表"><a href="#Member-Initializer-Lists成员初始化列表" class="headerlink" title="Member Initializer Lists成员初始化列表"></a>Member Initializer Lists成员初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    &#125;<span class="comment">//可以使用初始化列表来完成：</span></span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Score</span>(<span class="number">0</span>)<span class="comment">//需要按照声明顺序定义</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    	：<span class="built_in">m_Name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_Name = name;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entiyt e0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，实际上在不同的构造函数中，如果对</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    Example m_Example;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    	m_Example = <span class="built_in">Example</span>(<span class="number">8</span>)<span class="comment">////调用了构造函数，不带参数，来源于m_Example声明。也调用了参数为8的构造函数。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Example</span>(<span class="built_in">Example</span>(<span class="number">8</span>))，<span class="built_in">m_Example</span>(<span class="number">8</span>)<span class="comment">//只调用一次参数为8的构造函数，节约性能。</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    	：<span class="built_in">m_Name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_Name = name;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ternary-Operators三元操作符"><a href="#Ternary-Operators三元操作符" class="headerlink" title="Ternary Operators三元操作符"></a>Ternary Operators三元操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s_Level&gt;<span class="number">5</span>)&#123;</span><br><span class="line">    s_Speed = <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s_Speed = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">s_Speed = s_Level&gt;<span class="number">5</span> ? <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">std::string rank = s_Level &gt; <span class="number">10</span> ?<span class="string">&quot;Master&quot;</span>: <span class="string">&quot;Beginner&quot;</span>;<span class="comment">//三元操作符能做到更快</span></span><br><span class="line">std::string rank;<span class="comment">//需要先声明，并调用构造函数</span></span><br><span class="line"><span class="keyword">if</span>(s_Level&gt;<span class="number">10</span>)</span><br><span class="line">    rank = <span class="string">&quot;Master&quot;</span>;<span class="comment">//还要进行重载</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    rank = <span class="string">&quot;Beginner&quot;</span>;</span><br><span class="line"></span><br><span class="line">s_Speed = s_Level &gt; <span class="number">5</span> ? s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line">s_Speed = s_Level &gt; <span class="number">5</span> ? (s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> ) : <span class="number">5</span>;</span><br><span class="line">s_Speed = s_Level &gt; <span class="number">5</span> &amp;&amp; s_Level &lt; <span class="number">100</span> ? s_Level &gt; <span class="number">10</span> ? <span class="number">15</span> : <span class="number">10</span> : <span class="number">5</span>;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/21/TA/OpenGL/C++%20learning_01/" data-id="cmfe999lw001np4uh4lw40o4g" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Diary/2022-04-10" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/04/10/Diary/2022-04-10/">2022年4月10日 周日</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/04/10/Diary/2022-04-10/" class="article-date">
  <time datetime="2022-04-10T11:19:08.000Z" itemprop="datePublished">2022-04-10</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>​		原本以为结束了可视化的项目，就能放松一段时间，谁知道，清明节的假期就是仅有的放松时间。</p>
<p>​		在三月的时候，其实投递的很多简历都没有消息了，还挂了几家。但是那时候由于重心放在可视化项目，因此没有放在心上。（就连说好的更新博客也鸽了很长时间）直到现在，剩下的几家也都没有消息……就只有耐心等了，希望暑假能有班上。</p>
        
          <p>
            <a class="article-more-link" href="/2022/04/10/Diary/2022-04-10/">
              Read More...
            </a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/10/Diary/2022-04-10/" data-id="cmfe999lj0005p4uh5pjycdq9" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-TA/Graphics/GAMES/Ray Tracing Note" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/03/19/TA/Graphics/GAMES/Ray%20Tracing%20Note/">【笔记】【GAMES101】Ray Tracing Note</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/03/19/TA/Graphics/GAMES/Ray%20Tracing%20Note/" class="article-date">
  <time datetime="2022-03-18T20:15:58.000Z" itemprop="datePublished">2022-03-19</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <p>@[TOC]</p>
<h2 id="Whitted-Style-Ray-Tracing"><a href="#Whitted-Style-Ray-Tracing" class="headerlink" title="Whitted-Style Ray Tracing"></a>Whitted-Style Ray Tracing</h2><h3 id="Ray-Casting"><a href="#Ray-Casting" class="headerlink" title="Ray Casting"></a>Ray Casting</h3><p>基于针孔相机模型</p>
<p>从眼睛向某个像素投射光线，击中场景中最近的物体相交点，（解决深度测试），连接交点与光源，判定遮挡（解决阴影），如果没有遮挡，则依据着色模型进行着色。</p>
<h3 id="Recursive-（Whitted-Style）Ray-Tracing"><a href="#Recursive-（Whitted-Style）Ray-Tracing" class="headerlink" title="Recursive （Whitted-Style）Ray Tracing"></a>Recursive （Whitted-Style）Ray Tracing</h3><p>依据镜面反射和折射，计算出反射光线和折射光线，进行递归计算</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220304230619622.png" alt="image-20220304230619622" style="zoom:50%;" />

<h3 id="光线求交"><a href="#光线求交" class="headerlink" title="光线求交"></a>光线求交</h3><h4 id="Ray-Equation"><a href="#Ray-Equation" class="headerlink" title="Ray Equation"></a>Ray Equation</h4><p>$r(t)&#x3D;o+td ,  0\le t\le+ \infin$</p>
<h4 id="与球求交"><a href="#与球求交" class="headerlink" title="与球求交"></a>与球求交</h4><p>$p:(p-c)^2-R^2&#x3D;0$ ,联立$(o+td-c)^2-R^2&#x3D;0$，求解得到正的、较小的t值，可推广至一般隐式曲面。</p>
<h4 id="与三角形求交"><a href="#与三角形求交" class="headerlink" title="与三角形求交"></a>与三角形求交</h4><h5 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h5><ol>
<li>光线与平面求交</li>
</ol>
<p>​	定义平面：一个方向（法线方向）与一个点（平面上的点）,</p>
<p>​	$p:(p-p^{‘}) \cdot N  \to ax+by+cz+d&#x3D;0$ ,同样代入求解,$t&#x3D;\frac{(p^{‘}-o)\cdot N}{d\cdot N}$，检验$0\le t\le+ \infin$</p>
<ol start="2">
<li>判定交点是否在三角形内（叉乘）</li>
</ol>
<h5 id="Moller-Trumbore-Algorithm"><a href="#Moller-Trumbore-Algorithm" class="headerlink" title="Moller Trumbore Algorithm"></a>Moller Trumbore Algorithm</h5><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220304233012291-16476226716761.png" alt="image-20220304233012291" style="zoom:50%;" />

<p>假设光线和三角形平面有一个交点，则该点既可以用光线方程描述，也可以用三角形的重心坐标描述，以此构建方程，确定重心坐标非负，即可判定光线是否和三角形相交</p>
<h4 id="光线与表面求交的加速"><a href="#光线与表面求交的加速" class="headerlink" title="光线与表面求交的加速"></a>光线与表面求交的加速</h4><h5 id="简单的光线-场景求交"><a href="#简单的光线-场景求交" class="headerlink" title="简单的光线-场景求交"></a>简单的光线-场景求交</h5><ol>
<li>测试光线和每个物体的交点</li>
<li>找到最近的交点（最小的t）</li>
</ol>
<h5 id="包围盒Bounding-Volumes"><a href="#包围盒Bounding-Volumes" class="headerlink" title="包围盒Bounding Volumes"></a>包围盒Bounding Volumes</h5><h6 id="轴对齐包围盒AABB"><a href="#轴对齐包围盒AABB" class="headerlink" title="轴对齐包围盒AABB"></a>轴对齐包围盒AABB</h6><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220304234531792.png" alt="image-20220304234531792" style="zoom:50%;" />

<p>对于三维的情况</p>
<ul>
<li>只有当光线进入了所有的投影对面，光线才进入了盒子</li>
<li>当光线离开了任意一个对面，光线就离开了盒子</li>
</ul>
<p>对于每个对面，计算$t_{min}和t_{max}$，对于三维盒子，$t_{enter}&#x3D;max(t_{min}),t_{exit}&#x3D;min(t_{max})$</p>
<p>如果进入时间小于离开时间，光线则在这段时间内在盒子里，即有交点</p>
<p>因为正的t才是有意义的，只要$t_{enter}&lt;t_{exit} {&amp;&amp;}t_{exit}\ge0$，则光线与盒子有交点，如果此时$t_{enter}&lt;0$，表示光线出发点在盒子当中。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220304235816614.png" alt="image-20220304235816614" style="zoom:50%;" />

<h2 id="加速结构"><a href="#加速结构" class="headerlink" title="加速结构"></a>加速结构</h2><h3 id="空间划分（Spatial-Partitions）"><a href="#空间划分（Spatial-Partitions）" class="headerlink" title="空间划分（Spatial Partitions）"></a>空间划分（Spatial Partitions）</h3><h4 id="八叉树Oct-Tree-KD-Tree-BSP-Tree"><a href="#八叉树Oct-Tree-KD-Tree-BSP-Tree" class="headerlink" title="八叉树Oct-Tree &#x2F; KD-Tree &#x2F; BSP-Tree"></a>八叉树Oct-Tree &#x2F; KD-Tree &#x2F; BSP-Tree</h4><h4 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h4><p>物体只存在叶子节点中</p>
<p>光线只与被判定相交的叶子结点中所有物体判定求交</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220305161528199-16476227401752.png" alt="image-20220305161528199" style="zoom:50%;" />

<h4 id="BVH（Bounding-Volume-Hierarchy"><a href="#BVH（Bounding-Volume-Hierarchy" class="headerlink" title="BVH（Bounding Volume Hierarchy)"></a>BVH（Bounding Volume Hierarchy)</h4><ul>
<li><p>解决物体与包围盒相交、一个物体出现在多个叶子结点的问题</p>
</li>
<li><p>找到一个包围盒，递归地把物体进行划分，重新构建包围盒</p>
</li>
<li><p>选取节点中最长的轴进行划分</p>
</li>
<li><p>取在中间的物体进行节点划分</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220305162233644.png" alt="image-20220305162233644" style="zoom:50%;" />

<p>场景发生变化，则需要重新构建BVH</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220305162838657.png" alt="image-20220305162838657" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220305162847780.png" alt="image-20220305162847780" style="zoom:50%;" />

<h2 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h2><p>Why,What,How</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="Radiant-Energy-and-Flux"><a href="#Radiant-Energy-and-Flux" class="headerlink" title="Radiant Energy and Flux"></a>Radiant Energy and Flux</h4><ul>
<li><p>Radiant Energy是电磁辐射的能量，$Q[J&#x3D;Joule]$</p>
</li>
<li><p>Radiant flux(power) 是单位时间的能量，$\Phi &#x3D;\frac{dQ}{dt} [W&#x3D;Watt][lm&#x3D;lumen]$,lumen衡量光源亮度</p>
</li>
</ul>
<h4 id="Solid-Angles"><a href="#Solid-Angles" class="headerlink" title="Solid Angles"></a>Solid Angles</h4><p>Anlge：$\theta&#x3D;\frac{l}{r}$</p>
<p>Solid Angle:$\Omega&#x3D;\frac{A}{r^2}$</p>
<p>球有 $4\pi$ 的立体角</p>
<p>Differential Solid Angle：</p>
<p>$dA&#x3D;(rd\theta)(r \sin\theta d\phi)&#x3D;r^2\sin\theta d\theta d\phi$</p>
<p>$d\omega&#x3D;\frac{dA}{r^2}&#x3D;\sin\theta d\theta d\phi$</p>
<h4 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h4><p>单位立体角的power<br>$$<br>I(\omega)&#x3D;\frac{d\Phi}{d\omega}[\frac{W}{sr}][\frac{lm}{sr}&#x3D;cd&#x3D;candela]<br>$$</p>
<h4 id="Irradiance（辐射照度）"><a href="#Irradiance（辐射照度）" class="headerlink" title="Irradiance（辐射照度）"></a>Irradiance（辐射照度）</h4><p>单位面积的power:The power per(perpendicular&#x2F;projected) unit area incident on a surface point<br>$$<br>E(x)&#x3D;\frac{d\Phi(x)}{dA}[\frac{W}{m^2}][\frac{lm}{m^2}&#x3D;lux]<br>$$</p>
<h5 id="Lambert’s-Cosine-Law"><a href="#Lambert’s-Cosine-Law" class="headerlink" title="Lambert’s Cosine Law"></a>Lambert’s Cosine Law</h5><p>$E&#x3D;\frac{\Phi}{A}\cos\theta$</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220305181403183.png" alt="image-20220305181403183" style="zoom:50%;" />

<h4 id="Radiance-辐射率"><a href="#Radiance-辐射率" class="headerlink" title="Radiance(辐射率)"></a>Radiance(辐射率)</h4><p>物体表面单位立体角、单位投射面积的power:The power emitted,reflected,transmitted or received by a surface, per unit solid angle,per projected unit area</p>
<p>&#x3D;&#x3D;这里为什么cos在下面呢？这部分光线本身所在面积A，而由于角度，表面测量的面积为$\frac{A}{\cos\theta}$,因此，代表着该表面上的辐射照度Irradiance,其实增加了&#x3D;&#x3D;，而上面Lambert‘s Cosine Law定义的是表面面积为A，刚好相反。<br>$$<br>L(p,\omega)&#x3D;\frac{d^2\Phi(p,\omega)}{d\omega dA \cos\theta}[\frac{W}{sr\ m^2}][\frac{cd}{m^2}&#x3D;\frac{lm}{sr\ m^2}&#x3D;nit]<br>$$<br><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220305234631162.png" alt="image-20220305234631162" style="zoom:50%;" /></p>
<h5 id="Incident-Radiance"><a href="#Incident-Radiance" class="headerlink" title="Incident Radiance"></a>Incident Radiance</h5><p>光线从某个方向到达表面单位立体角的Irradiance<br>$$<br>L_i(p,\omega)&#x3D;\frac{dE(p)}{d\omega\cos\theta}<br>$$</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220305234924339.png" alt="image-20220305234924339" style="zoom:50%;" />

<h5 id="Exiting-Radiance"><a href="#Exiting-Radiance" class="headerlink" title="Exiting Radiance"></a>Exiting Radiance</h5><p>光线离开表面单位投射面积上的Intensity<br>$$<br>L(p,\omega)&#x3D;\frac{dI(p,\omega)}{dA\cos\theta}<br>$$</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220305235512827.png" alt="image-20220305235512827" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306001005140.png" alt="image-20220306001005140" style="zoom:50%;" />

<h3 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h3><p>微小表面从某个微小方向上接受的irradiance，分配到某个方向</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306002133557.png" alt="image-20220306002133557" style="zoom:50%;" />

<p>BRDF告诉我们，光线从每个吸收方向反射多少到每个出射方向</p>
<p>任意一个出射方向的radiance微分，除以入射点上的irradiance微分</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306002710943.png" alt="image-20220306002710943" style="zoom:50%;" />

<h3 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h3><p>对于一个出射方向的radiance，等于BRDF乘以每一个入射方向的radiance进行积分（把每个方向的入射光线对出射方向radiance的贡献加起来）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306003241967.png" alt="image-20220306003241967" style="zoom:50%;" />

<h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><p>即反射方程加自发光项</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306003933911.png" alt="image-20220306003933911" style="zoom:50%;" />

<h4 id="深入理解渲染方程："><a href="#深入理解渲染方程：" class="headerlink" title="深入理解渲染方程："></a>深入理解渲染方程：</h4><p>考虑一个点光源在一个反射方向上的渲染方程</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306004433528.png" alt="image-20220306004433528" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306004443153.png" alt="image-20220306004443153" style="zoom:50%;" />

<p>那么由这种情况可以推测，如果是面光源，则只需要对面光源进行积分（计算直接光照时可以使用）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306004607488.png" alt="image-20220306004607488" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306004823056.png" alt="image-20220306004823056" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306005126998.png" alt="image-20220306005126998" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306005304523.png" alt="image-20220306005304523" style="zoom:50%;" />



<h2 id="蒙特卡洛路径追踪——求解渲染方程"><a href="#蒙特卡洛路径追踪——求解渲染方程" class="headerlink" title="蒙特卡洛路径追踪——求解渲染方程"></a>蒙特卡洛路径追踪——求解渲染方程</h2><h3 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h3><p>计算定积分 $\int_a^bf(x)dx$ ，在积分域随机采样 $X_i \sim p(x)$ ，蒙特卡洛积分 $F_N&#x3D;\frac{1}{N}\sum_{i&#x3D;1}^N \frac{f(X_i)}{p(X_i)}$,以采样点的概率为权重，对采样的函数值进行加权求和。</p>
<p>推导<br>$$<br>利用样本均值对随机变量f(x)的无偏估计<br>\E(g(x))&#x3D;\int_{x\in S}g(x)p(x)d\mu \approx \frac{1}{N}\sum_{i&#x3D;1}^N g(x_i)<br>\通常更希望估计单个函数的积分，因此令f(x)&#x3D;g(x)p(x)<br>\\int_{x\in S}f(x)d\mu\approx\frac{1}{N}\sum_{i&#x3D;1}^N\frac{f(x_i)}{p(x_i)}<br>$$</p>
<h3 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Whitted Style ray tracing 中总是光滑的物体，产生reflections和refractions，在表面根据光照模型计算颜色，直到diffuse表面才发生停止。无法渲染复杂材质，也无法表现diffuse表面之间的反射。</p>
<h4 id="求解渲染方程"><a href="#求解渲染方程" class="headerlink" title="求解渲染方程"></a>求解渲染方程</h4><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306191509519.png" alt="image-20220306191509519" style="zoom:50%;" />

<h5 id="忽略自发光项的直接光照情况，"><a href="#忽略自发光项的直接光照情况，" class="headerlink" title="忽略自发光项的直接光照情况，"></a>忽略自发光项的直接光照情况，</h5><p>$L_o(p,\omega_o)&#x3D;\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_o,\omega_i)(n\cdot \omega_i)d\omega_i$ ，使用蒙特卡洛积分求解</p>
<p>此时 $f(x)&#x3D;L_i(p,\omega_i)f_r(p,\omega_o,\omega_i)(n\cdot \omega_i)$ ,$p(\omega_i)&#x3D;\frac{1}{2\pi}$(半球面均匀采样)<br>$$<br>L_o(p,\omega_o)&#x3D;\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_o,\omega_i)(n\cdot \omega_i)d\omega_i<br>\\approx\frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{L_i(p,\omega_i)f_r(p,\omega_o,\omega_i)(n\cdot \omega_i)}{p(\omega_i)}<br>$$<br><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306192828414.png" alt="image-20220306192828414" style="zoom:50%;" /></p>
<h5 id="间接光照"><a href="#间接光照" class="headerlink" title="间接光照"></a>间接光照</h5><p>等同于从P点观测Q点的直接光照。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306193020106.png" alt="image-20220306193020106" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306193055533.png" alt="image-20220306193055533" style="zoom:50%;" />

<h5 id="递归光线数量"><a href="#递归光线数量" class="headerlink" title="递归光线数量"></a>递归光线数量</h5><p>取N&#x3D;1，反射的光线则不会爆炸。（在pdf采样出的光线中，随机选取一个）</p>
<p>与之相对的，需要增加每个像素的光线路径采样数，将radiance取平均。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306193813503.png" alt="image-20220306193813503" style="zoom:50%;" />

<p>在这一部分当中，将摄像机位置和像素连线，就隐式构成了透视投影。如果直接按像素平面的法向投射光线，则形成正交投影。</p>
<h5 id="递归出口"><a href="#递归出口" class="headerlink" title="递归出口"></a>递归出口</h5><p>真实场景光线弹射无数次，但是在计算机中需要递归出口。因此引入了RR（Russian Roulette）</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306194500300.png" alt="image-20220306194500300" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306194555964.png" alt="image-20220306194555964" style="zoom:50%;" />

<p>在生存概率为P的情况下，光线弹射次数的期望是多少？$1&#x2F;p$ </p>
<h5 id="采样光源"><a href="#采样光源" class="headerlink" title="采样光源"></a>采样光源</h5><img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306205859562.png" alt="image-20220306205859562" style="zoom:50%;" />

<p>很难击中光源。</p>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306210040279.png" alt="image-20220306210040279" style="zoom:50%;" />

<p>渲染方程是在半球面上进行采样，因此需要将渲染方程写成对光源上的dA积分</p>
<p>因为只对光源部分进行积分，所以使用蒙特卡洛积分求解时，积分域只在光源上，因此取光源面积A，pdf&#x3D;1&#x2F;A</p>
<p>只需要求dw与dA的关系</p>
<p>将dA投影在半球面上</p>
<p>$d\omega&#x3D;\frac{dA\cos\theta^{‘}}{\abs{\abs{x^{‘}-x}}^2}$ ,<br>$$<br>L_o(p,\omega_o)&#x3D;\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_o,\omega_i)(n\cdot \omega_i)d\omega_i<br>\&#x3D;\int_AL_i(p,\omega_i)f_r(p,\omega_o,\omega_i)\frac{\cos\theta\cos\theta^{‘}}{\abs{\abs{x^{‘}-x}}^2}dA<br>$$<br>着色结果来源于两部分</p>
<ul>
<li>光源（直接光照，不需要RR）</li>
<li>其他反射物(借鉴光照，需要RR)</li>
</ul>
<img src="https://raw.githubusercontent.com/XZYW7/PicGo/main/img/image-20220306211237150.png" alt="image-20220306211237150" style="zoom:50%;" />

<p>直接光照部分，是使用了光源采样的改写渲染方程， $pdf&#x3D;1&#x2F;A$ ，间接光照部分，还是原来的渲染方程, $pdf&#x3D;1&#x2F;2\pi$ ,</p>
<p>最后加上直接光源部分计算光源是否被遮挡</p>
<h5 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h5><h6 id="半球均匀采样"><a href="#半球均匀采样" class="headerlink" title="半球均匀采样"></a>半球均匀采样</h6><h6 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h6><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/360420413">https://zhuanlan.zhihu.com/p/360420413</a></p>
<p>​	选择更适合的pdf</p>
<h6 id="多重重要性采样"><a href="#多重重要性采样" class="headerlink" title="多重重要性采样"></a>多重重要性采样</h6><p>采样球面和光源，将其结合起来</p>
<h6 id="像素重建滤波（pixel-reconstruction-filter）"><a href="#像素重建滤波（pixel-reconstruction-filter）" class="headerlink" title="像素重建滤波（pixel reconstruction filter）"></a>像素重建滤波（pixel reconstruction filter）</h6><h6 id="gamma矫正，曲线，色彩空间，HDR"><a href="#gamma矫正，曲线，色彩空间，HDR" class="headerlink" title="gamma矫正，曲线，色彩空间，HDR"></a>gamma矫正，曲线，色彩空间，HDR</h6><p>radiance和颜色的换算过程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/19/TA/Graphics/GAMES/Ray%20Tracing%20Note/" data-id="cmfe999mf0052p4uhf4zn3hez" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Graphics/" rel="tag">Computer Graphics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAMES/" rel="tag">GAMES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/6/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>XZYW7&#39;s Blog &copy; 2025</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="XZYW7&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>